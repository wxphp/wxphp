/*
 * @author Mário Soares
 * @contributors Jefferson González
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


void php_wxAuiNotebook_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxAuiNotebook_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxAuiNotebook, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOl' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0)\n");
				#endif
				_this = new wxAuiNotebook_php((wxWindow*) object_pointer0_0);

				((wxAuiNotebook_php*) _this)->references.Initialize();
				((wxAuiNotebook_php*) _this)->references.AddReference(parent0);
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0)\n");
				#endif
				_this = new wxAuiNotebook_php((wxWindow*) object_pointer0_0, (wxWindowID) id0);

				((wxAuiNotebook_php*) _this)->references.Initialize();
				((wxAuiNotebook_php*) _this)->references.AddReference(parent0);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2)\n");
				#endif
				_this = new wxAuiNotebook_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2);

				((wxAuiNotebook_php*) _this)->references.Initialize();
				((wxAuiNotebook_php*) _this)->references.AddReference(parent0);
				((wxAuiNotebook_php*) _this)->references.AddReference(pos0);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3)\n");
				#endif
				_this = new wxAuiNotebook_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3);

				((wxAuiNotebook_php*) _this)->references.Initialize();
				((wxAuiNotebook_php*) _this)->references.AddReference(parent0);
				((wxAuiNotebook_php*) _this)->references.AddReference(pos0);
				((wxAuiNotebook_php*) _this)->references.AddReference(size0);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0)\n");
				#endif
				_this = new wxAuiNotebook_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0);

				((wxAuiNotebook_php*) _this)->references.Initialize();
				((wxAuiNotebook_php*) _this)->references.AddReference(parent0);
				((wxAuiNotebook_php*) _this)->references.AddReference(pos0);
				((wxAuiNotebook_php*) _this)->references.AddReference(size0);
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxAuiNotebook_php();

				((wxAuiNotebook_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxAuiNotebook);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxAuiNotebook_php*) _this)->evnArray);
		
		array_init(((wxAuiNotebook_php*) _this)->evnArray);
		
		((wxAuiNotebook_php*) _this)->phpObj = getThis();
		
		((wxAuiNotebook_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxAuiNotebook_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxAuiNotebook, Split)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::Split\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::Split\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long page0;
	long direction0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&page0, &direction0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page0, &direction0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::Split((size_t) page0, (int) direction0)\n\n");
				#endif
				((wxAuiNotebook_php*)_this)->Split((size_t) page0, (int) direction0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, ShowWindowMenu)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::ShowWindowMenu\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::ShowWindowMenu\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::ShowWindowMenu())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)_this)->ShowWindowMenu());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, SetUniformBitmapSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetUniformBitmapSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::SetUniformBitmapSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* size0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size0, php_wxSize_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size0, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::SetUniformBitmapSize(*(wxSize*) object_pointer0_0)\n\n");
				#endif
				((wxAuiNotebook_php*)_this)->SetUniformBitmapSize(*(wxSize*) object_pointer0_0);

				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, SetTabCtrlHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetTabCtrlHeight\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::SetTabCtrlHeight\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long height0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&height0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::SetTabCtrlHeight((int) height0)\n\n");
				#endif
				((wxAuiNotebook_php*)_this)->SetTabCtrlHeight((int) height0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, SetSelectedFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetSelectedFont\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::SetSelectedFont\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* font0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(font0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::SetSelectedFont(*(wxFont*) object_pointer0_0)\n\n");
				#endif
				((wxAuiNotebook_php*)_this)->SetSelectedFont(*(wxFont*) object_pointer0_0);

				references->AddReference(font0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, SetPageText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetPageText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::SetPageText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long page0;
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&page0, &text0, &text_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page0, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::SetPageText((size_t) page0, wxString(text0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)_this)->SetPageText((size_t) page0, wxString(text0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, SetPageImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetPageImage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::SetPageImage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	long imageId0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&n0, &imageId0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &imageId0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::SetPageImage((size_t) n0, (int) imageId0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)_this)->SetPageImage((size_t) n0, (int) imageId0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, SetPageBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetPageBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::SetPageBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long page0;
	zval* bitmap0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&page0, &bitmap0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page0, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::SetPageBitmap((size_t) page0, *(wxBitmap*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)_this)->SetPageBitmap((size_t) page0, *(wxBitmap*) object_pointer0_1));

				references->AddReference(bitmap0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, SetNormalFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetNormalFont\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::SetNormalFont\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* font0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(font0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::SetNormalFont(*(wxFont*) object_pointer0_0)\n\n");
				#endif
				((wxAuiNotebook_php*)_this)->SetNormalFont(*(wxFont*) object_pointer0_0);

				references->AddReference(font0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, SetMeasuringFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetMeasuringFont\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::SetMeasuringFont\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* font0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(font0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::SetMeasuringFont(*(wxFont*) object_pointer0_0)\n\n");
				#endif
				((wxAuiNotebook_php*)_this)->SetMeasuringFont(*(wxFont*) object_pointer0_0);

				references->AddReference(font0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, SetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetFont\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::SetFont\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* font0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(font0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::SetFont(*(wxFont*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)_this)->SetFont(*(wxFont*) object_pointer0_0));

				references->AddReference(font0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, SetArtProvider)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetArtProvider\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::SetArtProvider\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* art0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&art0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &art0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(art0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(art0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(art0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::SetArtProvider((wxAuiTabArt*) object_pointer0_0)\n\n");
				#endif
				((wxAuiNotebook_php*)_this)->SetArtProvider((wxAuiTabArt*) object_pointer0_0);

				references->AddReference(art0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, RemovePage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::RemovePage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::RemovePage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long page0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&page0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::RemovePage((size_t) page0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)_this)->RemovePage((size_t) page0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, GetTabCtrlHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetTabCtrlHeight\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::GetTabCtrlHeight\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiNotebook::GetTabCtrlHeight())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiNotebook_php*)_this)->GetTabCtrlHeight());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::GetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiNotebook::GetSelection())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiNotebook_php*)_this)->GetSelection());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, GetPageText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetPageText\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::GetPageText\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long page0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&page0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiNotebook::GetPageText((size_t) page0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxAuiNotebook_php*)_this)->GetPageText((size_t) page0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, GetPageIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetPageIndex\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::GetPageIndex\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* page_wnd0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&page_wnd0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page_wnd0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(page_wnd0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(page_wnd0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(page_wnd0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiNotebook::GetPageIndex((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiNotebook_php*)_this)->GetPageIndex((wxWindow*) object_pointer0_0));

				references->AddReference(page_wnd0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, GetPageCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetPageCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::GetPageCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiNotebook::GetPageCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiNotebook_php*)_this)->GetPageCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, GetPageBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetPageBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::GetPageBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long page0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&page0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::GetPageBitmap((size_t) page0) to return new object\n\n");
				#endif
				wxBitmap value_to_return1;
				value_to_return1 = ((wxAuiNotebook_php*)_this)->GetPageBitmap((size_t) page0);
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxBitmap));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, GetPage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetPage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::GetPage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long page_idx0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&page_idx0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page_idx0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::GetPage((size_t) page_idx0) to return object pointer\n\n");
				#endif
				wxWindow_php* value_to_return1;
				value_to_return1 = (wxWindow_php*) ((wxAuiNotebook_php*)_this)->GetPage((size_t) page_idx0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWindow_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxWindow));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, GetHeightForPageHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetHeightForPageHeight\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::GetHeightForPageHeight\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long pageHeight0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pageHeight0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pageHeight0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiNotebook::GetHeightForPageHeight((int) pageHeight0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiNotebook_php*)_this)->GetHeightForPageHeight((int) pageHeight0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, GetCurrentPage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetCurrentPage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::GetCurrentPage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::GetCurrentPage() to return object pointer\n\n");
				#endif
				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxAuiNotebook_php*)_this)->GetCurrentPage();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWindow_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxWindow));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, GetArtProvider)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetArtProvider\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::GetArtProvider\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::GetArtProvider() to return object pointer\n\n");
				#endif
				wxAuiTabArt_php* value_to_return0;
				value_to_return0 = (wxAuiTabArt_php*) ((wxAuiNotebook_php*)_this)->GetArtProvider();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiTabArt_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiTabArt));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, DeletePage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::DeletePage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::DeletePage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long page0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&page0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::DeletePage((size_t) page0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)_this)->DeletePage((size_t) page0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, DeleteAllPages)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::DeleteAllPages\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::DeleteAllPages\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::DeleteAllPages())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)_this)->DeleteAllPages());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::Create\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::Create\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOl' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)_this)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0);
				references->AddReference(pos0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)_this)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0);
				references->AddReference(pos0);
				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, ChangeSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::ChangeSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::ChangeSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiNotebook::ChangeSelection((size_t) n0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiNotebook_php*)_this)->ChangeSelection((size_t) n0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, AdvanceSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::AdvanceSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::AdvanceSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool forward0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&forward0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &forward0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::AdvanceSelection()\n\n");
				#endif
				((wxAuiNotebook_php*)_this)->AdvanceSelection();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::AdvanceSelection(forward0)\n\n");
				#endif
				((wxAuiNotebook_php*)_this)->AdvanceSelection(forward0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, AddPage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::AddPage\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::AddPage\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* page0 = 0;
	void* object_pointer0_0 = 0;
	char* caption0;
	long caption_len0;
	bool select0;
	zval* bitmap0 = 0;
	void* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zs|bO' (&page0, &caption0, &caption_len0, &select0, &bitmap0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "zs|bO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page0, &caption0, &caption_len0, &select0, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(page0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(page0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(page0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::AddPage((wxWindow*) object_pointer0_0, wxString(caption0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)_this)->AddPage((wxWindow*) object_pointer0_0, wxString(caption0, wxConvUTF8)));

				references->AddReference(page0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::AddPage((wxWindow*) object_pointer0_0, wxString(caption0, wxConvUTF8), select0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)_this)->AddPage((wxWindow*) object_pointer0_0, wxString(caption0, wxConvUTF8), select0));

				references->AddReference(page0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::AddPage((wxWindow*) object_pointer0_0, wxString(caption0, wxConvUTF8), select0, *(wxBitmap*) object_pointer0_3))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)_this)->AddPage((wxWindow*) object_pointer0_0, wxString(caption0, wxConvUTF8), select0, *(wxBitmap*) object_pointer0_3));

				references->AddReference(page0);
				references->AddReference(bitmap0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiNotebook, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiNotebook::SetSelection\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiNotebook){
				references = &((wxAuiNotebook_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long new_page0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&new_page0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &new_page0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiNotebook::SetSelection((size_t) new_page0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiNotebook_php*)_this)->SetSelection((size_t) new_page0));


				return;
				break;
			}
		}
	}

		
}
void php_wxAuiTabArt_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiTabArt_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxAuiTabArt_php* object = static_cast<wxAuiTabArt_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAuiTabArt done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
void wxAuiTabArt_php::SetSizingInfo(const wxSize& tab_ctrl_size, size_t tab_count)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::SetSizingInfo\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetSizingInfo", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxSize_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&tab_ctrl_size, le_wxSize));
	ZVAL_LONG(arguments[1], tab_count);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetSizingInfo'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiTabArt_php::SetSelectedFont(const wxFont& font)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::SetSelectedFont\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetSelectedFont", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxFont_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&font, le_wxFont));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetSelectedFont'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiTabArt_php::SetNormalFont(const wxFont& font)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::SetNormalFont\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetNormalFont", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxFont_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&font, le_wxFont));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetNormalFont'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiTabArt_php::SetMeasuringFont(const wxFont& font)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::SetMeasuringFont\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetMeasuringFont", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxFont_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&font, le_wxFont));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetMeasuringFont'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiTabArt_php::SetFlags(unsigned int flags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::SetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetFlags", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], flags);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetFlags'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiTabArt_php::SetColour(const wxColour& colour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::SetColour\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetColour", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxColour_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&colour, le_wxColour));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetColour'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiTabArt_php::SetActiveColour(const wxColour& colour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::SetActiveColour\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetActiveColour", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxColour_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&colour, le_wxColour));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetActiveColour'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
wxSize wxAuiTabArt_php::GetTabSize(wxDC& dc, wxWindow* wnd, const wxString& caption, const wxBitmap& bitmap, bool active, int close_button_state, int* x_extent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::GetTabSize\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[7];
	
	//Initilize arguments array
	for(int i=0; i<7; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetTabSize", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)wnd, le_wxWindow));
	temp_string = (char*)malloc(sizeof(wxChar)*(caption.size()+1));
	strcpy(temp_string, (const char *) caption.char_str());
	ZVAL_STRING(arguments[2], temp_string, 1);
	free(temp_string);
	object_init_ex(arguments[3], php_wxBitmap_entry);
	add_property_resource(arguments[3], _wxResource, zend_list_insert((void*)&bitmap, le_wxBitmap));
	ZVAL_BOOL(arguments[4], active);
	ZVAL_LONG(arguments[5], close_button_state);
	ZVAL_LONG(arguments[6], *x_extent);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 7, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetTabSize'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}
		return *(wxSize*) return_object;
	

}
int wxAuiTabArt_php::GetIndentSize()
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::GetIndentSize\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetIndentSize", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetIndentSize'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (int) Z_LVAL_P(return_value);
	

}
void wxAuiTabArt_php::DrawButton(wxDC& dc, wxWindow* wnd, const wxRect& in_rect, int bitmap_id, int button_state, int orientation, wxRect* out_rect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::DrawButton\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[7];
	
	//Initilize arguments array
	for(int i=0; i<7; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawButton", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)wnd, le_wxWindow));
	object_init_ex(arguments[2], php_wxRect_entry);
	add_property_resource(arguments[2], _wxResource, zend_list_insert((void*)&in_rect, le_wxRect));
	ZVAL_LONG(arguments[3], bitmap_id);
	ZVAL_LONG(arguments[4], button_state);
	ZVAL_LONG(arguments[5], orientation);
	object_init_ex(arguments[6], php_wxRect_entry);
	add_property_resource(arguments[6], _wxResource, zend_list_insert((void*)out_rect, le_wxRect));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 7, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'DrawButton'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiTabArt_php::DrawBackground(wxDC& dc, wxWindow* wnd, const wxRect& rect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::DrawBackground\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawBackground", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)wnd, le_wxWindow));
	object_init_ex(arguments[2], php_wxRect_entry);
	add_property_resource(arguments[2], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 3, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'DrawBackground'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
wxAuiTabArt* wxAuiTabArt_php::Clone()
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::Clone\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "Clone", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'Clone'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}
		return (wxAuiTabArt*) return_object;
	

}
void php_wxAuiDockArt_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiDockArt_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxAuiDockArt_php* object = static_cast<wxAuiDockArt_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAuiDockArt done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxAuiDockArt, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDockArt::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxAuiDockArt_php();

				((wxAuiDockArt_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxAuiDockArt);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxAuiDockArt_php*) _this)->evnArray);
		
		array_init(((wxAuiDockArt_php*) _this)->evnArray);
		
		((wxAuiDockArt_php*) _this)->phpObj = getThis();
		
		((wxAuiDockArt_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxAuiDockArt_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void wxAuiDockArt_php::SetMetric(int id, int new_val)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::SetMetric\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetMetric", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], id);
	ZVAL_LONG(arguments[1], new_val);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetMetric'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiDockArt_php::SetFont(int id, const wxFont& font)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::SetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetFont", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], id);
	object_init_ex(arguments[1], php_wxFont_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)&font, le_wxFont));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetFont'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
int wxAuiDockArt_php::GetMetric(int id)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::GetMetric\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetMetric", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], id);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetMetric'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (int) Z_LVAL_P(return_value);
	

}
void wxAuiDockArt_php::SetColour(int id, const wxColour& colour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::SetColour\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetColour", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], id);
	object_init_ex(arguments[1], php_wxColour_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)&colour, le_wxColour));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetColour'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
wxFont wxAuiDockArt_php::GetFont(int id)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::GetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetFont", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], id);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetFont'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}
		return *(wxFont*) return_object;
	

}
wxColour wxAuiDockArt_php::GetColour(int id)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::GetColour\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetColour", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], id);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetColour'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}
		return *(wxColour*) return_object;
	

}
void wxAuiDockArt_php::DrawSash(wxDC& dc, wxWindow* window, int orientation, const wxRect& rect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::DrawSash\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawSash", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)window, le_wxWindow));
	ZVAL_LONG(arguments[2], orientation);
	object_init_ex(arguments[3], php_wxRect_entry);
	add_property_resource(arguments[3], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 4, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'DrawSash'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiDockArt_php::DrawPaneButton(wxDC& dc, wxWindow* window, int button, int button_state, const wxRect& rect, wxAuiPaneInfo& pane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::DrawPaneButton\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[6];
	
	//Initilize arguments array
	for(int i=0; i<6; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawPaneButton", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)window, le_wxWindow));
	ZVAL_LONG(arguments[2], button);
	ZVAL_LONG(arguments[3], button_state);
	object_init_ex(arguments[4], php_wxRect_entry);
	add_property_resource(arguments[4], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
	object_init_ex(arguments[5], php_wxAuiPaneInfo_entry);
	add_property_resource(arguments[5], _wxResource, zend_list_insert((void*)&pane, le_wxAuiPaneInfo));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 6, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'DrawPaneButton'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiDockArt_php::DrawGripper(wxDC& dc, wxWindow* window, const wxRect& rect, wxAuiPaneInfo& pane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::DrawGripper\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawGripper", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)window, le_wxWindow));
	object_init_ex(arguments[2], php_wxRect_entry);
	add_property_resource(arguments[2], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
	object_init_ex(arguments[3], php_wxAuiPaneInfo_entry);
	add_property_resource(arguments[3], _wxResource, zend_list_insert((void*)&pane, le_wxAuiPaneInfo));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 4, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'DrawGripper'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiDockArt_php::DrawCaption(wxDC& dc, wxWindow* window, const wxString& text, const wxRect& rect, wxAuiPaneInfo& pane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::DrawCaption\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[5];
	
	//Initilize arguments array
	for(int i=0; i<5; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawCaption", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)window, le_wxWindow));
	temp_string = (char*)malloc(sizeof(wxChar)*(text.size()+1));
	strcpy(temp_string, (const char *) text.char_str());
	ZVAL_STRING(arguments[2], temp_string, 1);
	free(temp_string);
	object_init_ex(arguments[3], php_wxRect_entry);
	add_property_resource(arguments[3], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
	object_init_ex(arguments[4], php_wxAuiPaneInfo_entry);
	add_property_resource(arguments[4], _wxResource, zend_list_insert((void*)&pane, le_wxAuiPaneInfo));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 5, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'DrawCaption'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiDockArt_php::DrawBorder(wxDC& dc, wxWindow* window, const wxRect& rect, wxAuiPaneInfo& pane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::DrawBorder\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawBorder", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)window, le_wxWindow));
	object_init_ex(arguments[2], php_wxRect_entry);
	add_property_resource(arguments[2], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
	object_init_ex(arguments[3], php_wxAuiPaneInfo_entry);
	add_property_resource(arguments[3], _wxResource, zend_list_insert((void*)&pane, le_wxAuiPaneInfo));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 4, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'DrawBorder'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiDockArt_php::DrawBackground(wxDC& dc, wxWindow* window, int orientation, const wxRect& rect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::DrawBackground\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawBackground", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)window, le_wxWindow));
	ZVAL_LONG(arguments[2], orientation);
	object_init_ex(arguments[3], php_wxRect_entry);
	add_property_resource(arguments[3], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 4, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'DrawBackground'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void php_wxAuiManager_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxAuiManager_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxAuiManager, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* managed_wnd0 = 0;
	void* object_pointer0_0 = 0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|zl' (&managed_wnd0, &flags0)\n");
		#endif
		char parse_parameters_string[] = "|zl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &managed_wnd0, &flags0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(managed_wnd0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(managed_wnd0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(managed_wnd0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxAuiManager_php();

				((wxAuiManager_php*) _this)->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0)\n");
				#endif
				_this = new wxAuiManager_php((wxWindow*) object_pointer0_0);

				((wxAuiManager_php*) _this)->references.Initialize();
				((wxAuiManager_php*) _this)->references.AddReference(managed_wnd0);
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (unsigned int) flags0)\n");
				#endif
				_this = new wxAuiManager_php((wxWindow*) object_pointer0_0, (unsigned int) flags0);

				((wxAuiManager_php*) _this)->references.Initialize();
				((wxAuiManager_php*) _this)->references.AddReference(managed_wnd0);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxAuiManager);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxAuiManager_php*) _this)->evnArray);
		
		array_init(((wxAuiManager_php*) _this)->evnArray);
		
		((wxAuiManager_php*) _this)->phpObj = getThis();
		
		((wxAuiManager_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxAuiManager_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxAuiManager, Update)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::Update\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::Update\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::Update()\n\n");
				#endif
				((wxAuiManager_php*)_this)->Update();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, UnInit)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::UnInit\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::UnInit\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::UnInit()\n\n");
				#endif
				((wxAuiManager_php*)_this)->UnInit();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, ShowHint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::ShowHint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::ShowHint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* rect0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&rect0, php_wxRect_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::ShowHint(*(wxRect*) object_pointer0_0)\n\n");
				#endif
				((wxAuiManager_php*)_this)->ShowHint(*(wxRect*) object_pointer0_0);

				references->AddReference(rect0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, SetManagedWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::SetManagedWindow\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::SetManagedWindow\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* managed_wnd0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&managed_wnd0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &managed_wnd0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(managed_wnd0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(managed_wnd0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(managed_wnd0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::SetManagedWindow((wxWindow*) object_pointer0_0)\n\n");
				#endif
				((wxAuiManager_php*)_this)->SetManagedWindow((wxWindow*) object_pointer0_0);

				references->AddReference(managed_wnd0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, SetDockSizeConstraint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::SetDockSizeConstraint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::SetDockSizeConstraint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	double widthpct0;
	double heightpct0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'dd' (&widthpct0, &heightpct0)\n");
		#endif
		char parse_parameters_string[] = "dd";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &widthpct0, &heightpct0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::SetDockSizeConstraint(widthpct0, heightpct0)\n\n");
				#endif
				((wxAuiManager_php*)_this)->SetDockSizeConstraint(widthpct0, heightpct0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, SetFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::SetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::SetFlags\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flags0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::SetFlags((unsigned int) flags0)\n\n");
				#endif
				((wxAuiManager_php*)_this)->SetFlags((unsigned int) flags0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, SetArtProvider)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::SetArtProvider\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::SetArtProvider\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* art_provider0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&art_provider0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &art_provider0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(art_provider0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(art_provider0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(art_provider0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::SetArtProvider((wxAuiDockArt*) object_pointer0_0)\n\n");
				#endif
				((wxAuiManager_php*)_this)->SetArtProvider((wxAuiDockArt*) object_pointer0_0);

				references->AddReference(art_provider0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, SavePerspective)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::SavePerspective\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::SavePerspective\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiManager::SavePerspective().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxAuiManager_php*)_this)->SavePerspective();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, SavePaneInfo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::SavePaneInfo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::SavePaneInfo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* pane0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pane0, php_wxAuiPaneInfo_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pane0, php_wxAuiPaneInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pane0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pane0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pane0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiManager::SavePaneInfo(*(wxAuiPaneInfo*) object_pointer0_0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxAuiManager_php*)_this)->SavePaneInfo(*(wxAuiPaneInfo*) object_pointer0_0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);

				references->AddReference(pane0);

				return;
				break;
			}
		}
	}

		
}
bool wxAuiManager_php::ProcessDockResult(wxAuiPaneInfo& target, const wxAuiPaneInfo& new_pos)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiManager::ProcessDockResult\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "ProcessDockResult", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxAuiPaneInfo_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&target, le_wxAuiPaneInfo));
	object_init_ex(arguments[1], php_wxAuiPaneInfo_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)&new_pos, le_wxAuiPaneInfo));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxAuiManager::ProcessDockResult(target, new_pos);

}
PHP_METHOD(php_wxAuiManager, LoadPerspective)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::LoadPerspective\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::LoadPerspective\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* perspective0;
	long perspective_len0;
	bool update0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|b' (&perspective0, &perspective_len0, &update0)\n");
		#endif
		char parse_parameters_string[] = "s|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &perspective0, &perspective_len0, &update0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::LoadPerspective(wxString(perspective0, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiManager_php*)_this)->LoadPerspective(wxString(perspective0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::LoadPerspective(wxString(perspective0, wxConvUTF8), update0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiManager_php*)_this)->LoadPerspective(wxString(perspective0, wxConvUTF8), update0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, LoadPaneInfo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::LoadPaneInfo\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::LoadPaneInfo\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* pane_part0;
	long pane_part_len0;
	zval* pane0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sO' (&pane_part0, &pane_part_len0, &pane0, php_wxAuiPaneInfo_entry)\n");
		#endif
		char parse_parameters_string[] = "sO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pane_part0, &pane_part_len0, &pane0, php_wxAuiPaneInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(pane0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pane0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pane0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::LoadPaneInfo(wxString(pane_part0, wxConvUTF8), *(wxAuiPaneInfo*) object_pointer0_1)\n\n");
				#endif
				((wxAuiManager_php*)_this)->LoadPaneInfo(wxString(pane_part0, wxConvUTF8), *(wxAuiPaneInfo*) object_pointer0_1);

				references->AddReference(pane0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, InsertPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::InsertPane\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::InsertPane\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* window0 = 0;
	void* object_pointer0_0 = 0;
	zval* insert_location0 = 0;
	void* object_pointer0_1 = 0;
	long insert_level0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zO|l' (&window0, &insert_location0, php_wxAuiPaneInfo_entry, &insert_level0)\n");
		#endif
		char parse_parameters_string[] = "zO|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &window0, &insert_location0, php_wxAuiPaneInfo_entry, &insert_level0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(window0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(window0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(window0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(insert_location0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(insert_location0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(insert_location0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::InsertPane((wxWindow*) object_pointer0_0, *(wxAuiPaneInfo*) object_pointer0_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiManager_php*)_this)->InsertPane((wxWindow*) object_pointer0_0, *(wxAuiPaneInfo*) object_pointer0_1));

				references->AddReference(window0);
				references->AddReference(insert_location0);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::InsertPane((wxWindow*) object_pointer0_0, *(wxAuiPaneInfo*) object_pointer0_1, (int) insert_level0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiManager_php*)_this)->InsertPane((wxWindow*) object_pointer0_0, *(wxAuiPaneInfo*) object_pointer0_1, (int) insert_level0));

				references->AddReference(window0);
				references->AddReference(insert_location0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, HideHint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::HideHint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::HideHint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::HideHint()\n\n");
				#endif
				((wxAuiManager_php*)_this)->HideHint();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, GetPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::GetPane\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::GetPane\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* window1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&window1)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &window1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(window1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(window1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(window1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::GetPane(wxString(name0, wxConvUTF8)) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiManager_php*)_this)->GetPane(wxString(name0, wxConvUTF8));

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::GetPane((wxWindow*) object_pointer1_0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiManager_php*)_this)->GetPane((wxWindow*) object_pointer1_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}

				references->AddReference(window1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, GetManager)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::GetManager\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::GetManager\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* window0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&window0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &window0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(window0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(window0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(window0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxAuiManager::GetManager((wxWindow*) object_pointer0_0) to return object pointer\n\n");
				#endif
				wxAuiManager_php* value_to_return1;
				value_to_return1 = (wxAuiManager_php*) wxAuiManager::GetManager((wxWindow*) object_pointer0_0);
				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiManager_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiManager));
				}



				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, GetManagedWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::GetManagedWindow\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::GetManagedWindow\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::GetManagedWindow() to return object pointer\n\n");
				#endif
				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxAuiManager_php*)_this)->GetManagedWindow();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWindow_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxWindow));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, GetFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::GetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::GetFlags\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiManager::GetFlags())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiManager_php*)_this)->GetFlags());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, GetDockSizeConstraint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::GetDockSizeConstraint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::GetDockSizeConstraint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	double* widthpct0;
	zval* widthpct0_ref;
	double* heightpct0;
	zval* heightpct0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'dd' (widthpct0, heightpct0)\n");
		#endif
		char parse_parameters_string[] = "dd";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, widthpct0, heightpct0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &widthpct0_ref, &heightpct0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::GetDockSizeConstraint(widthpct0, heightpct0)\n\n");
				#endif
				((wxAuiManager_php*)_this)->GetDockSizeConstraint(widthpct0, heightpct0);

				size_t elements_returned0_0 = sizeof(widthpct0)/sizeof(*widthpct0);
				array_init(widthpct0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(widthpct0_ref, widthpct0[i]);
				}
				size_t elements_returned0_1 = sizeof(heightpct0)/sizeof(*heightpct0);
				array_init(heightpct0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(heightpct0_ref, heightpct0[i]);
				}

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, GetArtProvider)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::GetArtProvider\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::GetArtProvider\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::GetArtProvider() to return object pointer\n\n");
				#endif
				wxAuiDockArt_php* value_to_return0;
				value_to_return0 = (wxAuiDockArt_php*) ((wxAuiManager_php*)_this)->GetArtProvider();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiDockArt_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiDockArt));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, DetachPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::DetachPane\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::DetachPane\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* window0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&window0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &window0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(window0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(window0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(window0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::DetachPane((wxWindow*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiManager_php*)_this)->DetachPane((wxWindow*) object_pointer0_0));

				references->AddReference(window0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiManager, AddPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::AddPane\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiManager::AddPane\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiManager){
				references = &((wxAuiManager_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* window0 = 0;
	void* object_pointer0_0 = 0;
	zval* pane_info0 = 0;
	void* object_pointer0_1 = 0;
	zval* drop_pos0 = 0;
	void* object_pointer0_2 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* window1 = 0;
	void* object_pointer1_0 = 0;
	long direction1;
	char* caption1;
	long caption_len1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* window2 = 0;
	void* object_pointer2_0 = 0;
	zval* pane_info2 = 0;
	void* object_pointer2_1 = 0;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zOO' (&window0, &pane_info0, php_wxAuiPaneInfo_entry, &drop_pos0, php_wxPoint_entry)\n");
		#endif
		char parse_parameters_string[] = "zOO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &window0, &pane_info0, php_wxAuiPaneInfo_entry, &drop_pos0, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(window0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(window0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(window0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(pane_info0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pane_info0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pane_info0) != IS_NULL)
				{
						goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(drop_pos0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(drop_pos0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(drop_pos0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|ls' (&window1, &direction1, &caption1, &caption_len1)\n");
		#endif
		char parse_parameters_string[] = "z|ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &window1, &direction1, &caption1, &caption_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(window1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(window1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(window1) != IS_NULL)
				{
						goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zO' (&window2, &pane_info2, php_wxAuiPaneInfo_entry)\n");
		#endif
		char parse_parameters_string[] = "zO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &window2, &pane_info2, php_wxAuiPaneInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(window2) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(window2), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer2_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer2_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(window2) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(pane_info2) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pane_info2), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer2_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer2_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pane_info2) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::AddPane((wxWindow*) object_pointer0_0, *(wxAuiPaneInfo*) object_pointer0_1, *(wxPoint*) object_pointer0_2))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiManager_php*)_this)->AddPane((wxWindow*) object_pointer0_0, *(wxAuiPaneInfo*) object_pointer0_1, *(wxPoint*) object_pointer0_2));

				references->AddReference(window0);
				references->AddReference(pane_info0);
				references->AddReference(drop_pos0);

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::AddPane((wxWindow*) object_pointer1_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiManager_php*)_this)->AddPane((wxWindow*) object_pointer1_0));

				references->AddReference(window1);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::AddPane((wxWindow*) object_pointer1_0, (int) direction1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiManager_php*)_this)->AddPane((wxWindow*) object_pointer1_0, (int) direction1));

				references->AddReference(window1);

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::AddPane((wxWindow*) object_pointer1_0, (int) direction1, wxString(caption1, wxConvUTF8)))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiManager_php*)_this)->AddPane((wxWindow*) object_pointer1_0, (int) direction1, wxString(caption1, wxConvUTF8)));

				references->AddReference(window1);

				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::AddPane((wxWindow*) object_pointer2_0, *(wxAuiPaneInfo*) object_pointer2_1))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiManager_php*)_this)->AddPane((wxWindow*) object_pointer2_0, *(wxAuiPaneInfo*) object_pointer2_1));

				references->AddReference(window2);
				references->AddReference(pane_info2);

				return;
				break;
			}
		}
	}

		
}
void php_wxAuiPaneInfo_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiPaneInfo_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxAuiPaneInfo_php* object = static_cast<wxAuiPaneInfo_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAuiPaneInfo done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxAuiPaneInfo, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* c0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&c0, php_wxAuiPaneInfo_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &c0, php_wxAuiPaneInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(c0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(c0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(c0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxAuiPaneInfo*) object_pointer0_0)\n");
				#endif
				_this = new wxAuiPaneInfo_php(*(wxAuiPaneInfo*) object_pointer0_0);

				((wxAuiPaneInfo_php*) _this)->references.Initialize();
				((wxAuiPaneInfo_php*) _this)->references.AddReference(c0);
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxAuiPaneInfo_php();

				((wxAuiPaneInfo_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxAuiPaneInfo);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxAuiPaneInfo_php*) _this)->evnArray);
		
		array_init(((wxAuiPaneInfo_php*) _this)->evnArray);
		
		((wxAuiPaneInfo_php*) _this)->phpObj = getThis();
		
		((wxAuiPaneInfo_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxAuiPaneInfo_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxAuiPaneInfo, Window)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Window\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Window\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* w0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&w0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &w0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(w0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(w0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(w0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Window((wxWindow*) object_pointer0_0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Window((wxWindow*) object_pointer0_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}

				references->AddReference(w0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, TopDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::TopDockable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::TopDockable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::TopDockable() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->TopDockable();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::TopDockable(b0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->TopDockable(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Top)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Top\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Top\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Top() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Top();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, ToolbarPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::ToolbarPane\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::ToolbarPane\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::ToolbarPane() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->ToolbarPane();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Show)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Show\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Show\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool show0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&show0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &show0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Show() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Show();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Show(show0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Show(show0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, SetFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::SetFlag\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::SetFlag\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long flag0;
	bool option_state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lb' (&flag0, &option_state0)\n");
		#endif
		char parse_parameters_string[] = "lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0, &option_state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::SetFlag((int) flag0, option_state0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return2;
				value_to_return2 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->SetFlag((int) flag0, option_state0);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxAuiPaneInfo));
				}

				if(value_to_return2 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, SafeSet)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::SafeSet\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::SafeSet\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* source0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&source0, php_wxAuiPaneInfo_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &source0, php_wxAuiPaneInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(source0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(source0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(source0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::SafeSet(*(wxAuiPaneInfo*) object_pointer0_0)\n\n");
				#endif
				((wxAuiPaneInfo_php*)_this)->SafeSet(*(wxAuiPaneInfo*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Row)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Row\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Row\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Row((int) row0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Row((int) row0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, RightDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::RightDockable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::RightDockable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::RightDockable() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->RightDockable();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::RightDockable(b0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->RightDockable(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Right)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Right\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Right\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Right() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Right();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Resizable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Resizable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Resizable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool resizable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&resizable0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &resizable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Resizable() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Resizable();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Resizable(resizable0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Resizable(resizable0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Position)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Position\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Position\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pos0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Position((int) pos0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Position((int) pos0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, PinButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::PinButton\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::PinButton\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&visible0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::PinButton() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->PinButton();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::PinButton(visible0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->PinButton(visible0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, PaneBorder)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::PaneBorder\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::PaneBorder\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&visible0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::PaneBorder() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->PaneBorder();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::PaneBorder(visible0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->PaneBorder(visible0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Name)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Name\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Name\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* n0;
	long n_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&n0, &n_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &n_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Name(wxString(n0, wxConvUTF8)) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Name(wxString(n0, wxConvUTF8));

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Movable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Movable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Movable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Movable() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Movable();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Movable(b0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Movable(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, MinimizeButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::MinimizeButton\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::MinimizeButton\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&visible0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::MinimizeButton() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->MinimizeButton();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::MinimizeButton(visible0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->MinimizeButton(visible0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, MinSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::MinSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::MinSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* size1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size1, php_wxSize_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size1, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::MinSize((int) x0, (int) y0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return2;
				value_to_return2 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->MinSize((int) x0, (int) y0);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxAuiPaneInfo));
				}

				if(value_to_return2 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::MinSize(*(wxSize*) object_pointer1_0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->MinSize(*(wxSize*) object_pointer1_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}

				references->AddReference(size1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, MaximizeButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::MaximizeButton\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::MaximizeButton\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&visible0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::MaximizeButton() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->MaximizeButton();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::MaximizeButton(visible0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->MaximizeButton(visible0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, MaxSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::MaxSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::MaxSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* size1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size1, php_wxSize_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size1, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::MaxSize((int) x0, (int) y0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return2;
				value_to_return2 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->MaxSize((int) x0, (int) y0);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxAuiPaneInfo));
				}

				if(value_to_return2 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::MaxSize(*(wxSize*) object_pointer1_0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->MaxSize(*(wxSize*) object_pointer1_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}

				references->AddReference(size1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, LeftDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::LeftDockable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::LeftDockable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::LeftDockable() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->LeftDockable();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::LeftDockable(b0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->LeftDockable(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Left)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Left\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Left\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Left() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Left();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Layer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Layer\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Layer\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long layer0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&layer0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &layer0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Layer((int) layer0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Layer((int) layer0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, IsTopDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsTopDockable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::IsTopDockable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsTopDockable())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->IsTopDockable());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, IsToolbar)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsToolbar\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::IsToolbar\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsToolbar())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->IsToolbar());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, IsShown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsShown\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::IsShown\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsShown())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->IsShown());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, IsRightDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsRightDockable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::IsRightDockable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsRightDockable())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->IsRightDockable());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, IsResizable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsResizable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::IsResizable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsResizable())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->IsResizable());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::IsOk\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsOk())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->IsOk());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, IsMovable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsMovable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::IsMovable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsMovable())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->IsMovable());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, IsLeftDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsLeftDockable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::IsLeftDockable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsLeftDockable())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->IsLeftDockable());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, IsFloating)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsFloating\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::IsFloating\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsFloating())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->IsFloating());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, IsFloatable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsFloatable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::IsFloatable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsFloatable())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->IsFloatable());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, IsFixed)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsFixed\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::IsFixed\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsFixed())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->IsFixed());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, IsDocked)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsDocked\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::IsDocked\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsDocked())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->IsDocked());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, IsDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsDockable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::IsDockable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsDockable())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->IsDockable());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, IsBottomDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsBottomDockable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::IsBottomDockable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsBottomDockable())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->IsBottomDockable());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Icon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Icon\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Icon\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* b0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&b0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(b0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(b0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(b0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Icon(*(wxBitmap*) object_pointer0_0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Icon(*(wxBitmap*) object_pointer0_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}

				references->AddReference(b0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Hide)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Hide\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Hide\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Hide() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Hide();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, HasPinButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasPinButton\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::HasPinButton\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasPinButton())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->HasPinButton());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, HasMinimizeButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasMinimizeButton\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::HasMinimizeButton\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasMinimizeButton())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->HasMinimizeButton());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, HasMaximizeButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasMaximizeButton\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::HasMaximizeButton\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasMaximizeButton())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->HasMaximizeButton());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, HasGripperTop)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasGripperTop\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::HasGripperTop\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasGripperTop())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->HasGripperTop());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, HasGripper)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasGripper\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::HasGripper\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasGripper())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->HasGripper());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, HasFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasFlag\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::HasFlag\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flag0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasFlag((int) flag0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->HasFlag((int) flag0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, HasCloseButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasCloseButton\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::HasCloseButton\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasCloseButton())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->HasCloseButton());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, HasCaption)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasCaption\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::HasCaption\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasCaption())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->HasCaption());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, HasBorder)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasBorder\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::HasBorder\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasBorder())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)_this)->HasBorder());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, GripperTop)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::GripperTop\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::GripperTop\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool attop0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&attop0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &attop0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::GripperTop() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->GripperTop();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::GripperTop(attop0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->GripperTop(attop0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Gripper)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Gripper\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Gripper\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&visible0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Gripper() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Gripper();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Gripper(visible0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Gripper(visible0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, FloatingSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::FloatingSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::FloatingSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* size1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size1, php_wxSize_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size1, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::FloatingSize((int) x0, (int) y0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return2;
				value_to_return2 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->FloatingSize((int) x0, (int) y0);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxAuiPaneInfo));
				}

				if(value_to_return2 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::FloatingSize(*(wxSize*) object_pointer1_0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->FloatingSize(*(wxSize*) object_pointer1_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}

				references->AddReference(size1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, FloatingPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::FloatingPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::FloatingPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* pos1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pos1, php_wxPoint_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos1, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pos1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pos1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::FloatingPosition((int) x0, (int) y0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return2;
				value_to_return2 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->FloatingPosition((int) x0, (int) y0);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxAuiPaneInfo));
				}

				if(value_to_return2 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::FloatingPosition(*(wxPoint*) object_pointer1_0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->FloatingPosition(*(wxPoint*) object_pointer1_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}

				references->AddReference(pos1);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Floatable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Floatable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Floatable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Floatable() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Floatable();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Floatable(b0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Floatable(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Float)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Float\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Float\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Float() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Float();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Fixed)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Fixed\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Fixed\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Fixed() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Fixed();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Dockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Dockable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Dockable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Dockable() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Dockable();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Dockable(b0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Dockable(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, DockFixed)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::DockFixed\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::DockFixed\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::DockFixed() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->DockFixed();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::DockFixed(b0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->DockFixed(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Dock)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Dock\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Dock\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Dock() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Dock();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Direction)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Direction\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Direction\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long direction0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&direction0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &direction0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Direction((int) direction0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Direction((int) direction0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, DestroyOnClose)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::DestroyOnClose\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::DestroyOnClose\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::DestroyOnClose() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->DestroyOnClose();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::DestroyOnClose(b0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->DestroyOnClose(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, DefaultPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::DefaultPane\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::DefaultPane\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::DefaultPane() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->DefaultPane();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, CloseButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::CloseButton\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::CloseButton\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&visible0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::CloseButton() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->CloseButton();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::CloseButton(visible0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->CloseButton(visible0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, CentrePane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::CentrePane\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::CentrePane\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::CentrePane() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->CentrePane();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Centre)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Centre\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Centre\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Centre() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Centre();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, CenterPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::CenterPane\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::CenterPane\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::CenterPane() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->CenterPane();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Center)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Center\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Center\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Center() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Center();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, CaptionVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::CaptionVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::CaptionVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&visible0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::CaptionVisible() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->CaptionVisible();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::CaptionVisible(visible0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->CaptionVisible(visible0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Caption)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Caption\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Caption\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* c0;
	long c_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&c0, &c_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &c0, &c_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Caption(wxString(c0, wxConvUTF8)) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Caption(wxString(c0, wxConvUTF8));

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, BottomDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::BottomDockable\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::BottomDockable\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif
		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::BottomDockable() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->BottomDockable();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::BottomDockable(b0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->BottomDockable(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, Bottom)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Bottom\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::Bottom\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Bottom() to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->Bottom();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiPaneInfo));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiPaneInfo, BestSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::BestSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiPaneInfo::BestSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiPaneInfo){
				references = &((wxAuiPaneInfo_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* size1 = 0;
	void* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size1, php_wxSize_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size1, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::BestSize((int) x0, (int) y0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return2;
				value_to_return2 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->BestSize((int) x0, (int) y0);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxAuiPaneInfo));
				}

				if(value_to_return2 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::BestSize(*(wxSize*) object_pointer1_0) to return object reference\n\n");
				#endif
				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)_this)->BestSize(*(wxSize*) object_pointer1_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiPaneInfo));
				}

				if(value_to_return1 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}

				references->AddReference(size1);

				return;
				break;
			}
		}
	}

		
}
void php_wxAuiToolBarEvent_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiToolBarEvent_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxAuiToolBarEvent_php* object = static_cast<wxAuiToolBarEvent_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAuiToolBarEvent done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxAuiToolBarEvent, GetClickPoint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarEvent::GetClickPoint\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarEvent::GetClickPoint\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarEvent){
				references = &((wxAuiToolBarEvent_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarEvent::GetClickPoint() to return new object\n\n");
				#endif
				wxPoint value_to_return0;
				if(parent_rsrc_type == le_wxAuiToolBarEvent)
				{
					value_to_return0 = ((wxAuiToolBarEvent_php*)_this)->GetClickPoint();
					void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
					memcpy(ptr, &value_to_return0, sizeof(wxPoint));
					object_init_ex(return_value, php_wxPoint_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxPoint));
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarEvent, GetItemRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarEvent::GetItemRect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarEvent::GetItemRect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarEvent){
				references = &((wxAuiToolBarEvent_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarEvent::GetItemRect() to return new object\n\n");
				#endif
				wxRect value_to_return0;
				if(parent_rsrc_type == le_wxAuiToolBarEvent)
				{
					value_to_return0 = ((wxAuiToolBarEvent_php*)_this)->GetItemRect();
					void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
					memcpy(ptr, &value_to_return0, sizeof(wxRect));
					object_init_ex(return_value, php_wxRect_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxRect));
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarEvent, GetToolId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarEvent::GetToolId\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarEvent::GetToolId\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarEvent){
				references = &((wxAuiToolBarEvent_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBarEvent::GetToolId())\n\n");
				#endif
				if(parent_rsrc_type == le_wxAuiToolBarEvent)
				{
					ZVAL_LONG(return_value, ((wxAuiToolBarEvent_php*)_this)->GetToolId());
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarEvent, IsDropDownClicked)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarEvent::IsDropDownClicked\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarEvent::IsDropDownClicked\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarEvent){
				references = &((wxAuiToolBarEvent_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBarEvent::IsDropDownClicked())\n\n");
				#endif
				if(parent_rsrc_type == le_wxAuiToolBarEvent)
				{
					ZVAL_BOOL(return_value, ((wxAuiToolBarEvent_php*)_this)->IsDropDownClicked());
				}


				return;
				break;
			}
		}
	}

		
}
void php_wxAuiToolBarItem_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiToolBarItem_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxAuiToolBarItem_php* object = static_cast<wxAuiToolBarItem_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAuiToolBarItem done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxAuiToolBarItem, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* c0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&c0, php_wxAuiToolBarItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &c0, php_wxAuiToolBarItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(c0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(c0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(c0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxAuiToolBarItem*) object_pointer0_0)\n");
				#endif
				_this = new wxAuiToolBarItem_php(*(wxAuiToolBarItem*) object_pointer0_0);

				((wxAuiToolBarItem_php*) _this)->references.Initialize();
				((wxAuiToolBarItem_php*) _this)->references.AddReference(c0);
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxAuiToolBarItem_php();

				((wxAuiToolBarItem_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxAuiToolBarItem);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxAuiToolBarItem_php*) _this)->evnArray);
		
		array_init(((wxAuiToolBarItem_php*) _this)->evnArray);
		
		((wxAuiToolBarItem_php*) _this)->phpObj = getThis();
		
		((wxAuiToolBarItem_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxAuiToolBarItem_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxAuiToolBarItem, SetWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetWindow\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetWindow\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* w0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&w0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &w0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(w0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(w0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(w0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetWindow((wxWindow*) object_pointer0_0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetWindow((wxWindow*) object_pointer0_0);

				references->AddReference(w0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetUserData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetUserData\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetUserData\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long l0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&l0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &l0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetUserData((long) l0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetUserData((long) l0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetSticky)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetSticky\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetSticky\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&b0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetSticky(b0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetSticky(b0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetState\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetState\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long new_state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&new_state0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &new_state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetState((int) new_state0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetState((int) new_state0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetSpacerPixels)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetSpacerPixels\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetSpacerPixels\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long s0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&s0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetSpacerPixels((int) s0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetSpacerPixels((int) s0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetSizerItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetSizerItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetSizerItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* s0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&s0)\n");
		#endif
		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(s0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(s0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxGBSizerItem))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(s0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetSizerItem((wxSizerItem*) object_pointer0_0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetSizerItem((wxSizerItem*) object_pointer0_0);

				references->AddReference(s0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetShortHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetShortHelp\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetShortHelp\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* s0;
	long s_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&s0, &s_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s0, &s_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetShortHelp(wxString(s0, wxConvUTF8))\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetShortHelp(wxString(s0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetProportion)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetProportion\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetProportion\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long p0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&p0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &p0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetProportion((int) p0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetProportion((int) p0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetMinSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetMinSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetMinSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* s0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&s0, php_wxSize_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s0, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(s0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(s0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(s0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetMinSize(*(wxSize*) object_pointer0_0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetMinSize(*(wxSize*) object_pointer0_0);

				references->AddReference(s0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetLongHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetLongHelp\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetLongHelp\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* s0;
	long s_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&s0, &s_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s0, &s_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetLongHelp(wxString(s0, wxConvUTF8))\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetLongHelp(wxString(s0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	char* s0;
	long s_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&s0, &s_len0)\n");
		#endif
		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s0, &s_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetLabel(wxString(s0, wxConvUTF8))\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetLabel(wxString(s0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetKind)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetKind\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetKind\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long new_kind0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&new_kind0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &new_kind0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetKind((int) new_kind0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetKind((int) new_kind0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetId\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetId\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long new_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&new_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &new_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetId((int) new_id0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetId((int) new_id0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetHoverBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetHoverBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetHoverBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* bmp0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bmp0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmp0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmp0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bmp0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmp0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetHoverBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetHoverBitmap(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bmp0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetHasDropDown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetHasDropDown\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetHasDropDown\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&b0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetHasDropDown(b0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetHasDropDown(b0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetDisabledBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetDisabledBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetDisabledBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* bmp0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bmp0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmp0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmp0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bmp0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmp0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetDisabledBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetDisabledBitmap(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bmp0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* bmp0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bmp0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmp0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmp0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bmp0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmp0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetBitmap(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bmp0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetAlignment\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long l0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&l0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &l0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetAlignment((int) l0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetAlignment((int) l0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, SetActive)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetActive\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::SetActive\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&b0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetActive(b0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->SetActive(b0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, IsSticky)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::IsSticky\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::IsSticky\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBarItem::IsSticky())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBarItem_php*)_this)->IsSticky());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, IsActive)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::IsActive\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::IsActive\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBarItem::IsActive())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBarItem_php*)_this)->IsActive());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, HasDropDown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::HasDropDown\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::HasDropDown\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBarItem::HasDropDown())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBarItem_php*)_this)->HasDropDown());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, GetWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetWindow\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::GetWindow\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::GetWindow() to return object pointer\n\n");
				#endif
				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxAuiToolBarItem_php*)_this)->GetWindow();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxWindow_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxWindow));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, GetUserData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetUserData\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::GetUserData\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBarItem::GetUserData())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiToolBarItem_php*)_this)->GetUserData());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, GetState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetState\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::GetState\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBarItem::GetState())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiToolBarItem_php*)_this)->GetState());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, GetSpacerPixels)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetSpacerPixels\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::GetSpacerPixels\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBarItem::GetSpacerPixels())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiToolBarItem_php*)_this)->GetSpacerPixels());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, GetSizerItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetSizerItem\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::GetSizerItem\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::GetSizerItem() to return object pointer\n\n");
				#endif
				wxSizerItem_php* value_to_return0;
				value_to_return0 = (wxSizerItem_php*) ((wxAuiToolBarItem_php*)_this)->GetSizerItem();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxSizerItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxSizerItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, GetShortHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetShortHelp\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::GetShortHelp\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiToolBarItem::GetShortHelp().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxAuiToolBarItem_php*)_this)->GetShortHelp();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, GetProportion)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetProportion\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::GetProportion\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBarItem::GetProportion())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiToolBarItem_php*)_this)->GetProportion());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, GetMinSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetMinSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::GetMinSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::GetMinSize() to return object reference\n\n");
				#endif
				wxSize_php* value_to_return0;
				value_to_return0 = (wxSize_php*) &((wxAuiToolBarItem_php*)_this)->GetMinSize();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxSize_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxSize));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, GetLongHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetLongHelp\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::GetLongHelp\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiToolBarItem::GetLongHelp().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxAuiToolBarItem_php*)_this)->GetLongHelp();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, GetLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::GetLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiToolBarItem::GetLabel().fn_str(), 1)\n\n");
				#endif
				wxString value_to_return0;
				value_to_return0 = ((wxAuiToolBarItem_php*)_this)->GetLabel();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, GetKind)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetKind\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::GetKind\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBarItem::GetKind())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiToolBarItem_php*)_this)->GetKind());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, GetId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetId\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::GetId\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBarItem::GetId())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiToolBarItem_php*)_this)->GetId());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, GetHoverBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetHoverBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::GetHoverBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::GetHoverBitmap() to return object reference\n\n");
				#endif
				wxBitmap_php* value_to_return0;
				value_to_return0 = (wxBitmap_php*) &((wxAuiToolBarItem_php*)_this)->GetHoverBitmap();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxBitmap));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, GetDisabledBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetDisabledBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::GetDisabledBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::GetDisabledBitmap() to return object reference\n\n");
				#endif
				wxBitmap_php* value_to_return0;
				value_to_return0 = (wxBitmap_php*) &((wxAuiToolBarItem_php*)_this)->GetDisabledBitmap();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxBitmap));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, GetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::GetBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::GetBitmap() to return object reference\n\n");
				#endif
				wxBitmap_php* value_to_return0;
				value_to_return0 = (wxBitmap_php*) &((wxAuiToolBarItem_php*)_this)->GetBitmap();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxBitmap));
				}

				if(value_to_return0 != _this && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, GetAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::GetAlignment\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBarItem::GetAlignment())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiToolBarItem_php*)_this)->GetAlignment());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBarItem, Assign)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::Assign\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBarItem::Assign\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBarItem){
				references = &((wxAuiToolBarItem_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* c0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&c0, php_wxAuiToolBarItem_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &c0, php_wxAuiToolBarItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(c0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(c0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(c0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::Assign(*(wxAuiToolBarItem*) object_pointer0_0)\n\n");
				#endif
				((wxAuiToolBarItem_php*)_this)->Assign(*(wxAuiToolBarItem*) object_pointer0_0);

				references->AddReference(c0);

				return;
				break;
			}
		}
	}

		
}
void php_wxAuiToolBarArt_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiToolBarArt_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxAuiToolBarArt_php* object = static_cast<wxAuiToolBarArt_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAuiToolBarArt done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
wxAuiToolBarArt* wxAuiToolBarArt_php::Clone()
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::Clone\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "Clone", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'Clone'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}
		return (wxAuiToolBarArt*) return_object;
	

}
void wxAuiToolBarArt_php::DrawBackground(wxDC& dc, wxWindow* wnd, const wxRect& rect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::DrawBackground\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawBackground", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)wnd, le_wxWindow));
	object_init_ex(arguments[2], php_wxRect_entry);
	add_property_resource(arguments[2], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 3, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'DrawBackground'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiToolBarArt_php::DrawButton(wxDC& dc, wxWindow* wnd, const wxAuiToolBarItem& item, const wxRect& rect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::DrawButton\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawButton", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)wnd, le_wxWindow));
	object_init_ex(arguments[2], php_wxAuiToolBarItem_entry);
	add_property_resource(arguments[2], _wxResource, zend_list_insert((void*)&item, le_wxAuiToolBarItem));
	object_init_ex(arguments[3], php_wxRect_entry);
	add_property_resource(arguments[3], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 4, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'DrawButton'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiToolBarArt_php::DrawControlLabel(wxDC& dc, wxWindow* wnd, const wxAuiToolBarItem& item, const wxRect& rect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::DrawControlLabel\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawControlLabel", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)wnd, le_wxWindow));
	object_init_ex(arguments[2], php_wxAuiToolBarItem_entry);
	add_property_resource(arguments[2], _wxResource, zend_list_insert((void*)&item, le_wxAuiToolBarItem));
	object_init_ex(arguments[3], php_wxRect_entry);
	add_property_resource(arguments[3], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 4, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'DrawControlLabel'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiToolBarArt_php::DrawDropDownButton(wxDC& dc, wxWindow* wnd, const wxAuiToolBarItem& item, const wxRect& rect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::DrawDropDownButton\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawDropDownButton", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)wnd, le_wxWindow));
	object_init_ex(arguments[2], php_wxAuiToolBarItem_entry);
	add_property_resource(arguments[2], _wxResource, zend_list_insert((void*)&item, le_wxAuiToolBarItem));
	object_init_ex(arguments[3], php_wxRect_entry);
	add_property_resource(arguments[3], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 4, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'DrawDropDownButton'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiToolBarArt_php::DrawGripper(wxDC& dc, wxWindow* wnd, const wxRect& rect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::DrawGripper\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawGripper", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)wnd, le_wxWindow));
	object_init_ex(arguments[2], php_wxRect_entry);
	add_property_resource(arguments[2], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 3, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'DrawGripper'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiToolBarArt_php::DrawLabel(wxDC& dc, wxWindow* wnd, const wxAuiToolBarItem& item, const wxRect& rect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::DrawLabel\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawLabel", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)wnd, le_wxWindow));
	object_init_ex(arguments[2], php_wxAuiToolBarItem_entry);
	add_property_resource(arguments[2], _wxResource, zend_list_insert((void*)&item, le_wxAuiToolBarItem));
	object_init_ex(arguments[3], php_wxRect_entry);
	add_property_resource(arguments[3], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 4, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'DrawLabel'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiToolBarArt_php::DrawOverflowButton(wxDC& dc, wxWindow* wnd, const wxRect& rect, int state)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::DrawOverflowButton\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawOverflowButton", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)wnd, le_wxWindow));
	object_init_ex(arguments[2], php_wxRect_entry);
	add_property_resource(arguments[2], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
	ZVAL_LONG(arguments[3], state);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 4, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'DrawOverflowButton'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiToolBarArt_php::DrawSeparator(wxDC& dc, wxWindow* wnd, const wxRect& rect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::DrawSeparator\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawSeparator", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)wnd, le_wxWindow));
	object_init_ex(arguments[2], php_wxRect_entry);
	add_property_resource(arguments[2], _wxResource, zend_list_insert((void*)&rect, le_wxRect));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 3, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'DrawSeparator'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
int wxAuiToolBarArt_php::GetElementSize(int element_id)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::GetElementSize\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetElementSize", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], element_id);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetElementSize'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (int) Z_LVAL_P(return_value);
	

}
unsigned int wxAuiToolBarArt_php::GetFlags()
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::GetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetFlags", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetFlags'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (unsigned int) Z_LVAL_P(return_value);
	

}
wxFont wxAuiToolBarArt_php::GetFont()
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::GetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetFont", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetFont'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}
		return *(wxFont*) return_object;
	

}
wxSize wxAuiToolBarArt_php::GetLabelSize(wxDC& dc, wxWindow* wnd, const wxAuiToolBarItem& item)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::GetLabelSize\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetLabelSize", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)wnd, le_wxWindow));
	object_init_ex(arguments[2], php_wxAuiToolBarItem_entry);
	add_property_resource(arguments[2], _wxResource, zend_list_insert((void*)&item, le_wxAuiToolBarItem));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 3, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetLabelSize'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}
		return *(wxSize*) return_object;
	

}
int wxAuiToolBarArt_php::GetTextOrientation()
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::GetTextOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	zval* arguments[1];
	arguments[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetTextOrientation", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 0, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetTextOrientation'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (int) Z_LVAL_P(return_value);
	

}
wxSize wxAuiToolBarArt_php::GetToolSize(wxDC& dc, wxWindow* wnd, const wxAuiToolBarItem& item)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::GetToolSize\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetToolSize", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&dc, le_wxDC));
	object_init_ex(arguments[1], php_wxWindow_entry);
	add_property_resource(arguments[1], _wxResource, zend_list_insert((void*)wnd, le_wxWindow));
	object_init_ex(arguments[2], php_wxAuiToolBarItem_entry);
	add_property_resource(arguments[2], _wxResource, zend_list_insert((void*)&item, le_wxAuiToolBarItem));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 3, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'GetToolSize'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		if(Z_TYPE_P(return_value) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(return_value), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
		{
			id_to_find = Z_RESVAL_P(*tmp);
			return_object = zend_list_find(id_to_find, &rsrc_type);
		}
		return *(wxSize*) return_object;
	

}
void wxAuiToolBarArt_php::SetElementSize(int element_id, int size)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::SetElementSize\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetElementSize", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], element_id);
	ZVAL_LONG(arguments[1], size);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 2, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetElementSize'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiToolBarArt_php::SetFlags(unsigned int flags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::SetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetFlags", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], flags);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetFlags'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiToolBarArt_php::SetFont(const wxFont& font)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::SetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetFont", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxFont_entry);
	add_property_resource(arguments[0], _wxResource, zend_list_insert((void*)&font, le_wxFont));
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetFont'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void wxAuiToolBarArt_php::SetTextOrientation(int orientation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::SetTextOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetTextOrientation", 0);
	char* temp_string;
	char _wxResource[] = "wxResource";
	zval **tmp;
	int id_to_find;
	void* return_object;
	int rsrc_type;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], orientation);
		
	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(call_user_function(NULL, (zval**) &this->phpObj, &function_name, return_value, 1, arguments TSRMLS_CC) == FAILURE)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'SetTextOrientation'!", "Error");
	}
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	

}
void php_wxAuiDefaultToolBarArt_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiDefaultToolBarArt_destruction_handler on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	
	wxAuiDefaultToolBarArt_php* object = static_cast<wxAuiDefaultToolBarArt_php*>(rsrc->ptr);
	
	if(rsrc->ptr != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)rsrc->ptr);
		#endif
		
		if(object->references.IsUserInitialized())
		{	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete object;
			
			rsrc->ptr = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAuiDefaultToolBarArt done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, Clone)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::Clone\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::Clone\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::Clone() to return object pointer\n\n");
				#endif
				wxAuiToolBarArt_php* value_to_return0;
				value_to_return0 = (wxAuiToolBarArt_php*) ((wxAuiDefaultToolBarArt_php*)_this)->Clone();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarArt_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiToolBarArt));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, DrawBackground)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::DrawBackground\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::DrawBackground\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* dc0 = 0;
	void* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	void* object_pointer0_1 = 0;
	zval* rect0 = 0;
	void* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OzO' (&dc0, php_wxDC_entry, &wnd0, &rect0, php_wxRect_entry)\n");
		#endif
		char parse_parameters_string[] = "OzO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, php_wxDC_entry, &wnd0, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(dc0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(wnd0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::DrawBackground(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxRect*) object_pointer0_2)\n\n");
				#endif
				((wxAuiDefaultToolBarArt_php*)_this)->DrawBackground(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxRect*) object_pointer0_2);

				references->AddReference(dc0);
				references->AddReference(wnd0);
				references->AddReference(rect0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, DrawButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::DrawButton\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::DrawButton\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* dc0 = 0;
	void* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	void* object_pointer0_1 = 0;
	zval* item0 = 0;
	void* object_pointer0_2 = 0;
	zval* rect0 = 0;
	void* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OzOO' (&dc0, php_wxDC_entry, &wnd0, &item0, php_wxAuiToolBarItem_entry, &rect0, php_wxRect_entry)\n");
		#endif
		char parse_parameters_string[] = "OzOO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, php_wxDC_entry, &wnd0, &item0, php_wxAuiToolBarItem_entry, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(dc0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(wnd0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::DrawButton(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2, *(wxRect*) object_pointer0_3)\n\n");
				#endif
				((wxAuiDefaultToolBarArt_php*)_this)->DrawButton(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2, *(wxRect*) object_pointer0_3);

				references->AddReference(dc0);
				references->AddReference(wnd0);
				references->AddReference(item0);
				references->AddReference(rect0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, DrawControlLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::DrawControlLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::DrawControlLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* dc0 = 0;
	void* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	void* object_pointer0_1 = 0;
	zval* item0 = 0;
	void* object_pointer0_2 = 0;
	zval* rect0 = 0;
	void* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OzOO' (&dc0, php_wxDC_entry, &wnd0, &item0, php_wxAuiToolBarItem_entry, &rect0, php_wxRect_entry)\n");
		#endif
		char parse_parameters_string[] = "OzOO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, php_wxDC_entry, &wnd0, &item0, php_wxAuiToolBarItem_entry, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(dc0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(wnd0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::DrawControlLabel(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2, *(wxRect*) object_pointer0_3)\n\n");
				#endif
				((wxAuiDefaultToolBarArt_php*)_this)->DrawControlLabel(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2, *(wxRect*) object_pointer0_3);

				references->AddReference(dc0);
				references->AddReference(wnd0);
				references->AddReference(item0);
				references->AddReference(rect0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, DrawDropDownButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::DrawDropDownButton\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::DrawDropDownButton\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* dc0 = 0;
	void* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	void* object_pointer0_1 = 0;
	zval* item0 = 0;
	void* object_pointer0_2 = 0;
	zval* rect0 = 0;
	void* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OzOO' (&dc0, php_wxDC_entry, &wnd0, &item0, php_wxAuiToolBarItem_entry, &rect0, php_wxRect_entry)\n");
		#endif
		char parse_parameters_string[] = "OzOO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, php_wxDC_entry, &wnd0, &item0, php_wxAuiToolBarItem_entry, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(dc0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(wnd0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::DrawDropDownButton(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2, *(wxRect*) object_pointer0_3)\n\n");
				#endif
				((wxAuiDefaultToolBarArt_php*)_this)->DrawDropDownButton(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2, *(wxRect*) object_pointer0_3);

				references->AddReference(dc0);
				references->AddReference(wnd0);
				references->AddReference(item0);
				references->AddReference(rect0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, DrawGripper)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::DrawGripper\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::DrawGripper\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* dc0 = 0;
	void* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	void* object_pointer0_1 = 0;
	zval* rect0 = 0;
	void* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OzO' (&dc0, php_wxDC_entry, &wnd0, &rect0, php_wxRect_entry)\n");
		#endif
		char parse_parameters_string[] = "OzO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, php_wxDC_entry, &wnd0, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(dc0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(wnd0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::DrawGripper(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxRect*) object_pointer0_2)\n\n");
				#endif
				((wxAuiDefaultToolBarArt_php*)_this)->DrawGripper(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxRect*) object_pointer0_2);

				references->AddReference(dc0);
				references->AddReference(wnd0);
				references->AddReference(rect0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, DrawLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::DrawLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::DrawLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* dc0 = 0;
	void* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	void* object_pointer0_1 = 0;
	zval* item0 = 0;
	void* object_pointer0_2 = 0;
	zval* rect0 = 0;
	void* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OzOO' (&dc0, php_wxDC_entry, &wnd0, &item0, php_wxAuiToolBarItem_entry, &rect0, php_wxRect_entry)\n");
		#endif
		char parse_parameters_string[] = "OzOO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, php_wxDC_entry, &wnd0, &item0, php_wxAuiToolBarItem_entry, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(dc0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(wnd0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::DrawLabel(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2, *(wxRect*) object_pointer0_3)\n\n");
				#endif
				((wxAuiDefaultToolBarArt_php*)_this)->DrawLabel(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2, *(wxRect*) object_pointer0_3);

				references->AddReference(dc0);
				references->AddReference(wnd0);
				references->AddReference(item0);
				references->AddReference(rect0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, DrawOverflowButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::DrawOverflowButton\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::DrawOverflowButton\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* dc0 = 0;
	void* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	void* object_pointer0_1 = 0;
	zval* rect0 = 0;
	void* object_pointer0_2 = 0;
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OzOl' (&dc0, php_wxDC_entry, &wnd0, &rect0, php_wxRect_entry, &state0)\n");
		#endif
		char parse_parameters_string[] = "OzOl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, php_wxDC_entry, &wnd0, &rect0, php_wxRect_entry, &state0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(dc0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(wnd0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::DrawOverflowButton(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxRect*) object_pointer0_2, (int) state0)\n\n");
				#endif
				((wxAuiDefaultToolBarArt_php*)_this)->DrawOverflowButton(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxRect*) object_pointer0_2, (int) state0);

				references->AddReference(dc0);
				references->AddReference(wnd0);
				references->AddReference(rect0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, DrawSeparator)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::DrawSeparator\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::DrawSeparator\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* dc0 = 0;
	void* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	void* object_pointer0_1 = 0;
	zval* rect0 = 0;
	void* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OzO' (&dc0, php_wxDC_entry, &wnd0, &rect0, php_wxRect_entry)\n");
		#endif
		char parse_parameters_string[] = "OzO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, php_wxDC_entry, &wnd0, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(dc0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(wnd0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(rect0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(rect0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::DrawSeparator(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxRect*) object_pointer0_2)\n\n");
				#endif
				((wxAuiDefaultToolBarArt_php*)_this)->DrawSeparator(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxRect*) object_pointer0_2);

				references->AddReference(dc0);
				references->AddReference(wnd0);
				references->AddReference(rect0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, GetElementSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::GetElementSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::GetElementSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long element0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&element0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &element0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiDefaultToolBarArt::GetElementSize((int) element0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiDefaultToolBarArt_php*)_this)->GetElementSize((int) element0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, GetFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::GetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::GetFlags\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiDefaultToolBarArt::GetFlags())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiDefaultToolBarArt_php*)_this)->GetFlags());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, GetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::GetFont\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::GetFont\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::GetFont() to return new object\n\n");
				#endif
				wxFont value_to_return0;
				value_to_return0 = ((wxAuiDefaultToolBarArt_php*)_this)->GetFont();
				void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxFont));
				object_init_ex(return_value, php_wxFont_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxFont));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, GetLabelSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::GetLabelSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::GetLabelSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* dc0 = 0;
	void* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	void* object_pointer0_1 = 0;
	zval* item0 = 0;
	void* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OzO' (&dc0, php_wxDC_entry, &wnd0, &item0, php_wxAuiToolBarItem_entry)\n");
		#endif
		char parse_parameters_string[] = "OzO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, php_wxDC_entry, &wnd0, &item0, php_wxAuiToolBarItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(dc0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(wnd0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::GetLabelSize(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2) to return new object\n\n");
				#endif
				wxSize value_to_return3;
				value_to_return3 = ((wxAuiDefaultToolBarArt_php*)_this)->GetLabelSize(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2);
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxSize));

				references->AddReference(dc0);
				references->AddReference(wnd0);
				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, GetTextOrientation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::GetTextOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::GetTextOrientation\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiDefaultToolBarArt::GetTextOrientation())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiDefaultToolBarArt_php*)_this)->GetTextOrientation());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, GetToolSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::GetToolSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::GetToolSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* dc0 = 0;
	void* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	void* object_pointer0_1 = 0;
	zval* item0 = 0;
	void* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OzO' (&dc0, php_wxDC_entry, &wnd0, &item0, php_wxAuiToolBarItem_entry)\n");
		#endif
		char parse_parameters_string[] = "OzO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, php_wxDC_entry, &wnd0, &item0, php_wxAuiToolBarItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(dc0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(wnd0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(item0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(item0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::GetToolSize(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2) to return new object\n\n");
				#endif
				wxSize value_to_return3;
				value_to_return3 = ((wxAuiDefaultToolBarArt_php*)_this)->GetToolSize(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2);
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxSize));

				references->AddReference(dc0);
				references->AddReference(wnd0);
				references->AddReference(item0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, SetElementSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::SetElementSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::SetElementSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long element_id0;
	long size0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&element_id0, &size0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &element_id0, &size0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::SetElementSize((int) element_id0, (int) size0)\n\n");
				#endif
				((wxAuiDefaultToolBarArt_php*)_this)->SetElementSize((int) element_id0, (int) size0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, SetFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::SetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::SetFlags\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flags0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::SetFlags((unsigned int) flags0)\n\n");
				#endif
				((wxAuiDefaultToolBarArt_php*)_this)->SetFlags((unsigned int) flags0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, SetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::SetFont\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::SetFont\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* font0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(font0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::SetFont(*(wxFont*) object_pointer0_0)\n\n");
				#endif
				((wxAuiDefaultToolBarArt_php*)_this)->SetFont(*(wxFont*) object_pointer0_0);

				references->AddReference(font0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, SetTextOrientation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::SetTextOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiDefaultToolBarArt::SetTextOrientation\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiDefaultToolBarArt){
				references = &((wxAuiDefaultToolBarArt_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long orientation0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&orientation0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &orientation0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::SetTextOrientation((int) orientation0)\n\n");
				#endif
				((wxAuiDefaultToolBarArt_php*)_this)->SetTextOrientation((int) orientation0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiDefaultToolBarArt, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif
				_this = new wxAuiDefaultToolBarArt_php();

				((wxAuiDefaultToolBarArt_php*) _this)->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxAuiDefaultToolBarArt);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxAuiDefaultToolBarArt_php*) _this)->evnArray);
		
		array_init(((wxAuiDefaultToolBarArt_php*) _this)->evnArray);
		
		((wxAuiDefaultToolBarArt_php*) _this)->phpObj = getThis();
		
		((wxAuiDefaultToolBarArt_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxAuiDefaultToolBarArt_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
void php_wxAuiToolBar_destruction_handler(zend_rsrc_list_entry *rsrc TSRMLS_DC) 
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate php_wxAuiToolBar_destruction_handler call on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxAuiToolBar, AddControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::AddControl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::AddControl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* control0 = 0;
	void* object_pointer0_0 = 0;
	char* label0;
	long label_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|s' (&control0, &label0, &label_len0)\n");
		#endif
		char parse_parameters_string[] = "z|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &control0, &label0, &label_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(control0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(control0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(control0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddControl((wxControl*) object_pointer0_0) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return1;
				value_to_return1 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddControl((wxControl*) object_pointer0_0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(control0);

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddControl((wxControl*) object_pointer0_0, wxString(label0, wxConvUTF8)) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return2;
				value_to_return2 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddControl((wxControl*) object_pointer0_0, wxString(label0, wxConvUTF8));

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(control0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, AddLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::AddLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::AddLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	char* label0;
	long label_len0;
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|sl' (&tool_id0, &label0, &label_len0, &width0)\n");
		#endif
		char parse_parameters_string[] = "l|sl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &label0, &label_len0, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddLabel((int) tool_id0) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return1;
				value_to_return1 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddLabel((int) tool_id0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddLabel((int) tool_id0, wxString(label0, wxConvUTF8)) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return2;
				value_to_return2 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddLabel((int) tool_id0, wxString(label0, wxConvUTF8));

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddLabel((int) tool_id0, wxString(label0, wxConvUTF8), (const int) width0) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return3;
				value_to_return3 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddLabel((int) tool_id0, wxString(label0, wxConvUTF8), (const int) width0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, AddSeparator)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::AddSeparator\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::AddSeparator\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddSeparator() to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return0;
				value_to_return0 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddSeparator();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, AddSpacer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::AddSpacer\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::AddSpacer\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long pixels0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pixels0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pixels0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddSpacer((int) pixels0) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return1;
				value_to_return1 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddSpacer((int) pixels0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, AddStretchSpacer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::AddStretchSpacer\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::AddStretchSpacer\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long proportion0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&proportion0)\n");
		#endif
		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &proportion0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddStretchSpacer() to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return0;
				value_to_return0 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddStretchSpacer();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddStretchSpacer((int) proportion0) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return1;
				value_to_return1 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddStretchSpacer((int) proportion0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, Clear)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::Clear\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::Clear\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::Clear()\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->Clear();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, ClearTools)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::ClearTools\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::ClearTools\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::ClearTools()\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->ClearTools();


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, DeleteByIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::DeleteByIndex\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::DeleteByIndex\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::DeleteByIndex((int) tool_id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)_this)->DeleteByIndex((int) tool_id0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, DeleteTool)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::DeleteTool\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::DeleteTool\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::DeleteTool((int) tool_id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)_this)->DeleteTool((int) tool_id0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, EnableTool)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::EnableTool\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::EnableTool\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lb' (&tool_id0, &state0)\n");
		#endif
		char parse_parameters_string[] = "lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::EnableTool((int) tool_id0, state0)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->EnableTool((int) tool_id0, state0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	
	//Parameters for overload 0
	zval* parent0 = 0;
	void* object_pointer0_0 = 0;
	long id0;
	zval* position0 = 0;
	void* object_pointer0_2 = 0;
	zval* size0 = 0;
	void* object_pointer0_3 = 0;
	long style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOl' (&parent0, &id0, &position0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0)\n");
		#endif
		char parse_parameters_string[] = "z|lOOl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &position0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(parent0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 || (rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(position0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(position0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(position0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0)\n");
				#endif
				_this = new wxAuiToolBar_php((wxWindow*) object_pointer0_0);

				((wxAuiToolBar_php*) _this)->references.Initialize();
				((wxAuiToolBar_php*) _this)->references.AddReference(parent0);
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0)\n");
				#endif
				_this = new wxAuiToolBar_php((wxWindow*) object_pointer0_0, (wxWindowID) id0);

				((wxAuiToolBar_php*) _this)->references.Initialize();
				((wxAuiToolBar_php*) _this)->references.AddReference(parent0);
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2)\n");
				#endif
				_this = new wxAuiToolBar_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2);

				((wxAuiToolBar_php*) _this)->references.Initialize();
				((wxAuiToolBar_php*) _this)->references.AddReference(parent0);
				((wxAuiToolBar_php*) _this)->references.AddReference(position0);
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3)\n");
				#endif
				_this = new wxAuiToolBar_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3);

				((wxAuiToolBar_php*) _this)->references.Initialize();
				((wxAuiToolBar_php*) _this)->references.AddReference(parent0);
				((wxAuiToolBar_php*) _this)->references.AddReference(position0);
				((wxAuiToolBar_php*) _this)->references.AddReference(size0);
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0)\n");
				#endif
				_this = new wxAuiToolBar_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0);

				((wxAuiToolBar_php*) _this)->references.Initialize();
				((wxAuiToolBar_php*) _this)->references.AddReference(parent0);
				((wxAuiToolBar_php*) _this)->references.AddReference(position0);
				((wxAuiToolBar_php*) _this)->references.AddReference(size0);
				break;
			}
		}
	}

		
	if(already_called)
	{
		long id_to_find = zend_list_insert(_this, le_wxAuiToolBar);
		
		add_property_resource(getThis(), _wxResource, id_to_find);
		
		MAKE_STD_ZVAL(((wxAuiToolBar_php*) _this)->evnArray);
		
		array_init(((wxAuiToolBar_php*) _this)->evnArray);
		
		((wxAuiToolBar_php*) _this)->phpObj = getThis();
		
		((wxAuiToolBar_php*) _this)->InitProperties();
		
		#ifdef ZTS 
		((wxAuiToolBar_php*) _this)->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract type: failed to call a proper constructor");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
PHP_METHOD(php_wxAuiToolBar, ToggleTool)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::ToggleTool\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::ToggleTool\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lb' (&tool_id0, &state0)\n");
		#endif
		char parse_parameters_string[] = "lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::ToggleTool((int) tool_id0, state0)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->ToggleTool((int) tool_id0, state0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetWindowStyleFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetWindowStyleFlag\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetWindowStyleFlag\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&style0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetWindowStyleFlag((long) style0)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetWindowStyleFlag((long) style0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetToolTextOrientation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolTextOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetToolTextOrientation\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long orientation0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&orientation0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &orientation0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolTextOrientation((int) orientation0)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetToolTextOrientation((int) orientation0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetToolSticky)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolSticky\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetToolSticky\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool sticky0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lb' (&tool_id0, &sticky0)\n");
		#endif
		char parse_parameters_string[] = "lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &sticky0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolSticky((int) tool_id0, sticky0)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetToolSticky((int) tool_id0, sticky0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetToolShortHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolShortHelp\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetToolShortHelp\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	char* help_string0;
	long help_string_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&tool_id0, &help_string0, &help_string_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &help_string0, &help_string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolShortHelp((int) tool_id0, wxString(help_string0, wxConvUTF8))\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetToolShortHelp((int) tool_id0, wxString(help_string0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetToolSeparation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolSeparation\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetToolSeparation\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long separation0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&separation0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &separation0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolSeparation((int) separation0)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetToolSeparation((int) separation0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetToolProportion)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolProportion\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetToolProportion\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	long proportion0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&tool_id0, &proportion0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &proportion0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolProportion((int) tool_id0, (int) proportion0)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetToolProportion((int) tool_id0, (int) proportion0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetToolPacking)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolPacking\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetToolPacking\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long packing0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&packing0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &packing0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolPacking((int) packing0)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetToolPacking((int) packing0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetToolLongHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolLongHelp\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetToolLongHelp\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	char* help_string0;
	long help_string_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&tool_id0, &help_string0, &help_string_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &help_string0, &help_string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolLongHelp((int) tool_id0, wxString(help_string0, wxConvUTF8))\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetToolLongHelp((int) tool_id0, wxString(help_string0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetToolLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetToolLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	char* label0;
	long label_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&tool_id0, &label0, &label_len0)\n");
		#endif
		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &label0, &label_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolLabel((int) tool_id0, wxString(label0, wxConvUTF8))\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetToolLabel((int) tool_id0, wxString(label0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetToolDropDown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolDropDown\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetToolDropDown\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool dropdown0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lb' (&tool_id0, &dropdown0)\n");
		#endif
		char parse_parameters_string[] = "lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &dropdown0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolDropDown((int) tool_id0, dropdown0)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetToolDropDown((int) tool_id0, dropdown0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetToolBorderPadding)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolBorderPadding\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetToolBorderPadding\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long padding0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&padding0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &padding0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolBorderPadding((int) padding0)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetToolBorderPadding((int) padding0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetToolBitmapSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolBitmapSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetToolBitmapSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* size0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size0, php_wxSize_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size0, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolBitmapSize(*(wxSize*) object_pointer0_0)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetToolBitmapSize(*(wxSize*) object_pointer0_0);

				references->AddReference(size0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetToolBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetToolBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	zval* bitmap0 = 0;
	void* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&tool_id0, &bitmap0, php_wxBitmap_entry)\n");
		#endif
		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolBitmap((int) tool_id0, *(wxBitmap*) object_pointer0_1)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetToolBitmap((int) tool_id0, *(wxBitmap*) object_pointer0_1);

				references->AddReference(bitmap0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetOverflowVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetOverflowVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetOverflowVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&visible0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetOverflowVisible(visible0)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetOverflowVisible(visible0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetMargins\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetMargins\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long left0;
	long right0;
	long top0;
	long bottom0;
	bool overload0_called = false;
	//Parameters for overload 1
	long x1;
	long y1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* size2 = 0;
	void* object_pointer2_0 = 0;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll' (&left0, &right0, &top0, &bottom0)\n");
		#endif
		char parse_parameters_string[] = "llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &left0, &right0, &top0, &bottom0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x1, &y1)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x1, &y1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size2, php_wxSize_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size2, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size2) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(size2), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer2_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer2_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size2) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetMargins((int) left0, (int) right0, (int) top0, (int) bottom0)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetMargins((int) left0, (int) right0, (int) top0, (int) bottom0);


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetMargins((int) x1, (int) y1)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetMargins((int) x1, (int) y1);


				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetMargins(*(wxSize*) object_pointer2_0)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetMargins(*(wxSize*) object_pointer2_0);

				references->AddReference(size2);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetGripperVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetGripperVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetGripperVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&visible0)\n");
		#endif
		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetGripperVisible(visible0)\n\n");
				#endif
				((wxAuiToolBar_php*)_this)->SetGripperVisible(visible0);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, SetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetFont\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::SetFont\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* font0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(font0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::SetFont(*(wxFont*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)_this)->SetFont(*(wxFont*) object_pointer0_0));

				references->AddReference(font0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, Realize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::Realize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::Realize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::Realize())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)_this)->Realize());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, IsPaneValid)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::IsPaneValid\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::IsPaneValid\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	zval* pane0 = 0;
	void* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pane0, php_wxAuiPaneInfo_entry)\n");
		#endif
		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pane0, php_wxAuiPaneInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pane0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(pane0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_0 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pane0) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::IsPaneValid(*(wxAuiPaneInfo*) object_pointer0_0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)_this)->IsPaneValid(*(wxAuiPaneInfo*) object_pointer0_0));

				references->AddReference(pane0);

				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetWindowStyleFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetWindowStyleFlag\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetWindowStyleFlag\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetWindowStyleFlag())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)_this)->GetWindowStyleFlag());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolToggled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolToggled\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolToggled\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetToolToggled((int) tool_id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)_this)->GetToolToggled((int) tool_id0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolTextOrientation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolTextOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolTextOrientation\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetToolTextOrientation())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)_this)->GetToolTextOrientation());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolSticky)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolSticky\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolSticky\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetToolSticky((int) tool_id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)_this)->GetToolSticky((int) tool_id0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolShortHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolShortHelp\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolShortHelp\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiToolBar::GetToolShortHelp((int) tool_id0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxAuiToolBar_php*)_this)->GetToolShortHelp((int) tool_id0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolSeparation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolSeparation\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolSeparation\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetToolSeparation())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)_this)->GetToolSeparation());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, FindControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::FindControl\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::FindControl\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long window_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&window_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &window_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::FindControl((int) window_id0) to return object pointer\n\n");
				#endif
				wxControl_php* value_to_return1;
				value_to_return1 = (wxControl_php*) ((wxAuiToolBar_php*)_this)->FindControl((int) window_id0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxControl_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxControl));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, FindTool)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::FindTool\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::FindTool\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::FindTool((int) tool_id0) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return1;
				value_to_return1 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->FindTool((int) tool_id0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, FindToolByIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::FindToolByIndex\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::FindToolByIndex\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long idx0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&idx0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &idx0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::FindToolByIndex((int) idx0) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return1;
				value_to_return1 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->FindToolByIndex((int) idx0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return1, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return1 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, FindToolByPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::FindToolByPosition\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::FindToolByPosition\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif
		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::FindToolByPosition((wxCoord) x0, (wxCoord) y0) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return2;
				value_to_return2 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->FindToolByPosition((wxCoord) x0, (wxCoord) y0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return2, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return2 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetArtProvider)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetArtProvider\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetArtProvider\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::GetArtProvider() to return object pointer\n\n");
				#endif
				wxAuiToolBarArt_php* value_to_return0;
				value_to_return0 = (wxAuiToolBarArt_php*) ((wxAuiToolBar_php*)_this)->GetArtProvider();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarArt_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return0, le_wxAuiToolBarArt));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return0 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetGripperVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetGripperVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetGripperVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetGripperVisible())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)_this)->GetGripperVisible());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetHintSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetHintSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetHintSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long dock_direction0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&dock_direction0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dock_direction0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::GetHintSize((int) dock_direction0) to return new object\n\n");
				#endif
				wxSize value_to_return1;
				value_to_return1 = ((wxAuiToolBar_php*)_this)->GetHintSize((int) dock_direction0);
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxSize));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetOverflowVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetOverflowVisible\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetOverflowVisible\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetOverflowVisible())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)_this)->GetOverflowVisible());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolBarFits)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolBarFits\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolBarFits\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetToolBarFits())\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)_this)->GetToolBarFits());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolBitmap\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::GetToolBitmap((int) tool_id0) to return new object\n\n");
				#endif
				wxBitmap value_to_return1;
				value_to_return1 = ((wxAuiToolBar_php*)_this)->GetToolBitmap((int) tool_id0);
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxBitmap));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolBitmapSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolBitmapSize\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolBitmapSize\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::GetToolBitmapSize() to return new object\n\n");
				#endif
				wxSize value_to_return0;
				value_to_return0 = ((wxAuiToolBar_php*)_this)->GetToolBitmapSize();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxSize));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolBorderPadding)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolBorderPadding\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolBorderPadding\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetToolBorderPadding())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)_this)->GetToolBorderPadding());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolCount\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolCount\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetToolCount())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)_this)->GetToolCount());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolDropDown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolDropDown\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolDropDown\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetToolDropDown((int) tool_id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)_this)->GetToolDropDown((int) tool_id0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolEnabled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolEnabled\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolEnabled\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetToolEnabled((int) tool_id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)_this)->GetToolEnabled((int) tool_id0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolFits)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolFits\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolFits\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetToolFits((int) tool_id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)_this)->GetToolFits((int) tool_id0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolFitsByIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolFitsByIndex\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolFitsByIndex\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetToolFitsByIndex((int) tool_id0))\n\n");
				#endif
				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)_this)->GetToolFitsByIndex((int) tool_id0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolIndex\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolIndex\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetToolIndex((int) tool_id0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)_this)->GetToolIndex((int) tool_id0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolLabel\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolLabel\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiToolBar::GetToolLabel((int) tool_id0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxAuiToolBar_php*)_this)->GetToolLabel((int) tool_id0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolLongHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolLongHelp\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolLongHelp\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiToolBar::GetToolLongHelp((int) tool_id0).fn_str(), 1)\n\n");
				#endif
				wxString value_to_return1;
				value_to_return1 = ((wxAuiToolBar_php*)_this)->GetToolLongHelp((int) tool_id0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolPacking)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolPacking\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolPacking\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif
		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetToolPacking())\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)_this)->GetToolPacking());


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolPos)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolPos\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolPos\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetToolPos((int) tool_id0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)_this)->GetToolPos((int) tool_id0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolProportion)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolProportion\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolProportion\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetToolProportion((int) tool_id0))\n\n");
				#endif
				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)_this)->GetToolProportion((int) tool_id0));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, GetToolRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolRect\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::GetToolRect\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif
		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::GetToolRect((int) tool_id0) to return new object\n\n");
				#endif
				wxRect value_to_return1;
				value_to_return1 = ((wxAuiToolBar_php*)_this)->GetToolRect((int) tool_id0);
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				add_property_resource(return_value, "wxResource", zend_list_insert(ptr, le_wxRect));


				return;
				break;
			}
		}
	}

		
}
PHP_METHOD(php_wxAuiToolBar, AddTool)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::AddTool\n");
	php_printf("===========================================\n");
	#endif
	
	//In case the constructor uses objects
	zval **tmp;
	int rsrc_type;
	int parent_rsrc_type;
	int id_to_find;
	char _wxResource[] = "wxResource";
	
	//Other variables used thru the code
	int arguments_received = ZEND_NUM_ARGS();
	void *_this;
	zval* dummy;
	bool already_called = false;
	wxPHPObjectReferences* references;
	bool return_is_user_initialized = false;
	
	//Get pointer of object that called this method if not a static method
	if (getThis() != NULL) 
	{
		if(zend_hash_find(Z_OBJPROP_P(getThis()), _wxResource, sizeof(_wxResource),  (void **)&tmp) == FAILURE)
		{
			zend_error(E_ERROR, "Failed to get the parent object that called wxAuiToolBar::AddTool\n");
			
			return;
		}
		else
		{
			id_to_find = Z_RESVAL_P(*tmp);
			_this = zend_list_find(id_to_find, &parent_rsrc_type);
			
			bool reference_type_found = false;

			if(parent_rsrc_type == le_wxAuiToolBar){
				references = &((wxAuiToolBar_php*)_this)->references;
				reference_type_found = true;
			}
		}
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Processing the method call as static\n");
		#endif
	}
	
	//Parameters for overload 0
	long tool_id0;
	char* label0;
	long label_len0;
	zval* bitmap0 = 0;
	void* object_pointer0_2 = 0;
	char* short_help_string0;
	long short_help_string_len0;
	long kind0;
	bool overload0_called = false;
	//Parameters for overload 1
	long tool_id1;
	char* label1;
	long label_len1;
	zval* bitmap1 = 0;
	void* object_pointer1_2 = 0;
	zval* disabled_bitmap1 = 0;
	void* object_pointer1_3 = 0;
	long kind1;
	char* short_help_string1;
	long short_help_string_len1;
	char* long_help_string1;
	long long_help_string_len1;
	zval* client_data1 = 0;
	void* object_pointer1_7 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	long tool_id2;
	zval* bitmap2 = 0;
	void* object_pointer2_1 = 0;
	zval* disabled_bitmap2 = 0;
	void* object_pointer2_2 = 0;
	bool toggle2;
	zval* client_data2 = 0;
	void* object_pointer2_4 = 0;
	char* short_help_string2;
	long short_help_string_len2;
	char* long_help_string2;
	long long_help_string_len2;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lsO|sl' (&tool_id0, &label0, &label_len0, &bitmap0, php_wxBitmap_entry, &short_help_string0, &short_help_string_len0, &kind0)\n");
		#endif
		char parse_parameters_string[] = "lsO|sl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &label0, &label_len0, &bitmap0, php_wxBitmap_entry, &short_help_string0, &short_help_string_len0, &kind0 ) == SUCCESS)
		{
			if(arguments_received >= 3){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap0), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer0_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
						goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lsOOlssz' (&tool_id1, &label1, &label_len1, &bitmap1, php_wxBitmap_entry, &disabled_bitmap1, php_wxBitmap_entry, &kind1, &short_help_string1, &short_help_string_len1, &long_help_string1, &long_help_string_len1, &client_data1)\n");
		#endif
		char parse_parameters_string[] = "lsOOlssz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id1, &label1, &label_len1, &bitmap1, php_wxBitmap_entry, &disabled_bitmap1, php_wxBitmap_entry, &kind1, &short_help_string1, &short_help_string_len1, &long_help_string1, &long_help_string_len1, &client_data1 ) == SUCCESS)
		{
			if(arguments_received >= 3){
				if(Z_TYPE_P(bitmap1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_2 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(bitmap1) != IS_NULL)
				{
						goto overload2;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(disabled_bitmap1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(disabled_bitmap1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_3 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_3 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(disabled_bitmap1) != IS_NULL)
				{
						goto overload2;
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(client_data1) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(client_data1), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer1_7 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer1_7 || (rsrc_type != le_wxEvtHandler && rsrc_type != le_wxWindow && rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow && rsrc_type != le_wxValidator && rsrc_type != le_wxTextValidator && rsrc_type != le_wxGenericValidator && rsrc_type != le_wxMenu && rsrc_type != le_wxAuiManager && rsrc_type != le_wxMouseEventsManager && rsrc_type != le_wxTimer && rsrc_type != le_wxEventBlocker && rsrc_type != le_wxProcess && rsrc_type != le_wxFileSystemWatcher && rsrc_type != le_wxTaskBarIcon && rsrc_type != le_wxNotificationMessage && rsrc_type != le_wxBitmapHandler && rsrc_type != le_wxImage && rsrc_type != le_wxSizer && rsrc_type != le_wxBoxSizer && rsrc_type != le_wxStaticBoxSizer && rsrc_type != le_wxWrapSizer && rsrc_type != le_wxStdDialogButtonSizer && rsrc_type != le_wxGridSizer && rsrc_type != le_wxFlexGridSizer && rsrc_type != le_wxGridBagSizer && rsrc_type != le_wxSizerItem && rsrc_type != le_wxGBSizerItem && rsrc_type != le_wxImageList && rsrc_type != le_wxDC && rsrc_type != le_wxWindowDC && rsrc_type != le_wxClientDC && rsrc_type != le_wxPaintDC && rsrc_type != le_wxScreenDC && rsrc_type != le_wxPostScriptDC && rsrc_type != le_wxPrinterDC && rsrc_type != le_wxMemoryDC && rsrc_type != le_wxBufferedDC && rsrc_type != le_wxBufferedPaintDC && rsrc_type != le_wxAutoBufferedPaintDC && rsrc_type != le_wxMirrorDC && rsrc_type != le_wxColour && rsrc_type != le_wxMenuItem && rsrc_type != le_wxEvent && rsrc_type != le_wxMenuEvent && rsrc_type != le_wxKeyEvent && rsrc_type != le_wxCommandEvent && rsrc_type != le_wxNotifyEvent && rsrc_type != le_wxTreeEvent && rsrc_type != le_wxBookCtrlEvent && rsrc_type != le_wxAuiNotebookEvent && rsrc_type != le_wxAuiToolBarEvent && rsrc_type != le_wxListEvent && rsrc_type != le_wxSpinEvent && rsrc_type != le_wxSplitterEvent && rsrc_type != le_wxSpinDoubleEvent && rsrc_type != le_wxGridSizeEvent && rsrc_type != le_wxWizardEvent && rsrc_type != le_wxGridEvent && rsrc_type != le_wxGridRangeSelectEvent && rsrc_type != le_wxDataViewEvent && rsrc_type != le_wxHeaderCtrlEvent && rsrc_type != le_wxRibbonBarEvent && rsrc_type != le_wxStyledTextEvent && rsrc_type != le_wxChildFocusEvent && rsrc_type != le_wxHtmlCellEvent && rsrc_type != le_wxHtmlLinkEvent && rsrc_type != le_wxHyperlinkEvent && rsrc_type != le_wxColourPickerEvent && rsrc_type != le_wxFontPickerEvent && rsrc_type != le_wxScrollEvent && rsrc_type != le_wxWindowModalDialogEvent && rsrc_type != le_wxDateEvent && rsrc_type != le_wxCalendarEvent && rsrc_type != le_wxWindowCreateEvent && rsrc_type != le_wxWindowDestroyEvent && rsrc_type != le_wxUpdateUIEvent && rsrc_type != le_wxHelpEvent && rsrc_type != le_wxGridEditorCreatedEvent && rsrc_type != le_wxCollapsiblePaneEvent && rsrc_type != le_wxClipboardTextEvent && rsrc_type != le_wxFileCtrlEvent && rsrc_type != le_wxSashEvent && rsrc_type != le_wxFileDirPickerEvent && rsrc_type != le_wxContextMenuEvent && rsrc_type != le_wxRibbonButtonBarEvent && rsrc_type != le_wxRibbonGalleryEvent && rsrc_type != le_wxCloseEvent && rsrc_type != le_wxActivateEvent && rsrc_type != le_wxAuiManagerEvent && rsrc_type != le_wxSizeEvent && rsrc_type != le_wxMouseEvent && rsrc_type != le_wxMoveEvent && rsrc_type != le_wxTimerEvent && rsrc_type != le_wxThreadEvent && rsrc_type != le_wxScrollWinEvent && rsrc_type != le_wxSysColourChangedEvent && rsrc_type != le_wxProcessEvent && rsrc_type != le_wxEraseEvent && rsrc_type != le_wxSetCursorEvent && rsrc_type != le_wxIdleEvent && rsrc_type != le_wxPaintEvent && rsrc_type != le_wxPaletteChangedEvent && rsrc_type != le_wxInitDialogEvent && rsrc_type != le_wxMaximizeEvent && rsrc_type != le_wxNavigationKeyEvent && rsrc_type != le_wxFocusEvent && rsrc_type != le_wxFileSystemWatcherEvent && rsrc_type != le_wxDisplayChangedEvent && rsrc_type != le_wxCalculateLayoutEvent && rsrc_type != le_wxQueryLayoutInfoEvent && rsrc_type != le_wxTaskBarIconEvent && rsrc_type != le_wxAcceleratorTable && rsrc_type != le_wxGDIObject && rsrc_type != le_wxBitmap && rsrc_type != le_wxPalette && rsrc_type != le_wxIcon && rsrc_type != le_wxFont && rsrc_type != le_wxAnimation && rsrc_type != le_wxIconBundle && rsrc_type != le_wxCursor && rsrc_type != le_wxRegion && rsrc_type != le_wxPen && rsrc_type != le_wxBrush && rsrc_type != le_wxArtProvider && rsrc_type != le_wxHtmlCell && rsrc_type != le_wxHtmlContainerCell && rsrc_type != le_wxHtmlColourCell && rsrc_type != le_wxHtmlWidgetCell && rsrc_type != le_wxHtmlEasyPrinting && rsrc_type != le_wxHtmlLinkInfo && rsrc_type != le_wxFindReplaceData && rsrc_type != le_wxSound && rsrc_type != le_wxFileSystem && rsrc_type != le_wxFileSystemHandler && rsrc_type != le_wxMask && rsrc_type != le_wxToolTip && rsrc_type != le_wxGraphicsRenderer && rsrc_type != le_wxLayoutConstraints && rsrc_type != le_wxFSFile && rsrc_type != le_wxColourData && rsrc_type != le_wxFontData && rsrc_type != le_wxGridTableBase && rsrc_type != le_wxDataViewRenderer && rsrc_type != le_wxDataViewBitmapRenderer && rsrc_type != le_wxDataViewChoiceRenderer && rsrc_type != le_wxDataViewCustomRenderer && rsrc_type != le_wxDataViewSpinRenderer && rsrc_type != le_wxDataViewDateRenderer && rsrc_type != le_wxDataViewIconTextRenderer && rsrc_type != le_wxDataViewProgressRenderer && rsrc_type != le_wxDataViewTextRenderer && rsrc_type != le_wxDataViewToggleRenderer && rsrc_type != le_wxDataViewIconText && rsrc_type != le_wxVariant && rsrc_type != le_wxClipboard && rsrc_type != le_wxConfigBase && rsrc_type != le_wxFileConfig && rsrc_type != le_wxXmlResource && rsrc_type != le_wxPageSetupDialogData && rsrc_type != le_wxPrintDialogData && rsrc_type != le_wxPrintData && rsrc_type != le_wxPrintPreview && rsrc_type != le_wxPrinter && rsrc_type != le_wxPrintout && rsrc_type != le_wxHtmlPrintout && rsrc_type != le_wxHtmlDCRenderer && rsrc_type != le_wxHtmlFilter && rsrc_type != le_wxHtmlHelpData && rsrc_type != le_wxHtmlTagHandler && rsrc_type != le_wxHtmlWinTagHandler && rsrc_type != le_wxModule && rsrc_type != le_wxHtmlTagsModule && rsrc_type != le_wxImageHandler && rsrc_type != le_wxXmlResourceHandler && rsrc_type != le_wxXmlDocument && rsrc_type != le_wxLayoutAlgorithm && rsrc_type != le_wxFileHistory && rsrc_type != le_wxToolBarToolBase))
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(client_data1) != IS_NULL)
				{
						goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lOO|bzss' (&tool_id2, &bitmap2, php_wxBitmap_entry, &disabled_bitmap2, php_wxBitmap_entry, &toggle2, &client_data2, &short_help_string2, &short_help_string_len2, &long_help_string2, &long_help_string_len2)\n");
		#endif
		char parse_parameters_string[] = "lOO|bzss";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id2, &bitmap2, php_wxBitmap_entry, &disabled_bitmap2, php_wxBitmap_entry, &toggle2, &client_data2, &short_help_string2, &short_help_string_len2, &long_help_string2, &long_help_string_len2 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(bitmap2) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(bitmap2), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer2_1 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer2_1 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap2) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(disabled_bitmap2) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(disabled_bitmap2), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer2_2 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer2_2 )
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(disabled_bitmap2) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(client_data2) == IS_OBJECT && zend_hash_find(Z_OBJPROP_P(client_data2), _wxResource , sizeof(_wxResource),  (void **)&tmp) == SUCCESS)
				{
					id_to_find = Z_RESVAL_P(*tmp);
					object_pointer2_4 = zend_list_find(id_to_find, &rsrc_type);
					if (!object_pointer2_4 || (rsrc_type != le_wxEvtHandler && rsrc_type != le_wxWindow && rsrc_type != le_wxNonOwnedWindow && rsrc_type != le_wxTopLevelWindow && rsrc_type != le_wxFrame && rsrc_type != le_wxSplashScreen && rsrc_type != le_wxMDIChildFrame && rsrc_type != le_wxMDIParentFrame && rsrc_type != le_wxMiniFrame && rsrc_type != le_wxPreviewFrame && rsrc_type != le_wxHtmlHelpDialog && rsrc_type != le_wxHtmlHelpFrame && rsrc_type != le_wxDialog && rsrc_type != le_wxTextEntryDialog && rsrc_type != le_wxPasswordEntryDialog && rsrc_type != le_wxMessageDialog && rsrc_type != le_wxFindReplaceDialog && rsrc_type != le_wxDirDialog && rsrc_type != le_wxSymbolPickerDialog && rsrc_type != le_wxPropertySheetDialog && rsrc_type != le_wxWizard && rsrc_type != le_wxProgressDialog && rsrc_type != le_wxColourDialog && rsrc_type != le_wxFileDialog && rsrc_type != le_wxFontDialog && rsrc_type != le_wxPageSetupDialog && rsrc_type != le_wxPrintDialog && rsrc_type != le_wxSingleChoiceDialog && rsrc_type != le_wxGenericProgressDialog && rsrc_type != le_wxPopupWindow && rsrc_type != le_wxPopupTransientWindow && rsrc_type != le_wxControl && rsrc_type != le_wxStatusBar && rsrc_type != le_wxAnyButton && rsrc_type != le_wxButton && rsrc_type != le_wxBitmapButton && rsrc_type != le_wxToggleButton && rsrc_type != le_wxBitmapToggleButton && rsrc_type != le_wxTreeCtrl && rsrc_type != le_wxControlWithItems && rsrc_type != le_wxListBox && rsrc_type != le_wxCheckListBox && rsrc_type != le_wxRearrangeList && rsrc_type != le_wxChoice && rsrc_type != le_wxBookCtrlBase && rsrc_type != le_wxAuiNotebook && rsrc_type != le_wxListbook && rsrc_type != le_wxChoicebook && rsrc_type != le_wxNotebook && rsrc_type != le_wxTreebook && rsrc_type != le_wxToolbook && rsrc_type != le_wxAnimationCtrl && rsrc_type != le_wxStyledTextCtrl && rsrc_type != le_wxScrollBar && rsrc_type != le_wxStaticText && rsrc_type != le_wxStaticLine && rsrc_type != le_wxStaticBox && rsrc_type != le_wxStaticBitmap && rsrc_type != le_wxCheckBox && rsrc_type != le_wxTextCtrl && rsrc_type != le_wxSearchCtrl && rsrc_type != le_wxComboBox && rsrc_type != le_wxBitmapComboBox && rsrc_type != le_wxAuiToolBar && rsrc_type != le_wxListCtrl && rsrc_type != le_wxListView && rsrc_type != le_wxRadioBox && rsrc_type != le_wxRadioButton && rsrc_type != le_wxSlider && rsrc_type != le_wxSpinCtrl && rsrc_type != le_wxSpinButton && rsrc_type != le_wxGauge && rsrc_type != le_wxHyperlinkCtrl && rsrc_type != le_wxSpinCtrlDouble && rsrc_type != le_wxGenericDirCtrl && rsrc_type != le_wxCalendarCtrl && rsrc_type != le_wxPickerBase && rsrc_type != le_wxColourPickerCtrl && rsrc_type != le_wxFontPickerCtrl && rsrc_type != le_wxFilePickerCtrl && rsrc_type != le_wxDirPickerCtrl && rsrc_type != le_wxTimePickerCtrl && rsrc_type != le_wxToolBar && rsrc_type != le_wxDatePickerCtrl && rsrc_type != le_wxCollapsiblePane && rsrc_type != le_wxComboCtrl && rsrc_type != le_wxDataViewCtrl && rsrc_type != le_wxDataViewListCtrl && rsrc_type != le_wxDataViewTreeCtrl && rsrc_type != le_wxHeaderCtrl && rsrc_type != le_wxHeaderCtrlSimple && rsrc_type != le_wxFileCtrl && rsrc_type != le_wxInfoBar && rsrc_type != le_wxRibbonControl && rsrc_type != le_wxRibbonBar && rsrc_type != le_wxRibbonButtonBar && rsrc_type != le_wxRibbonGallery && rsrc_type != le_wxRibbonPage && rsrc_type != le_wxRibbonPanel && rsrc_type != le_wxRibbonToolBar && rsrc_type != le_wxSplitterWindow && rsrc_type != le_wxPanel && rsrc_type != le_wxScrolledWindow && rsrc_type != le_wxHtmlWindow && rsrc_type != le_wxGrid && rsrc_type != le_wxPreviewCanvas && rsrc_type != le_wxWizardPage && rsrc_type != le_wxWizardPageSimple && rsrc_type != le_wxEditableListBox && rsrc_type != le_wxHScrolledWindow && rsrc_type != le_wxPreviewControlBar && rsrc_type != le_wxMenuBar && rsrc_type != le_wxBannerWindow && rsrc_type != le_wxMDIClientWindow && rsrc_type != le_wxTreeListCtrl && rsrc_type != le_wxSashWindow && rsrc_type != le_wxSashLayoutWindow && rsrc_type != le_wxHtmlHelpWindow && rsrc_type != le_wxValidator && rsrc_type != le_wxTextValidator && rsrc_type != le_wxGenericValidator && rsrc_type != le_wxMenu && rsrc_type != le_wxAuiManager && rsrc_type != le_wxMouseEventsManager && rsrc_type != le_wxTimer && rsrc_type != le_wxEventBlocker && rsrc_type != le_wxProcess && rsrc_type != le_wxFileSystemWatcher && rsrc_type != le_wxTaskBarIcon && rsrc_type != le_wxNotificationMessage && rsrc_type != le_wxBitmapHandler && rsrc_type != le_wxImage && rsrc_type != le_wxSizer && rsrc_type != le_wxBoxSizer && rsrc_type != le_wxStaticBoxSizer && rsrc_type != le_wxWrapSizer && rsrc_type != le_wxStdDialogButtonSizer && rsrc_type != le_wxGridSizer && rsrc_type != le_wxFlexGridSizer && rsrc_type != le_wxGridBagSizer && rsrc_type != le_wxSizerItem && rsrc_type != le_wxGBSizerItem && rsrc_type != le_wxImageList && rsrc_type != le_wxDC && rsrc_type != le_wxWindowDC && rsrc_type != le_wxClientDC && rsrc_type != le_wxPaintDC && rsrc_type != le_wxScreenDC && rsrc_type != le_wxPostScriptDC && rsrc_type != le_wxPrinterDC && rsrc_type != le_wxMemoryDC && rsrc_type != le_wxBufferedDC && rsrc_type != le_wxBufferedPaintDC && rsrc_type != le_wxAutoBufferedPaintDC && rsrc_type != le_wxMirrorDC && rsrc_type != le_wxColour && rsrc_type != le_wxMenuItem && rsrc_type != le_wxEvent && rsrc_type != le_wxMenuEvent && rsrc_type != le_wxKeyEvent && rsrc_type != le_wxCommandEvent && rsrc_type != le_wxNotifyEvent && rsrc_type != le_wxTreeEvent && rsrc_type != le_wxBookCtrlEvent && rsrc_type != le_wxAuiNotebookEvent && rsrc_type != le_wxAuiToolBarEvent && rsrc_type != le_wxListEvent && rsrc_type != le_wxSpinEvent && rsrc_type != le_wxSplitterEvent && rsrc_type != le_wxSpinDoubleEvent && rsrc_type != le_wxGridSizeEvent && rsrc_type != le_wxWizardEvent && rsrc_type != le_wxGridEvent && rsrc_type != le_wxGridRangeSelectEvent && rsrc_type != le_wxDataViewEvent && rsrc_type != le_wxHeaderCtrlEvent && rsrc_type != le_wxRibbonBarEvent && rsrc_type != le_wxStyledTextEvent && rsrc_type != le_wxChildFocusEvent && rsrc_type != le_wxHtmlCellEvent && rsrc_type != le_wxHtmlLinkEvent && rsrc_type != le_wxHyperlinkEvent && rsrc_type != le_wxColourPickerEvent && rsrc_type != le_wxFontPickerEvent && rsrc_type != le_wxScrollEvent && rsrc_type != le_wxWindowModalDialogEvent && rsrc_type != le_wxDateEvent && rsrc_type != le_wxCalendarEvent && rsrc_type != le_wxWindowCreateEvent && rsrc_type != le_wxWindowDestroyEvent && rsrc_type != le_wxUpdateUIEvent && rsrc_type != le_wxHelpEvent && rsrc_type != le_wxGridEditorCreatedEvent && rsrc_type != le_wxCollapsiblePaneEvent && rsrc_type != le_wxClipboardTextEvent && rsrc_type != le_wxFileCtrlEvent && rsrc_type != le_wxSashEvent && rsrc_type != le_wxFileDirPickerEvent && rsrc_type != le_wxContextMenuEvent && rsrc_type != le_wxRibbonButtonBarEvent && rsrc_type != le_wxRibbonGalleryEvent && rsrc_type != le_wxCloseEvent && rsrc_type != le_wxActivateEvent && rsrc_type != le_wxAuiManagerEvent && rsrc_type != le_wxSizeEvent && rsrc_type != le_wxMouseEvent && rsrc_type != le_wxMoveEvent && rsrc_type != le_wxTimerEvent && rsrc_type != le_wxThreadEvent && rsrc_type != le_wxScrollWinEvent && rsrc_type != le_wxSysColourChangedEvent && rsrc_type != le_wxProcessEvent && rsrc_type != le_wxEraseEvent && rsrc_type != le_wxSetCursorEvent && rsrc_type != le_wxIdleEvent && rsrc_type != le_wxPaintEvent && rsrc_type != le_wxPaletteChangedEvent && rsrc_type != le_wxInitDialogEvent && rsrc_type != le_wxMaximizeEvent && rsrc_type != le_wxNavigationKeyEvent && rsrc_type != le_wxFocusEvent && rsrc_type != le_wxFileSystemWatcherEvent && rsrc_type != le_wxDisplayChangedEvent && rsrc_type != le_wxCalculateLayoutEvent && rsrc_type != le_wxQueryLayoutInfoEvent && rsrc_type != le_wxTaskBarIconEvent && rsrc_type != le_wxAcceleratorTable && rsrc_type != le_wxGDIObject && rsrc_type != le_wxBitmap && rsrc_type != le_wxPalette && rsrc_type != le_wxIcon && rsrc_type != le_wxFont && rsrc_type != le_wxAnimation && rsrc_type != le_wxIconBundle && rsrc_type != le_wxCursor && rsrc_type != le_wxRegion && rsrc_type != le_wxPen && rsrc_type != le_wxBrush && rsrc_type != le_wxArtProvider && rsrc_type != le_wxHtmlCell && rsrc_type != le_wxHtmlContainerCell && rsrc_type != le_wxHtmlColourCell && rsrc_type != le_wxHtmlWidgetCell && rsrc_type != le_wxHtmlEasyPrinting && rsrc_type != le_wxHtmlLinkInfo && rsrc_type != le_wxFindReplaceData && rsrc_type != le_wxSound && rsrc_type != le_wxFileSystem && rsrc_type != le_wxFileSystemHandler && rsrc_type != le_wxMask && rsrc_type != le_wxToolTip && rsrc_type != le_wxGraphicsRenderer && rsrc_type != le_wxLayoutConstraints && rsrc_type != le_wxFSFile && rsrc_type != le_wxColourData && rsrc_type != le_wxFontData && rsrc_type != le_wxGridTableBase && rsrc_type != le_wxDataViewRenderer && rsrc_type != le_wxDataViewBitmapRenderer && rsrc_type != le_wxDataViewChoiceRenderer && rsrc_type != le_wxDataViewCustomRenderer && rsrc_type != le_wxDataViewSpinRenderer && rsrc_type != le_wxDataViewDateRenderer && rsrc_type != le_wxDataViewIconTextRenderer && rsrc_type != le_wxDataViewProgressRenderer && rsrc_type != le_wxDataViewTextRenderer && rsrc_type != le_wxDataViewToggleRenderer && rsrc_type != le_wxDataViewIconText && rsrc_type != le_wxVariant && rsrc_type != le_wxClipboard && rsrc_type != le_wxConfigBase && rsrc_type != le_wxFileConfig && rsrc_type != le_wxXmlResource && rsrc_type != le_wxPageSetupDialogData && rsrc_type != le_wxPrintDialogData && rsrc_type != le_wxPrintData && rsrc_type != le_wxPrintPreview && rsrc_type != le_wxPrinter && rsrc_type != le_wxPrintout && rsrc_type != le_wxHtmlPrintout && rsrc_type != le_wxHtmlDCRenderer && rsrc_type != le_wxHtmlFilter && rsrc_type != le_wxHtmlHelpData && rsrc_type != le_wxHtmlTagHandler && rsrc_type != le_wxHtmlWinTagHandler && rsrc_type != le_wxModule && rsrc_type != le_wxHtmlTagsModule && rsrc_type != le_wxImageHandler && rsrc_type != le_wxXmlResourceHandler && rsrc_type != le_wxXmlDocument && rsrc_type != le_wxLayoutAlgorithm && rsrc_type != le_wxFileHistory && rsrc_type != le_wxToolBarToolBase))
					{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(client_data2) != IS_NULL)
				{
						zend_error(E_ERROR, "Parameter  could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id0, wxString(label0, wxConvUTF8), *(wxBitmap*) object_pointer0_2) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return3;
				value_to_return3 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddTool((int) tool_id0, wxString(label0, wxConvUTF8), *(wxBitmap*) object_pointer0_2);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(bitmap0);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id0, wxString(label0, wxConvUTF8), *(wxBitmap*) object_pointer0_2, wxString(short_help_string0, wxConvUTF8)) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return4;
				value_to_return4 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddTool((int) tool_id0, wxString(label0, wxConvUTF8), *(wxBitmap*) object_pointer0_2, wxString(short_help_string0, wxConvUTF8));

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(bitmap0);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id0, wxString(label0, wxConvUTF8), *(wxBitmap*) object_pointer0_2, wxString(short_help_string0, wxConvUTF8), (wxItemKind) kind0) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return5;
				value_to_return5 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddTool((int) tool_id0, wxString(label0, wxConvUTF8), *(wxBitmap*) object_pointer0_2, wxString(short_help_string0, wxConvUTF8), (wxItemKind) kind0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(bitmap0);

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id1, wxString(label1, wxConvUTF8), *(wxBitmap*) object_pointer1_2, *(wxBitmap*) object_pointer1_3, (wxItemKind) kind1, wxString(short_help_string1, wxConvUTF8), wxString(long_help_string1, wxConvUTF8), (wxObject*) object_pointer1_7) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return8;
				value_to_return8 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddTool((int) tool_id1, wxString(label1, wxConvUTF8), *(wxBitmap*) object_pointer1_2, *(wxBitmap*) object_pointer1_3, (wxItemKind) kind1, wxString(short_help_string1, wxConvUTF8), wxString(long_help_string1, wxConvUTF8), (wxObject*) object_pointer1_7);

				if(value_to_return8 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return8->references.IsUserInitialized()){
					if(value_to_return8->phpObj != NULL){
						*return_value = *value_to_return8->phpObj;
						zval_add_ref(&value_to_return8->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return8, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return8 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(bitmap1);
				references->AddReference(disabled_bitmap1);
				references->AddReference(client_data1);

				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return3;
				value_to_return3 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return3, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return3 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(bitmap2);
				references->AddReference(disabled_bitmap2);

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2, toggle2) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return4;
				value_to_return4 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2, toggle2);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return4, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return4 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(bitmap2);
				references->AddReference(disabled_bitmap2);

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2, toggle2, (wxObject*) object_pointer2_4) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return5;
				value_to_return5 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2, toggle2, (wxObject*) object_pointer2_4);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return5, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return5 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(bitmap2);
				references->AddReference(disabled_bitmap2);
				references->AddReference(client_data2);

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2, toggle2, (wxObject*) object_pointer2_4, wxString(short_help_string2, wxConvUTF8)) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return6;
				value_to_return6 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2, toggle2, (wxObject*) object_pointer2_4, wxString(short_help_string2, wxConvUTF8));

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return6, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return6 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(bitmap2);
				references->AddReference(disabled_bitmap2);
				references->AddReference(client_data2);

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2, toggle2, (wxObject*) object_pointer2_4, wxString(short_help_string2, wxConvUTF8), wxString(long_help_string2, wxConvUTF8)) to return object pointer\n\n");
				#endif
				wxAuiToolBarItem_php* value_to_return7;
				value_to_return7 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)_this)->AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2, toggle2, (wxObject*) object_pointer2_4, wxString(short_help_string2, wxConvUTF8), wxString(long_help_string2, wxConvUTF8));

				if(value_to_return7 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return7->references.IsUserInitialized()){
					if(value_to_return7->phpObj != NULL){
						*return_value = *value_to_return7->phpObj;
						zval_add_ref(&value_to_return7->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiToolBarItem_entry);
					add_property_resource(return_value, "wxResource", zend_list_insert(value_to_return7, le_wxAuiToolBarItem));
				}

				if(Z_TYPE_P(return_value) != IS_NULL && value_to_return7 != _this && return_is_user_initialized){
					references->AddReference(return_value);
				}

				references->AddReference(bitmap2);
				references->AddReference(disabled_bitmap2);
				references->AddReference(client_data2);

				return;
				break;
			}
		}
	}

		
}
