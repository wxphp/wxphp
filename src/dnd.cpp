/*
 * @author Mário Soares
 * @contributors Jefferson González
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "webview.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


BEGIN_EXTERN_C()
void php_wxClipboard_free(void *object TSRMLS_DC) 
{
    zo_wxClipboard* custom_object = (zo_wxClipboard*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxClipboard_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxClipboard done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxClipboard_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxClipboard_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxClipboard* custom_object;
    custom_object = (zo_wxClipboard*) emalloc(sizeof(zo_wxClipboard));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXCLIPBOARD_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxClipboard_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto bool wxClipboard::AddData(wxDataObject &data)
   Call this function to add the data object to the clipboard. */
PHP_METHOD(php_wxClipboard, AddData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxClipboard::AddData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxClipboard* current_object;
	wxphp_object_type current_object_type;
	wxClipboard_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxClipboard*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxClipboard::AddData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCLIPBOARD_TYPE){
				references = &((wxClipboard_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* data0 = 0;
	wxDataObject* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&data0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(data0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDataObject*) zend_object_store_get_object(data0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDataObject*) zend_object_store_get_object(data0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDataObject*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDATAOBJECT_TYPE && argument_type != PHP_WXDATAOBJECTCOMPOSITE_TYPE && argument_type != PHP_WXDATAOBJECTSIMPLE_TYPE && argument_type != PHP_WXTEXTDATAOBJECT_TYPE && argument_type != PHP_WXURLDATAOBJECT_TYPE && argument_type != PHP_WXFILEDATAOBJECT_TYPE && argument_type != PHP_WXBITMAPDATAOBJECT_TYPE && argument_type != PHP_WXCUSTOMDATAOBJECT_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'data' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'data' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxClipboard::AddData((wxDataObject*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxClipboard_php*)native_object)->AddData((wxDataObject*) object_pointer0_0));

				references->AddReference(data0, "wxClipboard::AddData at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxClipboard::AddData\n");
	}
}
/* }}} */

/* {{{ proto  wxClipboard::Clear()
   Clears the global clipboard object and the system's clipboard if possible. */
PHP_METHOD(php_wxClipboard, Clear)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxClipboard::Clear\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxClipboard* current_object;
	wxphp_object_type current_object_type;
	wxClipboard_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxClipboard*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxClipboard::Clear call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCLIPBOARD_TYPE){
				references = &((wxClipboard_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxClipboard::Clear()\n\n");
				#endif

				((wxClipboard_php*)native_object)->Clear();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxClipboard::Clear\n");
	}
}
/* }}} */

/* {{{ proto  wxClipboard::Close()
   Call this function to close the clipboard, having opened it with Open(). */
PHP_METHOD(php_wxClipboard, Close)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxClipboard::Close\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxClipboard* current_object;
	wxphp_object_type current_object_type;
	wxClipboard_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxClipboard*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxClipboard::Close call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCLIPBOARD_TYPE){
				references = &((wxClipboard_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxClipboard::Close()\n\n");
				#endif

				((wxClipboard_php*)native_object)->Close();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxClipboard::Close\n");
	}
}
/* }}} */

/* {{{ proto bool wxClipboard::Flush()
   Flushes the clipboard: this means that the data which is currently on clipboard will stay available even after the application exits (possibly eating memory), otherwise the clipboard will be emptied on exit. */
PHP_METHOD(php_wxClipboard, Flush)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxClipboard::Flush\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxClipboard* current_object;
	wxphp_object_type current_object_type;
	wxClipboard_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxClipboard*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxClipboard::Flush call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCLIPBOARD_TYPE){
				references = &((wxClipboard_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxClipboard::Flush())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxClipboard_php*)native_object)->Flush());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxClipboard::Flush\n");
	}
}
/* }}} */

/* {{{ proto bool wxClipboard::GetData(wxDataObject &data)
   Call this function to fill data with data on the clipboard, if available in the required format. */
PHP_METHOD(php_wxClipboard, GetData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxClipboard::GetData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxClipboard* current_object;
	wxphp_object_type current_object_type;
	wxClipboard_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxClipboard*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxClipboard::GetData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCLIPBOARD_TYPE){
				references = &((wxClipboard_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* data0 = 0;
	wxDataObject* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&data0, php_wxDataObject_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &data0, php_wxDataObject_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(data0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDataObject*) zend_object_store_get_object(data0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDataObject*) zend_object_store_get_object(data0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDataObject*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'data' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'data' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxClipboard::GetData(*(wxDataObject*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxClipboard_php*)native_object)->GetData(*(wxDataObject*) object_pointer0_0));

				references->AddReference(data0, "wxClipboard::GetData at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxClipboard::GetData\n");
	}
}
/* }}} */

/* {{{ proto bool wxClipboard::IsOpened()
   Returns true if the clipboard has been opened. */
PHP_METHOD(php_wxClipboard, IsOpened)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxClipboard::IsOpened\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxClipboard* current_object;
	wxphp_object_type current_object_type;
	wxClipboard_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxClipboard*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxClipboard::IsOpened call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCLIPBOARD_TYPE){
				references = &((wxClipboard_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxClipboard::IsOpened())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxClipboard_php*)native_object)->IsOpened());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxClipboard::IsOpened\n");
	}
}
/* }}} */

/* {{{ proto bool wxClipboard::IsSupported(wxDataFormat format)
   Returns true if there is data which matches the data format of the given data object currently available on the clipboard. */
PHP_METHOD(php_wxClipboard, IsSupported)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxClipboard::IsSupported\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxClipboard* current_object;
	wxphp_object_type current_object_type;
	wxClipboard_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxClipboard*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxClipboard::IsSupported call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCLIPBOARD_TYPE){
				references = &((wxClipboard_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* format0 = 0;
	wxDataFormat* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&format0, php_wxDataFormat_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &format0, php_wxDataFormat_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(format0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDataFormat*) zend_object_store_get_object(format0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDataFormat*) zend_object_store_get_object(format0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDataFormat*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'format' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(format0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'format' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxClipboard::IsSupported(*(wxDataFormat*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxClipboard_php*)native_object)->IsSupported(*(wxDataFormat*) object_pointer0_0));

				references->AddReference(format0, "wxClipboard::IsSupported at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxClipboard::IsSupported\n");
	}
}
/* }}} */

/* {{{ proto bool wxClipboard::IsUsingPrimarySelection()
   Returns true if we are using the primary selection, false if clipboard one. */
PHP_METHOD(php_wxClipboard, IsUsingPrimarySelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxClipboard::IsUsingPrimarySelection\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxClipboard* current_object;
	wxphp_object_type current_object_type;
	wxClipboard_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxClipboard*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxClipboard::IsUsingPrimarySelection call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCLIPBOARD_TYPE){
				references = &((wxClipboard_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxClipboard::IsUsingPrimarySelection())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxClipboard_php*)native_object)->IsUsingPrimarySelection());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxClipboard::IsUsingPrimarySelection\n");
	}
}
/* }}} */

/* {{{ proto bool wxClipboard::Open()
   Call this function to open the clipboard before calling SetData() and GetData(). */
PHP_METHOD(php_wxClipboard, Open)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxClipboard::Open\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxClipboard* current_object;
	wxphp_object_type current_object_type;
	wxClipboard_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxClipboard*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxClipboard::Open call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCLIPBOARD_TYPE){
				references = &((wxClipboard_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxClipboard::Open())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxClipboard_php*)native_object)->Open());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxClipboard::Open\n");
	}
}
/* }}} */

/* {{{ proto bool wxClipboard::SetData(wxDataObject &data)
   Call this function to set the data object to the clipboard. */
PHP_METHOD(php_wxClipboard, SetData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxClipboard::SetData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxClipboard* current_object;
	wxphp_object_type current_object_type;
	wxClipboard_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxClipboard*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxClipboard::SetData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCLIPBOARD_TYPE){
				references = &((wxClipboard_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* data0 = 0;
	wxDataObject* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&data0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(data0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDataObject*) zend_object_store_get_object(data0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDataObject*) zend_object_store_get_object(data0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDataObject*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDATAOBJECT_TYPE && argument_type != PHP_WXDATAOBJECTCOMPOSITE_TYPE && argument_type != PHP_WXDATAOBJECTSIMPLE_TYPE && argument_type != PHP_WXTEXTDATAOBJECT_TYPE && argument_type != PHP_WXURLDATAOBJECT_TYPE && argument_type != PHP_WXFILEDATAOBJECT_TYPE && argument_type != PHP_WXBITMAPDATAOBJECT_TYPE && argument_type != PHP_WXCUSTOMDATAOBJECT_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'data' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'data' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxClipboard::SetData((wxDataObject*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxClipboard_php*)native_object)->SetData((wxDataObject*) object_pointer0_0));

				references->AddReference(data0, "wxClipboard::SetData at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxClipboard::SetData\n");
	}
}
/* }}} */

/* {{{ proto  wxClipboard::UsePrimarySelection(bool primary)
   On platforms supporting it (all X11-based ports), wxClipboard uses the CLIPBOARD X11 selection by default. */
PHP_METHOD(php_wxClipboard, UsePrimarySelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxClipboard::UsePrimarySelection\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxClipboard* current_object;
	wxphp_object_type current_object_type;
	wxClipboard_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxClipboard*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxClipboard::UsePrimarySelection call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCLIPBOARD_TYPE){
				references = &((wxClipboard_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool primary0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&primary0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &primary0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxClipboard::UsePrimarySelection()\n\n");
				#endif

				((wxClipboard_php*)native_object)->UsePrimarySelection();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxClipboard::UsePrimarySelection(primary0)\n\n");
				#endif

				((wxClipboard_php*)native_object)->UsePrimarySelection(primary0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxClipboard::UsePrimarySelection\n");
	}
}
/* }}} */

/* {{{ proto  wxClipboard::wxClipboard()
   Default constructor. */
PHP_METHOD(php_wxClipboard, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxClipboard::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxClipboard* current_object;
	wxClipboard_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxClipboard_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxClipboard*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxClipboard::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxDataFormat_free(void *object TSRMLS_DC) 
{
    zo_wxDataFormat* custom_object = (zo_wxDataFormat*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxDataFormat_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxDataFormat done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxDataFormat_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxDataFormat_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxDataFormat* custom_object;
    custom_object = (zo_wxDataFormat*) emalloc(sizeof(zo_wxDataFormat));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXDATAFORMAT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxDataFormat_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto string wxDataFormat::GetId()
   Returns the name of a custom format (this function will fail for a standard format). */
PHP_METHOD(php_wxDataFormat, GetId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataFormat::GetId\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataFormat* current_object;
	wxphp_object_type current_object_type;
	wxDataFormat_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxDataFormat*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxDataFormat::GetId call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXDATAFORMAT_TYPE){
				references = &((wxDataFormat_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxDataFormat::GetId().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxDataFormat_php*)native_object)->GetId();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataFormat::GetId\n");
	}
}
/* }}} */

/* {{{ proto wxDataFormatId wxDataFormat::GetType()
   Returns the platform-specific number identifying the format. */
PHP_METHOD(php_wxDataFormat, GetType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataFormat::GetType\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataFormat* current_object;
	wxphp_object_type current_object_type;
	wxDataFormat_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxDataFormat*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxDataFormat::GetType call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXDATAFORMAT_TYPE){
				references = &((wxDataFormat_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataFormat::GetType())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxDataFormat_php*)native_object)->GetType());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataFormat::GetType\n");
	}
}
/* }}} */

/* {{{ proto  wxDataFormat::SetId(string format)
   Sets the format to be the custom format identified by the given name. */
PHP_METHOD(php_wxDataFormat, SetId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataFormat::SetId\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataFormat* current_object;
	wxphp_object_type current_object_type;
	wxDataFormat_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxDataFormat*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxDataFormat::SetId call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXDATAFORMAT_TYPE){
				references = &((wxDataFormat_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* format0;
	long format_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&format0, &format_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &format0, &format_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataFormat::SetId(wxString(format0, wxConvUTF8))\n\n");
				#endif

				((wxDataFormat_php*)native_object)->SetId(wxString(format0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataFormat::SetId\n");
	}
}
/* }}} */

/* {{{ proto  wxDataFormat::SetType(wxDataFormatId type)
   Sets the format to the given value, which should be one of wxDF_XXX constants. */
PHP_METHOD(php_wxDataFormat, SetType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataFormat::SetType\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataFormat* current_object;
	wxphp_object_type current_object_type;
	wxDataFormat_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxDataFormat*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxDataFormat::SetType call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXDATAFORMAT_TYPE){
				references = &((wxDataFormat_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long type0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&type0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &type0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataFormat::SetType((wxDataFormatId) type0)\n\n");
				#endif

				((wxDataFormat_php*)native_object)->SetType((wxDataFormatId) type0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataFormat::SetType\n");
	}
}
/* }}} */

/* {{{ proto  wxDataFormat::wxDataFormat(wxDataFormatId format)
   Constructs a data format object for one of the standard data formats or an empty data object (use SetType() or SetId() later in this case). */
PHP_METHOD(php_wxDataFormat, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataFormat::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataFormat* current_object;
	wxDataFormat_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	long format0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* format1;
	long format_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&format0)\n");
		#endif

		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &format0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&format1, &format_len1)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &format1, &format_len1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxDataFormat_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxDataFormatId) format0)\n");
				#endif

				native_object = new wxDataFormat_php((wxDataFormatId) format0);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(format1, wxConvUTF8))\n");
				#endif

				native_object = new wxDataFormat_php(wxString(format1, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxDataFormat*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxDataFormat::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxDataObject_free(void *object TSRMLS_DC) 
{
    zo_wxDataObject* custom_object = (zo_wxDataObject*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxDataObject_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxDataObject done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxDataObject_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxDataObject_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxDataObject* custom_object;
    custom_object = (zo_wxDataObject*) emalloc(sizeof(zo_wxDataObject));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXDATAOBJECT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxDataObject_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxDataObject::GetAllFormats(wxDataFormat &formats, Direction dir)
   Copies all formats supported in the given direction dir to the array pointed to by formats. */
void wxDataObject_php::GetAllFormats(wxDataFormat* formats, Direction dir)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxDataObject::GetAllFormats\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetAllFormats", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDataFormat_entry);
	((zo_wxDataFormat*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDataFormat_php*) formats;
	ZVAL_LONG(arguments[1], dir);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetAllFormats", 13, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxDataObject::GetAllFormats'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto bool wxDataObject::GetDataHere(wxDataFormat format, void buf)
   The method will write the data of the format format in the buffer buf and return true on success, false on failure. */
bool wxDataObject_php::GetDataHere(const wxDataFormat& format, void* buf)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxDataObject::GetDataHere\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetDataHere", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDataFormat_entry);
	((zo_wxDataFormat*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDataFormat_php*) &format;
	ZVAL_STRING(arguments[1], (char*) buf, 0);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetDataHere", 11, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxDataObject::GetDataHere'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return Z_BVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto int wxDataObject::GetDataSize(wxDataFormat format)
   Returns the data size of the given format format. */
size_t wxDataObject_php::GetDataSize(const wxDataFormat& format)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxDataObject::GetDataSize\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetDataSize", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDataFormat_entry);
	((zo_wxDataFormat*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDataFormat_php*) &format;
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetDataSize", 11, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxDataObject::GetDataSize'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (size_t) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto int wxDataObject::GetFormatCount(Direction dir)
   Returns the number of available formats for rendering or setting the data. */
size_t wxDataObject_php::GetFormatCount(Direction dir)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxDataObject::GetFormatCount\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetFormatCount", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], dir);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetFormatCount", 14, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxDataObject::GetFormatCount'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (size_t) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto wxDataFormat wxDataObject::GetPreferredFormat(Direction dir)
   Returns the preferred format for either rendering the data (if dir is Get, its default value) or for setting it. */
wxDataFormat wxDataObject_php::GetPreferredFormat(Direction dir)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxDataObject::GetPreferredFormat\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetPreferredFormat", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], dir);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetPreferredFormat", 18, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxDataObject::GetPreferredFormat'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	if(Z_TYPE_P(return_value) == IS_OBJECT)
	{
		return_object = (void*) ((zo_wxDataFormat*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object;
	}

	//Threat it as a normal object on the calling function and not a php user space intiialized one
	((zo_wxDataFormat*) zend_object_store_get_object(return_value TSRMLS_CC))->is_user_initialized = 0;
	wxDataFormat_php* var = (wxDataFormat_php*) return_object;
	var->references.UnInitialize();

	return *(wxDataFormat*) return_object;
	
}
/* }}} */

/* {{{ proto bool wxDataObject::IsSupported(wxDataFormat format, Direction dir)
   Returns true if this format is supported. */
PHP_METHOD(php_wxDataObject, IsSupported)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataObject::IsSupported\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataObject* current_object;
	wxphp_object_type current_object_type;
	wxDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxDataObject::IsSupported call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXDATAOBJECT_TYPE){
				references = &((wxDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXDATAOBJECTCOMPOSITE_TYPE) && (!reference_type_found)){
				references = &((wxDataObjectComposite_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXDATAOBJECTSIMPLE_TYPE) && (!reference_type_found)){
				references = &((wxDataObjectSimple_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTEXTDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxTextDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXURLDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxURLDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXFILEDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxFileDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxBitmapDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXCUSTOMDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxCustomDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* format0 = 0;
	wxDataFormat* object_pointer0_0 = 0;
	long dir0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&format0, php_wxDataFormat_entry, &dir0)\n");
		#endif

		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &format0, php_wxDataFormat_entry, &dir0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(format0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDataFormat*) zend_object_store_get_object(format0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDataFormat*) zend_object_store_get_object(format0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDataFormat*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'format' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(format0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'format' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataObject::IsSupported(*(wxDataFormat*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxDataObject_php*)native_object)->IsSupported(*(wxDataFormat*) object_pointer0_0));

				references->AddReference(format0, "wxDataObject::IsSupported at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataObject::IsSupported(*(wxDataFormat*) object_pointer0_0, (wxDataObject::Direction) dir0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxDataObject_php*)native_object)->IsSupported(*(wxDataFormat*) object_pointer0_0, (wxDataObject::Direction) dir0));

				references->AddReference(format0, "wxDataObject::IsSupported at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataObject::IsSupported\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataObject::SetData(wxDataFormat format, int len, void buf)
   Set the data in the format format of the length len provided in the buffer buf. */
PHP_METHOD(php_wxDataObject, SetData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataObject::SetData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataObject* current_object;
	wxphp_object_type current_object_type;
	wxDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxDataObject::SetData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXDATAOBJECT_TYPE){
				references = &((wxDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXDATAOBJECTCOMPOSITE_TYPE) && (!reference_type_found)){
				references = &((wxDataObjectComposite_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXDATAOBJECTSIMPLE_TYPE) && (!reference_type_found)){
				references = &((wxDataObjectSimple_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTEXTDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxTextDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXURLDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxURLDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXFILEDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxFileDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxBitmapDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXCUSTOMDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxCustomDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* format0 = 0;
	wxDataFormat* object_pointer0_0 = 0;
	long len0;
	char* buf0;
	long buf_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ols' (&format0, php_wxDataFormat_entry, &len0, &buf0, &buf_len0)\n");
		#endif

		char parse_parameters_string[] = "Ols";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &format0, php_wxDataFormat_entry, &len0, &buf0, &buf_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(format0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDataFormat*) zend_object_store_get_object(format0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDataFormat*) zend_object_store_get_object(format0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDataFormat*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'format' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(format0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'format' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataObject::SetData(*(wxDataFormat*) object_pointer0_0, (size_t) len0, (const void*) buf0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxDataObject_php*)native_object)->SetData(*(wxDataFormat*) object_pointer0_0, (size_t) len0, (const void*) buf0));

				references->AddReference(format0, "wxDataObject::SetData at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataObject::SetData\n");
	}
}
/* }}} */

/* {{{ proto  wxDataObject::wxDataObject()
   Constructor. */
PHP_METHOD(php_wxDataObject, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataObject::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataObject* current_object;
	wxDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxDataObject_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxDataObject::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxCustomDataObject_free(void *object TSRMLS_DC) 
{
    zo_wxCustomDataObject* custom_object = (zo_wxCustomDataObject*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxCustomDataObject_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxCustomDataObject done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxCustomDataObject_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxCustomDataObject_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxCustomDataObject* custom_object;
    custom_object = (zo_wxCustomDataObject*) emalloc(sizeof(zo_wxCustomDataObject));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXCUSTOMDATAOBJECT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxCustomDataObject_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto void wxCustomDataObject::Alloc(int size)
   This function is called to allocate size bytes of memory from SetData(). */
PHP_METHOD(php_wxCustomDataObject, Alloc)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCustomDataObject::Alloc\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCustomDataObject* current_object;
	wxphp_object_type current_object_type;
	wxCustomDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCustomDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCustomDataObject::Alloc call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCUSTOMDATAOBJECT_TYPE){
				references = &((wxCustomDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long size0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&size0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCustomDataObject::Alloc((size_t) size0)\n\n");
				#endif

				ZVAL_STRING(return_value, (char*) ((wxCustomDataObject_php*)native_object)->Alloc((size_t) size0), 1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCustomDataObject::Alloc\n");
	}
}
/* }}} */

/* {{{ proto  wxCustomDataObject::Free()
   This function is called when the data is freed, you may override it to anything you want (or may be nothing at all). */
PHP_METHOD(php_wxCustomDataObject, Free)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCustomDataObject::Free\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCustomDataObject* current_object;
	wxphp_object_type current_object_type;
	wxCustomDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCustomDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCustomDataObject::Free call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCUSTOMDATAOBJECT_TYPE){
				references = &((wxCustomDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCustomDataObject::Free()\n\n");
				#endif

				((wxCustomDataObject_php*)native_object)->Free();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCustomDataObject::Free\n");
	}
}
/* }}} */

/* {{{ proto void wxCustomDataObject::GetData()
   Returns a pointer to the data. */
PHP_METHOD(php_wxCustomDataObject, GetData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCustomDataObject::GetData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCustomDataObject* current_object;
	wxphp_object_type current_object_type;
	wxCustomDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCustomDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCustomDataObject::GetData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCUSTOMDATAOBJECT_TYPE){
				references = &((wxCustomDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCustomDataObject::GetData()\n\n");
				#endif

				ZVAL_STRING(return_value, (char*) ((wxCustomDataObject_php*)native_object)->GetData(), 1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCustomDataObject::GetData\n");
	}
}
/* }}} */

/* {{{ proto int wxCustomDataObject::GetSize()
   Returns the data size in bytes. */
PHP_METHOD(php_wxCustomDataObject, GetSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCustomDataObject::GetSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCustomDataObject* current_object;
	wxphp_object_type current_object_type;
	wxCustomDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCustomDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCustomDataObject::GetSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCUSTOMDATAOBJECT_TYPE){
				references = &((wxCustomDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxCustomDataObject::GetSize())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxCustomDataObject_php*)native_object)->GetSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCustomDataObject::GetSize\n");
	}
}
/* }}} */

/* {{{ proto bool wxCustomDataObject::SetData(int size, void data)
   Set the data. */
PHP_METHOD(php_wxCustomDataObject, SetData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCustomDataObject::SetData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCustomDataObject* current_object;
	wxphp_object_type current_object_type;
	wxCustomDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCustomDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCustomDataObject::SetData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCUSTOMDATAOBJECT_TYPE){
				references = &((wxCustomDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long size0;
	char* data0;
	long data_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&size0, &data0, &data_len0)\n");
		#endif

		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size0, &data0, &data_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCustomDataObject::SetData((size_t) size0, (const void*) data0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxCustomDataObject_php*)native_object)->SetData((size_t) size0, (const void*) data0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCustomDataObject::SetData\n");
	}
}
/* }}} */

/* {{{ proto  wxCustomDataObject::TakeData(int size, void data)
   Like SetData(), but doesn't copy the data - instead the object takes ownership of the pointer. */
PHP_METHOD(php_wxCustomDataObject, TakeData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCustomDataObject::TakeData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCustomDataObject* current_object;
	wxphp_object_type current_object_type;
	wxCustomDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCustomDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCustomDataObject::TakeData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCUSTOMDATAOBJECT_TYPE){
				references = &((wxCustomDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long size0;
	char* data0;
	long data_len0;
	zval* data0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&size0, &data0, &data_len0)\n");
		#endif

		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size0, &data0, &data_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &data0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCustomDataObject::TakeData((size_t) size0, (void*) data0)\n\n");
				#endif

				((wxCustomDataObject_php*)native_object)->TakeData((size_t) size0, (void*) data0);

				ZVAL_STRING(data0_ref, (char*) data0, 1);

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCustomDataObject::TakeData\n");
	}
}
/* }}} */

/* {{{ proto  wxCustomDataObject::wxCustomDataObject(wxDataFormat format)
   The constructor accepts a format argument which specifies the (single) format supported by this object. */
PHP_METHOD(php_wxCustomDataObject, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCustomDataObject::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCustomDataObject* current_object;
	wxCustomDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* format0 = 0;
	wxDataFormat* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|O' (&format0, php_wxDataFormat_entry)\n");
		#endif

		char parse_parameters_string[] = "|O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &format0, php_wxDataFormat_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(format0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDataFormat*) zend_object_store_get_object(format0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDataFormat*) zend_object_store_get_object(format0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDataFormat*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'format' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(format0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'format' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxCustomDataObject_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxDataFormat*) object_pointer0_0)\n");
				#endif

				native_object = new wxCustomDataObject_php(*(wxDataFormat*) object_pointer0_0);

				native_object->references.Initialize();
				((wxCustomDataObject_php*) native_object)->references.AddReference(format0, "wxCustomDataObject::wxCustomDataObject at call with 1 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxCustomDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxCustomDataObject::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxDataObjectComposite_free(void *object TSRMLS_DC) 
{
    zo_wxDataObjectComposite* custom_object = (zo_wxDataObjectComposite*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxDataObjectComposite_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxDataObjectComposite done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxDataObjectComposite_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxDataObjectComposite_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxDataObjectComposite* custom_object;
    custom_object = (zo_wxDataObjectComposite*) emalloc(sizeof(zo_wxDataObjectComposite));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXDATAOBJECTCOMPOSITE_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxDataObjectComposite_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxDataObjectComposite::Add(wxDataObjectSimple &dataObject, bool preferred)
   Adds the dataObject to the list of supported objects and it becomes the preferred object if preferred is true. */
PHP_METHOD(php_wxDataObjectComposite, Add)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataObjectComposite::Add\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataObjectComposite* current_object;
	wxphp_object_type current_object_type;
	wxDataObjectComposite_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxDataObjectComposite*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxDataObjectComposite::Add call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXDATAOBJECTCOMPOSITE_TYPE){
				references = &((wxDataObjectComposite_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* dataObject0 = 0;
	wxDataObjectSimple* object_pointer0_0 = 0;
	bool preferred0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|b' (&dataObject0, &preferred0)\n");
		#endif

		char parse_parameters_string[] = "z|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dataObject0, &preferred0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dataObject0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDataObjectSimple*) zend_object_store_get_object(dataObject0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDataObjectSimple*) zend_object_store_get_object(dataObject0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDataObjectSimple*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDATAOBJECTSIMPLE_TYPE && argument_type != PHP_WXTEXTDATAOBJECT_TYPE && argument_type != PHP_WXURLDATAOBJECT_TYPE && argument_type != PHP_WXFILEDATAOBJECT_TYPE && argument_type != PHP_WXBITMAPDATAOBJECT_TYPE && argument_type != PHP_WXCUSTOMDATAOBJECT_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'dataObject' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dataObject0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dataObject' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataObjectComposite::Add((wxDataObjectSimple*) object_pointer0_0)\n\n");
				#endif

				((wxDataObjectComposite_php*)native_object)->Add((wxDataObjectSimple*) object_pointer0_0);

				references->AddReference(dataObject0, "wxDataObjectComposite::Add at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataObjectComposite::Add((wxDataObjectSimple*) object_pointer0_0, preferred0)\n\n");
				#endif

				((wxDataObjectComposite_php*)native_object)->Add((wxDataObjectSimple*) object_pointer0_0, preferred0);

				references->AddReference(dataObject0, "wxDataObjectComposite::Add at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataObjectComposite::Add\n");
	}
}
/* }}} */

/* {{{ proto wxDataFormat wxDataObjectComposite::GetReceivedFormat()
   Report the format passed to the SetData() method. */
PHP_METHOD(php_wxDataObjectComposite, GetReceivedFormat)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataObjectComposite::GetReceivedFormat\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataObjectComposite* current_object;
	wxphp_object_type current_object_type;
	wxDataObjectComposite_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxDataObjectComposite*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxDataObjectComposite::GetReceivedFormat call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXDATAOBJECTCOMPOSITE_TYPE){
				references = &((wxDataObjectComposite_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataObjectComposite::GetReceivedFormat() to return new object\n\n");
				#endif

				wxDataFormat value_to_return0;
				value_to_return0 = ((wxDataObjectComposite_php*)native_object)->GetReceivedFormat();
				void* ptr = safe_emalloc(1, sizeof(wxDataFormat_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxDataFormat));
				object_init_ex(return_value, php_wxDataFormat_entry);
				((zo_wxDataFormat*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxDataFormat_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataObjectComposite::GetReceivedFormat\n");
	}
}
/* }}} */

/* {{{ proto  wxDataObjectComposite::wxDataObjectComposite()
   The default constructor. */
PHP_METHOD(php_wxDataObjectComposite, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataObjectComposite::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataObjectComposite* current_object;
	wxDataObjectComposite_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxDataObjectComposite_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxDataObjectComposite*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxDataObjectComposite::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxDataObjectSimple_free(void *object TSRMLS_DC) 
{
    zo_wxDataObjectSimple* custom_object = (zo_wxDataObjectSimple*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxDataObjectSimple_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxDataObjectSimple done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxDataObjectSimple_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxDataObjectSimple_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxDataObjectSimple* custom_object;
    custom_object = (zo_wxDataObjectSimple*) emalloc(sizeof(zo_wxDataObjectSimple));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXDATAOBJECTSIMPLE_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxDataObjectSimple_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto bool wxDataObjectSimple::GetDataHere(void buf)
   Copy the data to the buffer, return true on success. */
PHP_METHOD(php_wxDataObjectSimple, GetDataHere)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataObjectSimple::GetDataHere\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataObjectSimple* current_object;
	wxphp_object_type current_object_type;
	wxDataObjectSimple_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxDataObjectSimple*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxDataObjectSimple::GetDataHere call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXDATAOBJECTSIMPLE_TYPE){
				references = &((wxDataObjectSimple_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTEXTDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxTextDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXURLDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxURLDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXFILEDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxFileDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxBitmapDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXCUSTOMDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxCustomDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* buf0;
	long buf_len0;
	zval* buf0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&buf0, &buf_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &buf0, &buf_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &buf0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataObjectSimple::GetDataHere((void*) buf0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxDataObjectSimple_php*)native_object)->GetDataHere((void*) buf0));

				ZVAL_STRING(buf0_ref, (char*) buf0, 1);

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataObjectSimple::GetDataHere\n");
	}
}
/* }}} */

/* {{{ proto int wxDataObjectSimple::GetDataSize()
   Gets the size of our data. */
PHP_METHOD(php_wxDataObjectSimple, GetDataSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataObjectSimple::GetDataSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataObjectSimple* current_object;
	wxphp_object_type current_object_type;
	wxDataObjectSimple_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxDataObjectSimple*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxDataObjectSimple::GetDataSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXDATAOBJECTSIMPLE_TYPE){
				references = &((wxDataObjectSimple_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTEXTDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxTextDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXURLDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxURLDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXFILEDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxFileDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxBitmapDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXCUSTOMDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxCustomDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxDataObjectSimple::GetDataSize())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxDataObjectSimple_php*)native_object)->GetDataSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataObjectSimple::GetDataSize\n");
	}
}
/* }}} */

/* {{{ proto wxDataFormat wxDataObjectSimple::GetFormat()
   Returns the (one and only one) format supported by this object. */
PHP_METHOD(php_wxDataObjectSimple, GetFormat)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataObjectSimple::GetFormat\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataObjectSimple* current_object;
	wxphp_object_type current_object_type;
	wxDataObjectSimple_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxDataObjectSimple*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxDataObjectSimple::GetFormat call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXDATAOBJECTSIMPLE_TYPE){
				references = &((wxDataObjectSimple_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTEXTDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxTextDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXURLDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxURLDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXFILEDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxFileDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxBitmapDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXCUSTOMDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxCustomDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataObjectSimple::GetFormat() to return object reference\n\n");
				#endif

				wxDataFormat_php* value_to_return0;
				value_to_return0 = (wxDataFormat_php*) &((wxDataObjectSimple_php*)native_object)->GetFormat();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataFormat_entry);
					((zo_wxDataFormat*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxDataFormat_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxDataObjectSimple::GetFormat at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataObjectSimple::GetFormat\n");
	}
}
/* }}} */

/* {{{ proto bool wxDataObjectSimple::SetData(int len, void buf)
   Copy the data from the buffer, return true on success. */
PHP_METHOD(php_wxDataObjectSimple, SetData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataObjectSimple::SetData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataObjectSimple* current_object;
	wxphp_object_type current_object_type;
	wxDataObjectSimple_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxDataObjectSimple*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxDataObjectSimple::SetData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXDATAOBJECTSIMPLE_TYPE){
				references = &((wxDataObjectSimple_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTEXTDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxTextDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXURLDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxURLDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXFILEDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxFileDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxBitmapDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXCUSTOMDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxCustomDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long len0;
	char* buf0;
	long buf_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&len0, &buf0, &buf_len0)\n");
		#endif

		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &len0, &buf0, &buf_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDataObjectSimple::SetData((size_t) len0, (const void*) buf0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxDataObjectSimple_php*)native_object)->SetData((size_t) len0, (const void*) buf0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataObjectSimple::SetData\n");
	}
}
/* }}} */

/* {{{ proto  wxDataObjectSimple::SetFormat(wxDataFormat format)
   Sets the supported format. */
PHP_METHOD(php_wxDataObjectSimple, SetFormat)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataObjectSimple::SetFormat\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataObjectSimple* current_object;
	wxphp_object_type current_object_type;
	wxDataObjectSimple_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxDataObjectSimple*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxDataObjectSimple::SetFormat call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXDATAOBJECTSIMPLE_TYPE){
				references = &((wxDataObjectSimple_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTEXTDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxTextDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXURLDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxURLDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXFILEDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxFileDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxBitmapDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXCUSTOMDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxCustomDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* format0 = 0;
	wxDataFormat* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&format0, php_wxDataFormat_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &format0, php_wxDataFormat_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(format0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDataFormat*) zend_object_store_get_object(format0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDataFormat*) zend_object_store_get_object(format0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDataFormat*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'format' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(format0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'format' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDataObjectSimple::SetFormat(*(wxDataFormat*) object_pointer0_0)\n\n");
				#endif

				((wxDataObjectSimple_php*)native_object)->SetFormat(*(wxDataFormat*) object_pointer0_0);

				references->AddReference(format0, "wxDataObjectSimple::SetFormat at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDataObjectSimple::SetFormat\n");
	}
}
/* }}} */

/* {{{ proto  wxDataObjectSimple::wxDataObjectSimple(wxDataFormat format)
   Constructor accepts the supported format (none by default) which may also be set later with SetFormat(). */
PHP_METHOD(php_wxDataObjectSimple, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDataObjectSimple::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDataObjectSimple* current_object;
	wxDataObjectSimple_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* format0 = 0;
	wxDataFormat* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|O' (&format0, php_wxDataFormat_entry)\n");
		#endif

		char parse_parameters_string[] = "|O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &format0, php_wxDataFormat_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(format0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDataFormat*) zend_object_store_get_object(format0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDataFormat*) zend_object_store_get_object(format0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDataFormat*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'format' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(format0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'format' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxDataObjectSimple_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxDataFormat*) object_pointer0_0)\n");
				#endif

				native_object = new wxDataObjectSimple_php(*(wxDataFormat*) object_pointer0_0);

				native_object->references.Initialize();
				((wxDataObjectSimple_php*) native_object)->references.AddReference(format0, "wxDataObjectSimple::wxDataObjectSimple at call with 1 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxDataObjectSimple*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxDataObjectSimple::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxBitmapDataObject_free(void *object TSRMLS_DC) 
{
    zo_wxBitmapDataObject* custom_object = (zo_wxBitmapDataObject*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxBitmapDataObject_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxBitmapDataObject done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxBitmapDataObject_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxBitmapDataObject_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxBitmapDataObject* custom_object;
    custom_object = (zo_wxBitmapDataObject*) emalloc(sizeof(zo_wxBitmapDataObject));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXBITMAPDATAOBJECT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxBitmapDataObject_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto wxBitmap wxBitmapDataObject::GetBitmap()
   Returns the bitmap associated with the data object. */
PHP_METHOD(php_wxBitmapDataObject, GetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapDataObject::GetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmapDataObject* current_object;
	wxphp_object_type current_object_type;
	wxBitmapDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmapDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmapDataObject::GetBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAPDATAOBJECT_TYPE){
				references = &((wxBitmapDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmapDataObject::GetBitmap() to return new object\n\n");
				#endif

				wxBitmap value_to_return0;
				value_to_return0 = ((wxBitmapDataObject_php*)native_object)->GetBitmap();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				((zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmap_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapDataObject::GetBitmap\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmapDataObject::SetBitmap(wxBitmap bitmap)
   Sets the bitmap associated with the data object. */
PHP_METHOD(php_wxBitmapDataObject, SetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapDataObject::SetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmapDataObject* current_object;
	wxphp_object_type current_object_type;
	wxBitmapDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmapDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmapDataObject::SetBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAPDATAOBJECT_TYPE){
				references = &((wxBitmapDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bitmap0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmapDataObject::SetBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif

				((wxBitmapDataObject_php*)native_object)->SetBitmap(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bitmap0, "wxBitmapDataObject::SetBitmap at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapDataObject::SetBitmap\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmapDataObject::wxBitmapDataObject(wxBitmap bitmap)
   Constructor, optionally passing a bitmap (otherwise use SetBitmap() later). */
PHP_METHOD(php_wxBitmapDataObject, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapDataObject::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmapDataObject* current_object;
	wxBitmapDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|O' (&bitmap0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "|O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxBitmapDataObject_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer0_0)\n");
				#endif

				native_object = new wxBitmapDataObject_php(*(wxBitmap*) object_pointer0_0);

				native_object->references.Initialize();
				((wxBitmapDataObject_php*) native_object)->references.AddReference(bitmap0, "wxBitmapDataObject::wxBitmapDataObject at call with 1 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxBitmapDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxBitmapDataObject::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxURLDataObject_free(void *object TSRMLS_DC) 
{
    zo_wxURLDataObject* custom_object = (zo_wxURLDataObject*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxURLDataObject_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxURLDataObject done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxURLDataObject_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxURLDataObject_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxURLDataObject* custom_object;
    custom_object = (zo_wxURLDataObject*) emalloc(sizeof(zo_wxURLDataObject));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXURLDATAOBJECT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxURLDataObject_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto string wxURLDataObject::GetURL()
   Returns the URL stored by this object, as a string. */
PHP_METHOD(php_wxURLDataObject, GetURL)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxURLDataObject::GetURL\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxURLDataObject* current_object;
	wxphp_object_type current_object_type;
	wxURLDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxURLDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxURLDataObject::GetURL call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXURLDATAOBJECT_TYPE){
				references = &((wxURLDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxURLDataObject::GetURL().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxURLDataObject_php*)native_object)->GetURL();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxURLDataObject::GetURL\n");
	}
}
/* }}} */

/* {{{ proto  wxURLDataObject::SetURL(string url)
   Sets the URL stored by this object. */
PHP_METHOD(php_wxURLDataObject, SetURL)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxURLDataObject::SetURL\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxURLDataObject* current_object;
	wxphp_object_type current_object_type;
	wxURLDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxURLDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxURLDataObject::SetURL call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXURLDATAOBJECT_TYPE){
				references = &((wxURLDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* url0;
	long url_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&url0, &url_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &url0, &url_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxURLDataObject::SetURL(wxString(url0, wxConvUTF8))\n\n");
				#endif

				((wxURLDataObject_php*)native_object)->SetURL(wxString(url0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxURLDataObject::SetURL\n");
	}
}
/* }}} */

/* {{{ proto  wxURLDataObject::wxURLDataObject(string url)
   Constructor, may be used to initialize the URL. */
PHP_METHOD(php_wxURLDataObject, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxURLDataObject::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxURLDataObject* current_object;
	wxURLDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	char* url0;
	long url_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|s' (&url0, &url_len0)\n");
		#endif

		char parse_parameters_string[] = "|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &url0, &url_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxURLDataObject_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(url0, wxConvUTF8))\n");
				#endif

				native_object = new wxURLDataObject_php(wxString(url0, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxURLDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxURLDataObject::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxTextDataObject_free(void *object TSRMLS_DC) 
{
    zo_wxTextDataObject* custom_object = (zo_wxTextDataObject*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTextDataObject_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxTextDataObject done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxTextDataObject_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTextDataObject_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxTextDataObject* custom_object;
    custom_object = (zo_wxTextDataObject*) emalloc(sizeof(zo_wxTextDataObject));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXTEXTDATAOBJECT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxTextDataObject_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxTextDataObject::GetAllFormats(wxDataFormat &formats, Direction dir)
   Returns all the formats supported by wxTextDataObject. */
void wxTextDataObject_php::GetAllFormats(wxDataFormat* formats, Direction dir)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxTextDataObject::GetAllFormats\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetAllFormats", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDataFormat_entry);
	((zo_wxDataFormat*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDataFormat_php*) formats;
	ZVAL_LONG(arguments[1], dir);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetAllFormats", 13, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxTextDataObject::GetAllFormats'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto wxDataFormat wxTextDataObject::GetFormat()
   Returns the preferred format supported by this object. */
PHP_METHOD(php_wxTextDataObject, GetFormat)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextDataObject::GetFormat\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextDataObject* current_object;
	wxphp_object_type current_object_type;
	wxTextDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextDataObject::GetFormat call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTDATAOBJECT_TYPE){
				references = &((wxTextDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXURLDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxURLDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextDataObject::GetFormat() to return object reference\n\n");
				#endif

				wxDataFormat_php* value_to_return0;
				value_to_return0 = (wxDataFormat_php*) &((wxTextDataObject_php*)native_object)->GetFormat();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxDataFormat_entry);
					((zo_wxDataFormat*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxDataFormat_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxTextDataObject::GetFormat at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextDataObject::GetFormat\n");
	}
}
/* }}} */

/* {{{ proto string wxTextDataObject::GetText()
   Returns the text associated with the data object. */
PHP_METHOD(php_wxTextDataObject, GetText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextDataObject::GetText\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextDataObject* current_object;
	wxphp_object_type current_object_type;
	wxTextDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextDataObject::GetText call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTDATAOBJECT_TYPE){
				references = &((wxTextDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXURLDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxURLDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextDataObject::GetText().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxTextDataObject_php*)native_object)->GetText();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextDataObject::GetText\n");
	}
}
/* }}} */

/* {{{ proto int wxTextDataObject::GetTextLength()
   Returns the data size. */
PHP_METHOD(php_wxTextDataObject, GetTextLength)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextDataObject::GetTextLength\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextDataObject* current_object;
	wxphp_object_type current_object_type;
	wxTextDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextDataObject::GetTextLength call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTDATAOBJECT_TYPE){
				references = &((wxTextDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXURLDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxURLDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextDataObject::GetTextLength())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextDataObject_php*)native_object)->GetTextLength());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextDataObject::GetTextLength\n");
	}
}
/* }}} */

/* {{{ proto  wxTextDataObject::SetText(string strText)
   Sets the text associated with the data object. */
PHP_METHOD(php_wxTextDataObject, SetText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextDataObject::SetText\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextDataObject* current_object;
	wxphp_object_type current_object_type;
	wxTextDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextDataObject::SetText call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTDATAOBJECT_TYPE){
				references = &((wxTextDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXURLDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxURLDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* strText0;
	long strText_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&strText0, &strText_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &strText0, &strText_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextDataObject::SetText(wxString(strText0, wxConvUTF8))\n\n");
				#endif

				((wxTextDataObject_php*)native_object)->SetText(wxString(strText0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextDataObject::SetText\n");
	}
}
/* }}} */

/* {{{ proto  wxTextDataObject::wxTextDataObject(string text)
   Constructor, may be used to initialise the text (otherwise SetText() should be used later). */
PHP_METHOD(php_wxTextDataObject, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextDataObject::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextDataObject* current_object;
	wxTextDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|s' (&text0, &text_len0)\n");
		#endif

		char parse_parameters_string[] = "|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxTextDataObject_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(text0, wxConvUTF8))\n");
				#endif

				native_object = new wxTextDataObject_php(wxString(text0, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxTextDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxTextDataObject::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto int wxTextDataObject::GetFormatCount(Direction dir)
   Returns 2 under wxMac and wxGTK, where text data coming from the clipboard may be provided as ANSI (wxDF_TEXT) or as Unicode text (wxDF_UNICODETEXT, but only when wxUSE_UNICODE==1). */
PHP_METHOD(php_wxTextDataObject, GetFormatCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextDataObject::GetFormatCount\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextDataObject* current_object;
	wxphp_object_type current_object_type;
	wxTextDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextDataObject::GetFormatCount call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTDATAOBJECT_TYPE){
				references = &((wxTextDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXURLDATAOBJECT_TYPE) && (!reference_type_found)){
				references = &((wxURLDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long dir0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&dir0)\n");
		#endif

		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dir0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextDataObject::GetFormatCount())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextDataObject_php*)native_object)->GetFormatCount());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextDataObject::GetFormatCount((wxDataObject::Direction) dir0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextDataObject_php*)native_object)->GetFormatCount((wxDataObject::Direction) dir0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextDataObject::GetFormatCount\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFileDataObject_free(void *object TSRMLS_DC) 
{
    zo_wxFileDataObject* custom_object = (zo_wxFileDataObject*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFileDataObject_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxFileDataObject done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxFileDataObject_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFileDataObject_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxFileDataObject* custom_object;
    custom_object = (zo_wxFileDataObject*) emalloc(sizeof(zo_wxFileDataObject));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFILEDATAOBJECT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxFileDataObject_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxFileDataObject::AddFile(string file)
   Adds a file to the file list represented by this data object (Windows only). */
PHP_METHOD(php_wxFileDataObject, AddFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileDataObject::AddFile\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileDataObject* current_object;
	wxphp_object_type current_object_type;
	wxFileDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileDataObject::AddFile call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILEDATAOBJECT_TYPE){
				references = &((wxFileDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* file0;
	long file_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&file0, &file_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &file0, &file_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileDataObject::AddFile(wxString(file0, wxConvUTF8))\n\n");
				#endif

				((wxFileDataObject_php*)native_object)->AddFile(wxString(file0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileDataObject::AddFile\n");
	}
}
/* }}} */

/* {{{ proto array wxFileDataObject::GetFilenames()
   Returns the array of file names. */
PHP_METHOD(php_wxFileDataObject, GetFilenames)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileDataObject::GetFilenames\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileDataObject* current_object;
	wxphp_object_type current_object_type;
	wxFileDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileDataObject::GetFilenames call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILEDATAOBJECT_TYPE){
				references = &((wxFileDataObject_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileDataObject::GetFilenames() to return strings array\n\n");
				#endif

				wxArrayString value_to_return0;
				value_to_return0 = ((wxFileDataObject_php*)native_object)->GetFilenames();
				char* temp_string0;
				array_init(return_value);
				for(size_t i=0; i<value_to_return0.GetCount(); i++)
				{
					temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0[i].size()+1));
					strcpy (temp_string0, (const char *) value_to_return0[i].char_str() );
					add_next_index_string(return_value, (char*) temp_string0, 1);
					free(temp_string0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileDataObject::GetFilenames\n");
	}
}
/* }}} */

/* {{{ proto  wxFileDataObject::wxFileDataObject()
   Constructor. */
PHP_METHOD(php_wxFileDataObject, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileDataObject::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileDataObject* current_object;
	wxFileDataObject_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxFileDataObject_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxFileDataObject*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxFileDataObject::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxDropTarget_free(void *object TSRMLS_DC) 
{
    zo_wxDropTarget* custom_object = (zo_wxDropTarget*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxDropTarget_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxDropTarget done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxDropTarget_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxDropTarget_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxDropTarget* custom_object;
    custom_object = (zo_wxDropTarget*) emalloc(sizeof(zo_wxDropTarget));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXDROPTARGET_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxDropTarget_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxDropTarget::OnLeave()
   Called when the mouse leaves the drop target. */
void wxDropTarget_php::OnLeave()
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxDropTarget::OnLeave\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnLeave", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnLeave", 7, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return;
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	wxDropTarget::OnLeave();
}
/* }}} */

/* {{{ proto  wxDropTarget::wxDropTarget(wxDataObject &data)
   Constructor. */
PHP_METHOD(php_wxDropTarget, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDropTarget::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDropTarget* current_object;
	wxDropTarget_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* data0 = 0;
	wxDataObject* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|z' (&data0)\n");
		#endif

		char parse_parameters_string[] = "|z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(data0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDataObject*) zend_object_store_get_object(data0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDataObject*) zend_object_store_get_object(data0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDataObject*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDATAOBJECT_TYPE && argument_type != PHP_WXDATAOBJECTCOMPOSITE_TYPE && argument_type != PHP_WXDATAOBJECTSIMPLE_TYPE && argument_type != PHP_WXTEXTDATAOBJECT_TYPE && argument_type != PHP_WXURLDATAOBJECT_TYPE && argument_type != PHP_WXFILEDATAOBJECT_TYPE && argument_type != PHP_WXBITMAPDATAOBJECT_TYPE && argument_type != PHP_WXCUSTOMDATAOBJECT_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'data' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'data' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxDropTarget_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxDataObject*) object_pointer0_0)\n");
				#endif

				native_object = new wxDropTarget_php((wxDataObject*) object_pointer0_0);

				native_object->references.Initialize();
				((wxDropTarget_php*) native_object)->references.AddReference(data0, "wxDropTarget::wxDropTarget at call with 1 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxDropTarget*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxDropTarget::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxDropTarget::SetDataObject(wxDataObject &data)
   Sets the data wxDataObject associated with the drop target and deletes any previously associated data object. */
PHP_METHOD(php_wxDropTarget, SetDataObject)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDropTarget::SetDataObject\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDropTarget* current_object;
	wxphp_object_type current_object_type;
	wxDropTarget_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxDropTarget*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxDropTarget::SetDataObject call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXDROPTARGET_TYPE){
				references = &((wxDropTarget_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXFILEDROPTARGET_TYPE) && (!reference_type_found)){
				references = &((wxFileDropTarget_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTEXTDROPTARGET_TYPE) && (!reference_type_found)){
				references = &((wxTextDropTarget_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* data0 = 0;
	wxDataObject* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&data0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(data0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDataObject*) zend_object_store_get_object(data0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDataObject*) zend_object_store_get_object(data0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDataObject*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDATAOBJECT_TYPE && argument_type != PHP_WXDATAOBJECTCOMPOSITE_TYPE && argument_type != PHP_WXDATAOBJECTSIMPLE_TYPE && argument_type != PHP_WXTEXTDATAOBJECT_TYPE && argument_type != PHP_WXURLDATAOBJECT_TYPE && argument_type != PHP_WXFILEDATAOBJECT_TYPE && argument_type != PHP_WXBITMAPDATAOBJECT_TYPE && argument_type != PHP_WXCUSTOMDATAOBJECT_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'data' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'data' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxDropTarget::SetDataObject((wxDataObject*) object_pointer0_0)\n\n");
				#endif

				((wxDropTarget_php*)native_object)->SetDataObject((wxDataObject*) object_pointer0_0);

				references->AddReference(data0, "wxDropTarget::SetDataObject at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDropTarget::SetDataObject\n");
	}
}
/* }}} */

/* {{{ proto wxDragResult wxDropTarget::OnDragOver(int x, int y, wxDragResult defResult)
   Called when the mouse is being dragged over the drop target. */
wxDragResult wxDropTarget_php::OnDragOver(wxCoord x, wxCoord y, wxDragResult defResult)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxDropTarget::OnDragOver\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnDragOver", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], x);
	ZVAL_LONG(arguments[1], y);
	ZVAL_LONG(arguments[2], defResult);
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnDragOver", 10, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (wxDragResult) Z_LVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxDropTarget::OnDragOver(x, y, defResult);
}
/* }}} */

/* {{{ proto wxDragResult wxDropTarget::OnEnter(int x, int y, wxDragResult defResult)
   Called when the mouse enters the drop target. */
wxDragResult wxDropTarget_php::OnEnter(wxCoord x, wxCoord y, wxDragResult defResult)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxDropTarget::OnEnter\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnEnter", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], x);
	ZVAL_LONG(arguments[1], y);
	ZVAL_LONG(arguments[2], defResult);
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnEnter", 7, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return (wxDragResult) Z_LVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxDropTarget::OnEnter(x, y, defResult);
}
/* }}} */

/* {{{ proto bool wxDropTarget::GetData()
   This method may only be called from within OnData(). */
PHP_METHOD(php_wxDropTarget, GetData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDropTarget::GetData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDropTarget* current_object;
	wxphp_object_type current_object_type;
	wxDropTarget_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxDropTarget*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxDropTarget::GetData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXDROPTARGET_TYPE){
				references = &((wxDropTarget_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXFILEDROPTARGET_TYPE) && (!reference_type_found)){
				references = &((wxFileDropTarget_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTEXTDROPTARGET_TYPE) && (!reference_type_found)){
				references = &((wxTextDropTarget_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxDropTarget::GetData())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxDropTarget_php*)native_object)->GetData());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxDropTarget::GetData\n");
	}
}
/* }}} */

/* {{{ proto wxDragResult wxDropTarget::OnData(int x, int y, wxDragResult defResult)
   Called after OnDrop() returns true. */
wxDragResult wxDropTarget_php::OnData(wxCoord x, wxCoord y, wxDragResult defResult)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxDropTarget::OnData\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnData", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], x);
	ZVAL_LONG(arguments[1], y);
	ZVAL_LONG(arguments[2], defResult);
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnData", 6, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxDropTarget::OnData'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (wxDragResult) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto bool wxDropTarget::OnDrop(int x, int y)
   Called when the user drops a data object on the target. */
bool wxDropTarget_php::OnDrop(wxCoord x, wxCoord y)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxDropTarget::OnDrop\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnDrop", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], x);
	ZVAL_LONG(arguments[1], y);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnDrop", 6, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxDropTarget::OnDrop(x, y);
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxTextDropTarget_free(void *object TSRMLS_DC) 
{
    zo_wxTextDropTarget* custom_object = (zo_wxTextDropTarget*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTextDropTarget_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxTextDropTarget done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxTextDropTarget_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTextDropTarget_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxTextDropTarget* custom_object;
    custom_object = (zo_wxTextDropTarget*) emalloc(sizeof(zo_wxTextDropTarget));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXTEXTDROPTARGET_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxTextDropTarget_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxTextDropTarget::wxTextDropTarget()
   Constructor. */
PHP_METHOD(php_wxTextDropTarget, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextDropTarget::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextDropTarget* current_object;
	wxTextDropTarget_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxTextDropTarget_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxTextDropTarget*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxTextDropTarget::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto bool wxTextDropTarget::OnDropText(int x, int y, string data)
   Override this function to receive dropped text. */
bool wxTextDropTarget_php::OnDropText(wxCoord x, wxCoord y, const wxString& data)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxTextDropTarget::OnDropText\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnDropText", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], x);
	ZVAL_LONG(arguments[1], y);
	temp_string = (char*)malloc(sizeof(wxChar)*(data.size()+1));
	strcpy(temp_string, (const char *) data.char_str());
	ZVAL_STRING(arguments[2], temp_string, 1);
	free(temp_string);
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnDropText", 10, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxTextDropTarget::OnDropText'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return Z_BVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto bool wxTextDropTarget::OnDrop(int x, int y)
   See wxDropTarget::OnDrop(). */
bool wxTextDropTarget_php::OnDrop(wxCoord x, wxCoord y)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxTextDropTarget::OnDrop\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnDrop", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], x);
	ZVAL_LONG(arguments[1], y);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnDrop", 6, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxTextDropTarget::OnDrop(x, y);
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFileDropTarget_free(void *object TSRMLS_DC) 
{
    zo_wxFileDropTarget* custom_object = (zo_wxFileDropTarget*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFileDropTarget_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxFileDropTarget done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxFileDropTarget_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFileDropTarget_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxFileDropTarget* custom_object;
    custom_object = (zo_wxFileDropTarget*) emalloc(sizeof(zo_wxFileDropTarget));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFILEDROPTARGET_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxFileDropTarget_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxFileDropTarget::wxFileDropTarget()
   Constructor. */
PHP_METHOD(php_wxFileDropTarget, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileDropTarget::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileDropTarget* current_object;
	wxFileDropTarget_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxFileDropTarget_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxFileDropTarget*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxFileDropTarget::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto bool wxFileDropTarget::OnDropFiles(int x, int y, array filenames)
   Override this function to receive dropped files. */
bool wxFileDropTarget_php::OnDropFiles(wxCoord x, wxCoord y, const wxArrayString& filenames)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxFileDropTarget::OnDropFiles\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnDropFiles", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], x);
	ZVAL_LONG(arguments[1], y);
	array_init(arguments[2]);
	for(int i=0; i<filenames.GetCount(); i++)
	{
		temp_string = (char*)malloc(sizeof(wxChar)*(filenames[i].size()+1));
		strcpy(temp_string, (const char *) filenames[i].char_str());
		add_next_index_string(arguments[2], temp_string, 1);
		free(temp_string);
	}
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnDropFiles", 11, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxFileDropTarget::OnDropFiles'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return Z_BVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto bool wxFileDropTarget::OnDrop(int x, int y)
   See wxDropTarget::OnDrop(). */
bool wxFileDropTarget_php::OnDrop(wxCoord x, wxCoord y)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxFileDropTarget::OnDrop\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnDrop", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], x);
	ZVAL_LONG(arguments[1], y);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnDrop", 6, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxFileDropTarget::OnDrop(x, y);
}
/* }}} */

