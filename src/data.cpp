/*
 * @author Mário Soares
 * @contributors Jefferson González
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "webview.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


BEGIN_EXTERN_C()
void php_wxAcceleratorEntry_free(void *object TSRMLS_DC) 
{
    zo_wxAcceleratorEntry* custom_object = (zo_wxAcceleratorEntry*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAcceleratorEntry_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAcceleratorEntry done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxAcceleratorEntry_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAcceleratorEntry_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxAcceleratorEntry* custom_object;
    custom_object = (zo_wxAcceleratorEntry*) emalloc(sizeof(zo_wxAcceleratorEntry));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXACCELERATORENTRY_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxAcceleratorEntry_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxAcceleratorEntry::wxAcceleratorEntry(wxAcceleratorEntry entry)
   Copy ctor. */
PHP_METHOD(php_wxAcceleratorEntry, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAcceleratorEntry::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAcceleratorEntry* current_object;
	wxAcceleratorEntry_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* entry0 = 0;
	wxAcceleratorEntry* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	long flags1;
	long keyCode1;
	long cmd1;
	zval* item1 = 0;
	wxMenuItem* object_pointer1_3 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&entry0, php_wxAcceleratorEntry_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &entry0, php_wxAcceleratorEntry_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(entry0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAcceleratorEntry*) zend_object_store_get_object(entry0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAcceleratorEntry*) zend_object_store_get_object(entry0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxAcceleratorEntry*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(entry0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 0  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|lllz' (&flags1, &keyCode1, &cmd1, &item1)\n");
		#endif

		char parse_parameters_string[] = "|lllz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flags1, &keyCode1, &cmd1, &item1 ) == SUCCESS)
		{
			if(arguments_received >= 4){
				if(Z_TYPE_P(item1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxMenuItem*) zend_object_store_get_object(item1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxMenuItem*) zend_object_store_get_object(item1 TSRMLS_CC))->native_object;
					object_pointer1_3 = (wxMenuItem*) argument_native_object;
					if (!object_pointer1_3 || (argument_type != PHP_WXMENUITEM_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'item' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'item' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxAcceleratorEntry*) object_pointer0_0)\n");
				#endif

				native_object = new wxAcceleratorEntry_php(*(wxAcceleratorEntry*) object_pointer0_0);

				native_object->references.Initialize();
				((wxAcceleratorEntry_php*) native_object)->references.AddReference(entry0, "wxAcceleratorEntry::wxAcceleratorEntry at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxAcceleratorEntry_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) flags1)\n");
				#endif

				native_object = new wxAcceleratorEntry_php((int) flags1);

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) flags1, (int) keyCode1)\n");
				#endif

				native_object = new wxAcceleratorEntry_php((int) flags1, (int) keyCode1);

				native_object->references.Initialize();
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) flags1, (int) keyCode1, (int) cmd1)\n");
				#endif

				native_object = new wxAcceleratorEntry_php((int) flags1, (int) keyCode1, (int) cmd1);

				native_object->references.Initialize();
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) flags1, (int) keyCode1, (int) cmd1, (wxMenuItem*) object_pointer1_3)\n");
				#endif

				native_object = new wxAcceleratorEntry_php((int) flags1, (int) keyCode1, (int) cmd1, (wxMenuItem*) object_pointer1_3);

				native_object->references.Initialize();
				((wxAcceleratorEntry_php*) native_object)->references.AddReference(item1, "wxAcceleratorEntry::wxAcceleratorEntry at call with 4 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxAcceleratorEntry*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxAcceleratorEntry::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto string wxAcceleratorEntry::ToString()
   Returns a textual representation of this accelerator. */
PHP_METHOD(php_wxAcceleratorEntry, ToString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAcceleratorEntry::ToString\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAcceleratorEntry* current_object;
	wxphp_object_type current_object_type;
	wxAcceleratorEntry_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAcceleratorEntry*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAcceleratorEntry::ToString call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXACCELERATORENTRY_TYPE){
				references = &((wxAcceleratorEntry_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAcceleratorEntry::ToString().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxAcceleratorEntry_php*)native_object)->ToString();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAcceleratorEntry::ToString\n");
	}
}
/* }}} */

/* {{{ proto  wxAcceleratorEntry::Set(int flags, int keyCode, int cmd, wxMenuItem &item)
   Sets the accelerator entry parameters. */
PHP_METHOD(php_wxAcceleratorEntry, Set)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAcceleratorEntry::Set\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAcceleratorEntry* current_object;
	wxphp_object_type current_object_type;
	wxAcceleratorEntry_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAcceleratorEntry*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAcceleratorEntry::Set call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXACCELERATORENTRY_TYPE){
				references = &((wxAcceleratorEntry_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flags0;
	long keyCode0;
	long cmd0;
	zval* item0 = 0;
	wxMenuItem* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll|z' (&flags0, &keyCode0, &cmd0, &item0)\n");
		#endif

		char parse_parameters_string[] = "lll|z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flags0, &keyCode0, &cmd0, &item0 ) == SUCCESS)
		{
			if(arguments_received >= 4){
				if(Z_TYPE_P(item0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxMenuItem*) zend_object_store_get_object(item0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxMenuItem*) zend_object_store_get_object(item0 TSRMLS_CC))->native_object;
					object_pointer0_3 = (wxMenuItem*) argument_native_object;
					if (!object_pointer0_3 || (argument_type != PHP_WXMENUITEM_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'item' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'item' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAcceleratorEntry::Set((int) flags0, (int) keyCode0, (int) cmd0)\n\n");
				#endif

				((wxAcceleratorEntry_php*)native_object)->Set((int) flags0, (int) keyCode0, (int) cmd0);


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAcceleratorEntry::Set((int) flags0, (int) keyCode0, (int) cmd0, (wxMenuItem*) object_pointer0_3)\n\n");
				#endif

				((wxAcceleratorEntry_php*)native_object)->Set((int) flags0, (int) keyCode0, (int) cmd0, (wxMenuItem*) object_pointer0_3);

				references->AddReference(item0, "wxAcceleratorEntry::Set at call with 4 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAcceleratorEntry::Set\n");
	}
}
/* }}} */

/* {{{ proto bool wxAcceleratorEntry::IsOk()
   Returns true if this object is correctly initialized. */
PHP_METHOD(php_wxAcceleratorEntry, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAcceleratorEntry::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAcceleratorEntry* current_object;
	wxphp_object_type current_object_type;
	wxAcceleratorEntry_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAcceleratorEntry*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAcceleratorEntry::IsOk call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXACCELERATORENTRY_TYPE){
				references = &((wxAcceleratorEntry_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAcceleratorEntry::IsOk())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAcceleratorEntry_php*)native_object)->IsOk());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAcceleratorEntry::IsOk\n");
	}
}
/* }}} */

/* {{{ proto wxMenuItem wxAcceleratorEntry::GetMenuItem()
   Returns the menu item associated with this accelerator entry. */
PHP_METHOD(php_wxAcceleratorEntry, GetMenuItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAcceleratorEntry::GetMenuItem\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAcceleratorEntry* current_object;
	wxphp_object_type current_object_type;
	wxAcceleratorEntry_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAcceleratorEntry*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAcceleratorEntry::GetMenuItem call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXACCELERATORENTRY_TYPE){
				references = &((wxAcceleratorEntry_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAcceleratorEntry::GetMenuItem() to return object pointer\n\n");
				#endif

				wxMenuItem_php* value_to_return0;
				value_to_return0 = (wxMenuItem_php*) ((wxAcceleratorEntry_php*)native_object)->GetMenuItem();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxMenuItem_entry);
					((zo_wxMenuItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxMenuItem_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAcceleratorEntry::GetMenuItem at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAcceleratorEntry::GetMenuItem\n");
	}
}
/* }}} */

/* {{{ proto int wxAcceleratorEntry::GetKeyCode()
   Returns the keycode for the accelerator table entry. */
PHP_METHOD(php_wxAcceleratorEntry, GetKeyCode)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAcceleratorEntry::GetKeyCode\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAcceleratorEntry* current_object;
	wxphp_object_type current_object_type;
	wxAcceleratorEntry_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAcceleratorEntry*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAcceleratorEntry::GetKeyCode call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXACCELERATORENTRY_TYPE){
				references = &((wxAcceleratorEntry_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAcceleratorEntry::GetKeyCode())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAcceleratorEntry_php*)native_object)->GetKeyCode());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAcceleratorEntry::GetKeyCode\n");
	}
}
/* }}} */

/* {{{ proto int wxAcceleratorEntry::GetFlags()
   Returns the flags for the accelerator table entry. */
PHP_METHOD(php_wxAcceleratorEntry, GetFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAcceleratorEntry::GetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAcceleratorEntry* current_object;
	wxphp_object_type current_object_type;
	wxAcceleratorEntry_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAcceleratorEntry*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAcceleratorEntry::GetFlags call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXACCELERATORENTRY_TYPE){
				references = &((wxAcceleratorEntry_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAcceleratorEntry::GetFlags())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAcceleratorEntry_php*)native_object)->GetFlags());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAcceleratorEntry::GetFlags\n");
	}
}
/* }}} */

/* {{{ proto int wxAcceleratorEntry::GetCommand()
   Returns the command identifier for the accelerator table entry. */
PHP_METHOD(php_wxAcceleratorEntry, GetCommand)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAcceleratorEntry::GetCommand\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAcceleratorEntry* current_object;
	wxphp_object_type current_object_type;
	wxAcceleratorEntry_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAcceleratorEntry*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAcceleratorEntry::GetCommand call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXACCELERATORENTRY_TYPE){
				references = &((wxAcceleratorEntry_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAcceleratorEntry::GetCommand())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAcceleratorEntry_php*)native_object)->GetCommand());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAcceleratorEntry::GetCommand\n");
	}
}
/* }}} */

/* {{{ proto bool wxAcceleratorEntry::FromString(string str)
   Parses the given string and sets the accelerator accordingly. */
PHP_METHOD(php_wxAcceleratorEntry, FromString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAcceleratorEntry::FromString\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAcceleratorEntry* current_object;
	wxphp_object_type current_object_type;
	wxAcceleratorEntry_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAcceleratorEntry*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAcceleratorEntry::FromString call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXACCELERATORENTRY_TYPE){
				references = &((wxAcceleratorEntry_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* str0;
	long str_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&str0, &str_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &str0, &str_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAcceleratorEntry::FromString(wxString(str0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAcceleratorEntry_php*)native_object)->FromString(wxString(str0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAcceleratorEntry::FromString\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxAcceleratorTable_free(void *object TSRMLS_DC) 
{
    zo_wxAcceleratorTable* custom_object = (zo_wxAcceleratorTable*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAcceleratorTable_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAcceleratorTable done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxAcceleratorTable_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAcceleratorTable_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxAcceleratorTable* custom_object;
    custom_object = (zo_wxAcceleratorTable*) emalloc(sizeof(zo_wxAcceleratorTable));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXACCELERATORTABLE_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxAcceleratorTable_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto bool wxAcceleratorTable::IsOk()
   Returns true if the accelerator table is valid. */
PHP_METHOD(php_wxAcceleratorTable, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAcceleratorTable::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAcceleratorTable* current_object;
	wxphp_object_type current_object_type;
	wxAcceleratorTable_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAcceleratorTable*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAcceleratorTable::IsOk call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXACCELERATORTABLE_TYPE){
				references = &((wxAcceleratorTable_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAcceleratorTable::IsOk())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAcceleratorTable_php*)native_object)->IsOk());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAcceleratorTable::IsOk\n");
	}
}
/* }}} */

/* {{{ proto  wxAcceleratorTable::wxAcceleratorTable()
   Default ctor. */
PHP_METHOD(php_wxAcceleratorTable, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAcceleratorTable::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAcceleratorTable* current_object;
	wxAcceleratorTable_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxAcceleratorTable_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxAcceleratorTable*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxAcceleratorTable::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxCalendarDateAttr_free(void *object TSRMLS_DC) 
{
    zo_wxCalendarDateAttr* custom_object = (zo_wxCalendarDateAttr*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxCalendarDateAttr_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxCalendarDateAttr done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxCalendarDateAttr_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxCalendarDateAttr_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxCalendarDateAttr* custom_object;
    custom_object = (zo_wxCalendarDateAttr*) emalloc(sizeof(zo_wxCalendarDateAttr));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXCALENDARDATEATTR_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxCalendarDateAttr_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxCalendarDateAttr::wxCalendarDateAttr(int border, wxColour colBorder)
   Constructor using default properties except the given border. */
PHP_METHOD(php_wxCalendarDateAttr, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	long border0;
	zval* colBorder0 = 0;
	wxColour* object_pointer0_1 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* colText1 = 0;
	wxColour* object_pointer1_0 = 0;
	zval* colBack1 = 0;
	wxColour* object_pointer1_1 = 0;
	zval* colBorder1 = 0;
	wxColour* object_pointer1_2 = 0;
	zval* font1 = 0;
	wxFont* object_pointer1_3 = 0;
	long border1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|O' (&border0, &colBorder0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "l|O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &border0, &colBorder0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(colBorder0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colBorder0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colBorder0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxColour*) argument_native_object;
					if (!object_pointer0_1 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(colBorder0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 0  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|OOOOl' (&colText1, php_wxColour_entry, &colBack1, php_wxColour_entry, &colBorder1, php_wxColour_entry, &font1, php_wxFont_entry, &border1)\n");
		#endif

		char parse_parameters_string[] = "|OOOOl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colText1, php_wxColour_entry, &colBack1, php_wxColour_entry, &colBorder1, php_wxColour_entry, &font1, php_wxFont_entry, &border1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colText1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colText1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colText1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxColour*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'colText' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colText1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colText' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(colBack1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colBack1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colBack1 TSRMLS_CC))->native_object;
					object_pointer1_1 = (wxColour*) argument_native_object;
					if (!object_pointer1_1 )
					{
						zend_error(E_ERROR, "Parameter 'colBack' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colBack1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colBack' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(colBorder1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colBorder1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colBorder1 TSRMLS_CC))->native_object;
					object_pointer1_2 = (wxColour*) argument_native_object;
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter 'colBorder' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colBorder1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colBorder' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(font1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font1 TSRMLS_CC))->native_object;
					object_pointer1_3 = (wxFont*) argument_native_object;
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxCalendarDateBorder) border0)\n");
				#endif

				native_object = new wxCalendarDateAttr_php((wxCalendarDateBorder) border0);

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxCalendarDateBorder) border0, *(wxColour*) object_pointer0_1)\n");
				#endif

				native_object = new wxCalendarDateAttr_php((wxCalendarDateBorder) border0, *(wxColour*) object_pointer0_1);

				native_object->references.Initialize();
				((wxCalendarDateAttr_php*) native_object)->references.AddReference(colBorder0, "wxCalendarDateAttr::wxCalendarDateAttr at call with 2 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxCalendarDateAttr_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer1_0)\n");
				#endif

				native_object = new wxCalendarDateAttr_php(*(wxColour*) object_pointer1_0);

				native_object->references.Initialize();
				((wxCalendarDateAttr_php*) native_object)->references.AddReference(colText1, "wxCalendarDateAttr::wxCalendarDateAttr at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1)\n");
				#endif

				native_object = new wxCalendarDateAttr_php(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1);

				native_object->references.Initialize();
				((wxCalendarDateAttr_php*) native_object)->references.AddReference(colText1, "wxCalendarDateAttr::wxCalendarDateAttr at call with 2 argument(s)");
				((wxCalendarDateAttr_php*) native_object)->references.AddReference(colBack1, "wxCalendarDateAttr::wxCalendarDateAttr at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1, *(wxColour*) object_pointer1_2)\n");
				#endif

				native_object = new wxCalendarDateAttr_php(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1, *(wxColour*) object_pointer1_2);

				native_object->references.Initialize();
				((wxCalendarDateAttr_php*) native_object)->references.AddReference(colText1, "wxCalendarDateAttr::wxCalendarDateAttr at call with 3 argument(s)");
				((wxCalendarDateAttr_php*) native_object)->references.AddReference(colBack1, "wxCalendarDateAttr::wxCalendarDateAttr at call with 3 argument(s)");
				((wxCalendarDateAttr_php*) native_object)->references.AddReference(colBorder1, "wxCalendarDateAttr::wxCalendarDateAttr at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1, *(wxColour*) object_pointer1_2, *(wxFont*) object_pointer1_3)\n");
				#endif

				native_object = new wxCalendarDateAttr_php(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1, *(wxColour*) object_pointer1_2, *(wxFont*) object_pointer1_3);

				native_object->references.Initialize();
				((wxCalendarDateAttr_php*) native_object)->references.AddReference(colText1, "wxCalendarDateAttr::wxCalendarDateAttr at call with 4 argument(s)");
				((wxCalendarDateAttr_php*) native_object)->references.AddReference(colBack1, "wxCalendarDateAttr::wxCalendarDateAttr at call with 4 argument(s)");
				((wxCalendarDateAttr_php*) native_object)->references.AddReference(colBorder1, "wxCalendarDateAttr::wxCalendarDateAttr at call with 4 argument(s)");
				((wxCalendarDateAttr_php*) native_object)->references.AddReference(font1, "wxCalendarDateAttr::wxCalendarDateAttr at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1, *(wxColour*) object_pointer1_2, *(wxFont*) object_pointer1_3, (wxCalendarDateBorder) border1)\n");
				#endif

				native_object = new wxCalendarDateAttr_php(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1, *(wxColour*) object_pointer1_2, *(wxFont*) object_pointer1_3, (wxCalendarDateBorder) border1);

				native_object->references.Initialize();
				((wxCalendarDateAttr_php*) native_object)->references.AddReference(colText1, "wxCalendarDateAttr::wxCalendarDateAttr at call with 5 argument(s)");
				((wxCalendarDateAttr_php*) native_object)->references.AddReference(colBack1, "wxCalendarDateAttr::wxCalendarDateAttr at call with 5 argument(s)");
				((wxCalendarDateAttr_php*) native_object)->references.AddReference(colBorder1, "wxCalendarDateAttr::wxCalendarDateAttr at call with 5 argument(s)");
				((wxCalendarDateAttr_php*) native_object)->references.AddReference(font1, "wxCalendarDateAttr::wxCalendarDateAttr at call with 5 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxCalendarDateAttr::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxCalendarDateAttr::SetTextColour(wxColour colText)
   Sets the text (foreground) colour to use. */
PHP_METHOD(php_wxCalendarDateAttr, SetTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::SetTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::SetTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colText0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colText0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colText0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colText0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colText0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colText0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colText' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colText0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colText' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarDateAttr::SetTextColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxCalendarDateAttr_php*)native_object)->SetTextColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colText0, "wxCalendarDateAttr::SetTextColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::SetTextColour\n");
	}
}
/* }}} */

/* {{{ proto  wxCalendarDateAttr::SetHoliday(bool holiday)
   If holiday is true, this calendar day will be displayed as a holiday. */
PHP_METHOD(php_wxCalendarDateAttr, SetHoliday)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::SetHoliday\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::SetHoliday call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool holiday0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&holiday0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &holiday0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarDateAttr::SetHoliday(holiday0)\n\n");
				#endif

				((wxCalendarDateAttr_php*)native_object)->SetHoliday(holiday0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::SetHoliday\n");
	}
}
/* }}} */

/* {{{ proto  wxCalendarDateAttr::SetFont(wxFont font)
   Sets the font to use. */
PHP_METHOD(php_wxCalendarDateAttr, SetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::SetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::SetFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* font0 = 0;
	wxFont* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxFont*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarDateAttr::SetFont(*(wxFont*) object_pointer0_0)\n\n");
				#endif

				((wxCalendarDateAttr_php*)native_object)->SetFont(*(wxFont*) object_pointer0_0);

				references->AddReference(font0, "wxCalendarDateAttr::SetFont at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::SetFont\n");
	}
}
/* }}} */

/* {{{ proto  wxCalendarDateAttr::SetBorderColour(wxColour col)
   Sets the border colour to use. */
PHP_METHOD(php_wxCalendarDateAttr, SetBorderColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::SetBorderColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::SetBorderColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* col0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&col0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(col0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(col0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'col' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'col' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarDateAttr::SetBorderColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxCalendarDateAttr_php*)native_object)->SetBorderColour(*(wxColour*) object_pointer0_0);

				references->AddReference(col0, "wxCalendarDateAttr::SetBorderColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::SetBorderColour\n");
	}
}
/* }}} */

/* {{{ proto  wxCalendarDateAttr::SetBorder(int border)
   Sets the border to use. */
PHP_METHOD(php_wxCalendarDateAttr, SetBorder)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::SetBorder\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::SetBorder call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long border0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&border0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &border0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarDateAttr::SetBorder((wxCalendarDateBorder) border0)\n\n");
				#endif

				((wxCalendarDateAttr_php*)native_object)->SetBorder((wxCalendarDateBorder) border0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::SetBorder\n");
	}
}
/* }}} */

/* {{{ proto  wxCalendarDateAttr::SetBackgroundColour(wxColour colBack)
   Sets the text background colour to use. */
PHP_METHOD(php_wxCalendarDateAttr, SetBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::SetBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::SetBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colBack0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colBack0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colBack0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colBack0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colBack0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colBack0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colBack' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colBack0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colBack' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarDateAttr::SetBackgroundColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxCalendarDateAttr_php*)native_object)->SetBackgroundColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colBack0, "wxCalendarDateAttr::SetBackgroundColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::SetBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto bool wxCalendarDateAttr::IsHoliday()
   Returns true if this calendar day is displayed as a holiday. */
PHP_METHOD(php_wxCalendarDateAttr, IsHoliday)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::IsHoliday\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::IsHoliday call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarDateAttr::IsHoliday())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxCalendarDateAttr_php*)native_object)->IsHoliday());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::IsHoliday\n");
	}
}
/* }}} */

/* {{{ proto bool wxCalendarDateAttr::HasTextColour()
   Returns true if a non-default text foreground colour is set. */
PHP_METHOD(php_wxCalendarDateAttr, HasTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::HasTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::HasTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarDateAttr::HasTextColour())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxCalendarDateAttr_php*)native_object)->HasTextColour());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::HasTextColour\n");
	}
}
/* }}} */

/* {{{ proto bool wxCalendarDateAttr::HasFont()
   Returns true if a non-default font is set. */
PHP_METHOD(php_wxCalendarDateAttr, HasFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::HasFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::HasFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarDateAttr::HasFont())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxCalendarDateAttr_php*)native_object)->HasFont());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::HasFont\n");
	}
}
/* }}} */

/* {{{ proto bool wxCalendarDateAttr::HasBorderColour()
   Returns true if a non-default border colour is set. */
PHP_METHOD(php_wxCalendarDateAttr, HasBorderColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::HasBorderColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::HasBorderColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarDateAttr::HasBorderColour())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxCalendarDateAttr_php*)native_object)->HasBorderColour());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::HasBorderColour\n");
	}
}
/* }}} */

/* {{{ proto bool wxCalendarDateAttr::HasBorder()
   Returns true if a non-default (i.e. */
PHP_METHOD(php_wxCalendarDateAttr, HasBorder)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::HasBorder\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::HasBorder call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarDateAttr::HasBorder())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxCalendarDateAttr_php*)native_object)->HasBorder());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::HasBorder\n");
	}
}
/* }}} */

/* {{{ proto bool wxCalendarDateAttr::HasBackgroundColour()
   Returns true if a non-default text background colour is set. */
PHP_METHOD(php_wxCalendarDateAttr, HasBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::HasBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::HasBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCalendarDateAttr::HasBackgroundColour())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxCalendarDateAttr_php*)native_object)->HasBackgroundColour());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::HasBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxCalendarDateAttr::GetTextColour()
   Returns the text colour set for the calendar date. */
PHP_METHOD(php_wxCalendarDateAttr, GetTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::GetTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::GetTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarDateAttr::GetTextColour() to return object reference\n\n");
				#endif

				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxCalendarDateAttr_php*)native_object)->GetTextColour();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxCalendarDateAttr::GetTextColour at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::GetTextColour\n");
	}
}
/* }}} */

/* {{{ proto wxCalendarDateAttr wxCalendarDateAttr::GetMark()
   Used (internally) by the generic wxCalendarCtrl::Mark(). */
PHP_METHOD(php_wxCalendarDateAttr, GetMark)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::GetMark\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::GetMark call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxCalendarDateAttr::GetMark() to return object reference\n\n");
				#endif

				wxCalendarDateAttr_php* value_to_return0;
				value_to_return0 = (wxCalendarDateAttr_php*) &wxCalendarDateAttr::GetMark();
				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxCalendarDateAttr_entry);
					((zo_wxCalendarDateAttr*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxCalendarDateAttr_php*) value_to_return0;
				}



				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::GetMark\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxCalendarDateAttr::GetFont()
   Returns the font set for the calendar date. */
PHP_METHOD(php_wxCalendarDateAttr, GetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::GetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::GetFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarDateAttr::GetFont() to return object reference\n\n");
				#endif

				wxFont_php* value_to_return0;
				value_to_return0 = (wxFont_php*) &((wxCalendarDateAttr_php*)native_object)->GetFont();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxCalendarDateAttr::GetFont at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::GetFont\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxCalendarDateAttr::GetBorderColour()
   Returns the border colour set for the calendar date. */
PHP_METHOD(php_wxCalendarDateAttr, GetBorderColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::GetBorderColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::GetBorderColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarDateAttr::GetBorderColour() to return object reference\n\n");
				#endif

				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxCalendarDateAttr_php*)native_object)->GetBorderColour();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxCalendarDateAttr::GetBorderColour at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::GetBorderColour\n");
	}
}
/* }}} */

/* {{{ proto int wxCalendarDateAttr::GetBorder()
   Returns the border set for the calendar date. */
PHP_METHOD(php_wxCalendarDateAttr, GetBorder)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::GetBorder\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::GetBorder call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxCalendarDateAttr::GetBorder())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxCalendarDateAttr_php*)native_object)->GetBorder());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::GetBorder\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxCalendarDateAttr::GetBackgroundColour()
   Returns the background colour set for the calendar date. */
PHP_METHOD(php_wxCalendarDateAttr, GetBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::GetBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::GetBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxCalendarDateAttr::GetBackgroundColour() to return object reference\n\n");
				#endif

				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxCalendarDateAttr_php*)native_object)->GetBackgroundColour();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxCalendarDateAttr::GetBackgroundColour at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::GetBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto  wxCalendarDateAttr::SetMark(wxCalendarDateAttr m)
   Set the attributes that will be used to Mark() days on the generic wxCalendarCtrl. */
PHP_METHOD(php_wxCalendarDateAttr, SetMark)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCalendarDateAttr::SetMark\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCalendarDateAttr* current_object;
	wxphp_object_type current_object_type;
	wxCalendarDateAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCalendarDateAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCalendarDateAttr::SetMark call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCALENDARDATEATTR_TYPE){
				references = &((wxCalendarDateAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* m0 = 0;
	wxCalendarDateAttr* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&m0, php_wxCalendarDateAttr_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &m0, php_wxCalendarDateAttr_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(m0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxCalendarDateAttr*) zend_object_store_get_object(m0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxCalendarDateAttr*) zend_object_store_get_object(m0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxCalendarDateAttr*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'm' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(m0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'm' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxCalendarDateAttr::SetMark(*(wxCalendarDateAttr*) object_pointer0_0)\n\n");
				#endif

				wxCalendarDateAttr::SetMark(*(wxCalendarDateAttr*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCalendarDateAttr::SetMark\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPageSetupDialogData_free(void *object TSRMLS_DC) 
{
    zo_wxPageSetupDialogData* custom_object = (zo_wxPageSetupDialogData*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPageSetupDialogData_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxPageSetupDialogData done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxPageSetupDialogData_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPageSetupDialogData_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxPageSetupDialogData* custom_object;
    custom_object = (zo_wxPageSetupDialogData*) emalloc(sizeof(zo_wxPageSetupDialogData));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPAGESETUPDIALOGDATA_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxPageSetupDialogData_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxPageSetupDialogData::EnableHelp(bool flag)
   Enables or disables the "Help" button (Windows only). */
PHP_METHOD(php_wxPageSetupDialogData, EnableHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::EnableHelp\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::EnableHelp call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&flag0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::EnableHelp(flag0)\n\n");
				#endif

				((wxPageSetupDialogData_php*)native_object)->EnableHelp(flag0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::EnableHelp\n");
	}
}
/* }}} */

/* {{{ proto  wxPageSetupDialogData::EnableMargins(bool flag)
   Enables or disables the margin controls (Windows only). */
PHP_METHOD(php_wxPageSetupDialogData, EnableMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::EnableMargins\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::EnableMargins call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&flag0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::EnableMargins(flag0)\n\n");
				#endif

				((wxPageSetupDialogData_php*)native_object)->EnableMargins(flag0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::EnableMargins\n");
	}
}
/* }}} */

/* {{{ proto  wxPageSetupDialogData::EnableOrientation(bool flag)
   Enables or disables the orientation control (Windows only). */
PHP_METHOD(php_wxPageSetupDialogData, EnableOrientation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::EnableOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::EnableOrientation call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&flag0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::EnableOrientation(flag0)\n\n");
				#endif

				((wxPageSetupDialogData_php*)native_object)->EnableOrientation(flag0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::EnableOrientation\n");
	}
}
/* }}} */

/* {{{ proto  wxPageSetupDialogData::EnablePaper(bool flag)
   Enables or disables the paper size control (Windows only). */
PHP_METHOD(php_wxPageSetupDialogData, EnablePaper)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::EnablePaper\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::EnablePaper call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&flag0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::EnablePaper(flag0)\n\n");
				#endif

				((wxPageSetupDialogData_php*)native_object)->EnablePaper(flag0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::EnablePaper\n");
	}
}
/* }}} */

/* {{{ proto  wxPageSetupDialogData::EnablePrinter(bool flag)
   Enables or disables the "Printer" button, which invokes a printer setup dialog. */
PHP_METHOD(php_wxPageSetupDialogData, EnablePrinter)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::EnablePrinter\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::EnablePrinter call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&flag0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::EnablePrinter(flag0)\n\n");
				#endif

				((wxPageSetupDialogData_php*)native_object)->EnablePrinter(flag0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::EnablePrinter\n");
	}
}
/* }}} */

/* {{{ proto bool wxPageSetupDialogData::GetDefaultInfo()
   Returns true if the dialog will simply return default printer information (such as orientation) instead of showing a dialog (Windows only). */
PHP_METHOD(php_wxPageSetupDialogData, GetDefaultInfo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::GetDefaultInfo\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::GetDefaultInfo call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPageSetupDialogData::GetDefaultInfo())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPageSetupDialogData_php*)native_object)->GetDefaultInfo());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::GetDefaultInfo\n");
	}
}
/* }}} */

/* {{{ proto bool wxPageSetupDialogData::GetDefaultMinMargins()
   Returns true if the page setup dialog will take its minimum margin values from the currently selected printer properties (Windows only). */
PHP_METHOD(php_wxPageSetupDialogData, GetDefaultMinMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::GetDefaultMinMargins\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::GetDefaultMinMargins call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPageSetupDialogData::GetDefaultMinMargins())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPageSetupDialogData_php*)native_object)->GetDefaultMinMargins());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::GetDefaultMinMargins\n");
	}
}
/* }}} */

/* {{{ proto bool wxPageSetupDialogData::GetEnableHelp()
   Returns true if the printer setup button is enabled. */
PHP_METHOD(php_wxPageSetupDialogData, GetEnableHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::GetEnableHelp\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::GetEnableHelp call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPageSetupDialogData::GetEnableHelp())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPageSetupDialogData_php*)native_object)->GetEnableHelp());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::GetEnableHelp\n");
	}
}
/* }}} */

/* {{{ proto bool wxPageSetupDialogData::GetEnableMargins()
   Returns true if the margin controls are enabled (Windows only). */
PHP_METHOD(php_wxPageSetupDialogData, GetEnableMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::GetEnableMargins\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::GetEnableMargins call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPageSetupDialogData::GetEnableMargins())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPageSetupDialogData_php*)native_object)->GetEnableMargins());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::GetEnableMargins\n");
	}
}
/* }}} */

/* {{{ proto bool wxPageSetupDialogData::GetEnableOrientation()
   Returns true if the orientation control is enabled (Windows only). */
PHP_METHOD(php_wxPageSetupDialogData, GetEnableOrientation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::GetEnableOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::GetEnableOrientation call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPageSetupDialogData::GetEnableOrientation())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPageSetupDialogData_php*)native_object)->GetEnableOrientation());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::GetEnableOrientation\n");
	}
}
/* }}} */

/* {{{ proto bool wxPageSetupDialogData::GetEnablePaper()
   Returns true if the paper size control is enabled (Windows only). */
PHP_METHOD(php_wxPageSetupDialogData, GetEnablePaper)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::GetEnablePaper\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::GetEnablePaper call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPageSetupDialogData::GetEnablePaper())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPageSetupDialogData_php*)native_object)->GetEnablePaper());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::GetEnablePaper\n");
	}
}
/* }}} */

/* {{{ proto bool wxPageSetupDialogData::GetEnablePrinter()
   Returns true if the printer setup button is enabled. */
PHP_METHOD(php_wxPageSetupDialogData, GetEnablePrinter)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::GetEnablePrinter\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::GetEnablePrinter call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPageSetupDialogData::GetEnablePrinter())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPageSetupDialogData_php*)native_object)->GetEnablePrinter());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::GetEnablePrinter\n");
	}
}
/* }}} */

/* {{{ proto wxPoint wxPageSetupDialogData::GetMarginBottomRight()
   Returns the right (x) and bottom (y) margins in millimetres. */
PHP_METHOD(php_wxPageSetupDialogData, GetMarginBottomRight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::GetMarginBottomRight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::GetMarginBottomRight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::GetMarginBottomRight() to return new object\n\n");
				#endif

				wxPoint value_to_return0;
				value_to_return0 = ((wxPageSetupDialogData_php*)native_object)->GetMarginBottomRight();
				void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxPoint));
				object_init_ex(return_value, php_wxPoint_entry);
				((zo_wxPoint*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPoint_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::GetMarginBottomRight\n");
	}
}
/* }}} */

/* {{{ proto wxPoint wxPageSetupDialogData::GetMarginTopLeft()
   Returns the left (x) and top (y) margins in millimetres. */
PHP_METHOD(php_wxPageSetupDialogData, GetMarginTopLeft)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::GetMarginTopLeft\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::GetMarginTopLeft call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::GetMarginTopLeft() to return new object\n\n");
				#endif

				wxPoint value_to_return0;
				value_to_return0 = ((wxPageSetupDialogData_php*)native_object)->GetMarginTopLeft();
				void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxPoint));
				object_init_ex(return_value, php_wxPoint_entry);
				((zo_wxPoint*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPoint_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::GetMarginTopLeft\n");
	}
}
/* }}} */

/* {{{ proto wxPoint wxPageSetupDialogData::GetMinMarginBottomRight()
   Returns the right (x) and bottom (y) minimum margins the user can enter (Windows only). */
PHP_METHOD(php_wxPageSetupDialogData, GetMinMarginBottomRight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::GetMinMarginBottomRight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::GetMinMarginBottomRight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::GetMinMarginBottomRight() to return new object\n\n");
				#endif

				wxPoint value_to_return0;
				value_to_return0 = ((wxPageSetupDialogData_php*)native_object)->GetMinMarginBottomRight();
				void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxPoint));
				object_init_ex(return_value, php_wxPoint_entry);
				((zo_wxPoint*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPoint_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::GetMinMarginBottomRight\n");
	}
}
/* }}} */

/* {{{ proto wxPoint wxPageSetupDialogData::GetMinMarginTopLeft()
   Returns the left (x) and top (y) minimum margins the user can enter (Windows only). */
PHP_METHOD(php_wxPageSetupDialogData, GetMinMarginTopLeft)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::GetMinMarginTopLeft\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::GetMinMarginTopLeft call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::GetMinMarginTopLeft() to return new object\n\n");
				#endif

				wxPoint value_to_return0;
				value_to_return0 = ((wxPageSetupDialogData_php*)native_object)->GetMinMarginTopLeft();
				void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxPoint));
				object_init_ex(return_value, php_wxPoint_entry);
				((zo_wxPoint*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPoint_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::GetMinMarginTopLeft\n");
	}
}
/* }}} */

/* {{{ proto wxPaperSize wxPageSetupDialogData::GetPaperId()
   Returns the paper id (stored in the internal wxPrintData object). */
PHP_METHOD(php_wxPageSetupDialogData, GetPaperId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::GetPaperId\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::GetPaperId call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPageSetupDialogData::GetPaperId())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPageSetupDialogData_php*)native_object)->GetPaperId());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::GetPaperId\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxPageSetupDialogData::GetPaperSize()
   Returns the paper size in millimetres. */
PHP_METHOD(php_wxPageSetupDialogData, GetPaperSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::GetPaperSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::GetPaperSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::GetPaperSize() to return new object\n\n");
				#endif

				wxSize value_to_return0;
				value_to_return0 = ((wxPageSetupDialogData_php*)native_object)->GetPaperSize();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				((zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxSize_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::GetPaperSize\n");
	}
}
/* }}} */

/* {{{ proto wxPrintData wxPageSetupDialogData::GetPrintData()
   Returns a reference to the print data associated with this object. */
PHP_METHOD(php_wxPageSetupDialogData, GetPrintData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::GetPrintData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::GetPrintData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::GetPrintData() to return object reference\n\n");
				#endif

				wxPrintData_php* value_to_return0;
				value_to_return0 = (wxPrintData_php*) &((wxPageSetupDialogData_php*)native_object)->GetPrintData();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxPrintData_entry);
					((zo_wxPrintData*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPrintData_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxPageSetupDialogData::GetPrintData at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::GetPrintData() to return object reference\n\n");
				#endif

				wxPrintData_php* value_to_return0;
				value_to_return0 = (wxPrintData_php*) &((wxPageSetupDialogData_php*)native_object)->GetPrintData();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxPrintData_entry);
					((zo_wxPrintData*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPrintData_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxPageSetupDialogData::GetPrintData at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::GetPrintData\n");
	}
}
/* }}} */

/* {{{ proto bool wxPageSetupDialogData::IsOk()
   Returns true if the print data associated with the dialog data is valid. */
PHP_METHOD(php_wxPageSetupDialogData, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::IsOk call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPageSetupDialogData::IsOk())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPageSetupDialogData_php*)native_object)->IsOk());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::IsOk\n");
	}
}
/* }}} */

/* {{{ proto  wxPageSetupDialogData::SetDefaultInfo(bool flag)
   Pass true if the dialog will simply return default printer information (such as orientation) instead of showing a dialog (Windows only). */
PHP_METHOD(php_wxPageSetupDialogData, SetDefaultInfo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::SetDefaultInfo\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::SetDefaultInfo call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&flag0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::SetDefaultInfo(flag0)\n\n");
				#endif

				((wxPageSetupDialogData_php*)native_object)->SetDefaultInfo(flag0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::SetDefaultInfo\n");
	}
}
/* }}} */

/* {{{ proto  wxPageSetupDialogData::SetDefaultMinMargins(bool flag)
   Pass true if the page setup dialog will take its minimum margin values from the currently selected printer properties (Windows only). */
PHP_METHOD(php_wxPageSetupDialogData, SetDefaultMinMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::SetDefaultMinMargins\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::SetDefaultMinMargins call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&flag0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::SetDefaultMinMargins(flag0)\n\n");
				#endif

				((wxPageSetupDialogData_php*)native_object)->SetDefaultMinMargins(flag0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::SetDefaultMinMargins\n");
	}
}
/* }}} */

/* {{{ proto  wxPageSetupDialogData::SetMarginBottomRight(wxPoint pt)
   Sets the right (x) and bottom (y) margins in millimetres. */
PHP_METHOD(php_wxPageSetupDialogData, SetMarginBottomRight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::SetMarginBottomRight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::SetMarginBottomRight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* pt0 = 0;
	wxPoint* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt0, php_wxPoint_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt0, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pt0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pt0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxPoint*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::SetMarginBottomRight(*(wxPoint*) object_pointer0_0)\n\n");
				#endif

				((wxPageSetupDialogData_php*)native_object)->SetMarginBottomRight(*(wxPoint*) object_pointer0_0);

				references->AddReference(pt0, "wxPageSetupDialogData::SetMarginBottomRight at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::SetMarginBottomRight\n");
	}
}
/* }}} */

/* {{{ proto  wxPageSetupDialogData::SetMarginTopLeft(wxPoint pt)
   Sets the left (x) and top (y) margins in millimetres. */
PHP_METHOD(php_wxPageSetupDialogData, SetMarginTopLeft)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::SetMarginTopLeft\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::SetMarginTopLeft call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* pt0 = 0;
	wxPoint* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt0, php_wxPoint_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt0, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pt0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pt0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxPoint*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::SetMarginTopLeft(*(wxPoint*) object_pointer0_0)\n\n");
				#endif

				((wxPageSetupDialogData_php*)native_object)->SetMarginTopLeft(*(wxPoint*) object_pointer0_0);

				references->AddReference(pt0, "wxPageSetupDialogData::SetMarginTopLeft at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::SetMarginTopLeft\n");
	}
}
/* }}} */

/* {{{ proto  wxPageSetupDialogData::SetMinMarginBottomRight(wxPoint pt)
   Sets the right (x) and bottom (y) minimum margins the user can enter (Windows only). */
PHP_METHOD(php_wxPageSetupDialogData, SetMinMarginBottomRight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::SetMinMarginBottomRight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::SetMinMarginBottomRight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* pt0 = 0;
	wxPoint* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt0, php_wxPoint_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt0, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pt0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pt0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxPoint*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::SetMinMarginBottomRight(*(wxPoint*) object_pointer0_0)\n\n");
				#endif

				((wxPageSetupDialogData_php*)native_object)->SetMinMarginBottomRight(*(wxPoint*) object_pointer0_0);

				references->AddReference(pt0, "wxPageSetupDialogData::SetMinMarginBottomRight at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::SetMinMarginBottomRight\n");
	}
}
/* }}} */

/* {{{ proto  wxPageSetupDialogData::SetMinMarginTopLeft(wxPoint pt)
   Sets the left (x) and top (y) minimum margins the user can enter (Windows only). */
PHP_METHOD(php_wxPageSetupDialogData, SetMinMarginTopLeft)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::SetMinMarginTopLeft\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::SetMinMarginTopLeft call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* pt0 = 0;
	wxPoint* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt0, php_wxPoint_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt0, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pt0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pt0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxPoint*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::SetMinMarginTopLeft(*(wxPoint*) object_pointer0_0)\n\n");
				#endif

				((wxPageSetupDialogData_php*)native_object)->SetMinMarginTopLeft(*(wxPoint*) object_pointer0_0);

				references->AddReference(pt0, "wxPageSetupDialogData::SetMinMarginTopLeft at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::SetMinMarginTopLeft\n");
	}
}
/* }}} */

/* {{{ proto  wxPageSetupDialogData::SetPaperId(wxPaperSize id)
   Sets the paper size id. */
PHP_METHOD(php_wxPageSetupDialogData, SetPaperId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::SetPaperId\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::SetPaperId call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::SetPaperId((wxPaperSize) id0)\n\n");
				#endif

				((wxPageSetupDialogData_php*)native_object)->SetPaperId((wxPaperSize) id0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::SetPaperId\n");
	}
}
/* }}} */

/* {{{ proto  wxPageSetupDialogData::SetPaperSize(wxSize size)
   Sets the paper size in millimetres. */
PHP_METHOD(php_wxPageSetupDialogData, SetPaperSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::SetPaperSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::SetPaperSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* size0 = 0;
	wxSize* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size0, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size0, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxSize*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::SetPaperSize(*(wxSize*) object_pointer0_0)\n\n");
				#endif

				((wxPageSetupDialogData_php*)native_object)->SetPaperSize(*(wxSize*) object_pointer0_0);

				references->AddReference(size0, "wxPageSetupDialogData::SetPaperSize at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::SetPaperSize\n");
	}
}
/* }}} */

/* {{{ proto  wxPageSetupDialogData::SetPrintData(wxPrintData printData)
   Sets the print data associated with this object. */
PHP_METHOD(php_wxPageSetupDialogData, SetPrintData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::SetPrintData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxphp_object_type current_object_type;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPageSetupDialogData::SetPrintData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPAGESETUPDIALOGDATA_TYPE){
				references = &((wxPageSetupDialogData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* printData0 = 0;
	wxPrintData* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&printData0, php_wxPrintData_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &printData0, php_wxPrintData_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(printData0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPrintData*) zend_object_store_get_object(printData0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPrintData*) zend_object_store_get_object(printData0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxPrintData*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'printData' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(printData0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'printData' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPageSetupDialogData::SetPrintData(*(wxPrintData*) object_pointer0_0)\n\n");
				#endif

				((wxPageSetupDialogData_php*)native_object)->SetPrintData(*(wxPrintData*) object_pointer0_0);

				references->AddReference(printData0, "wxPageSetupDialogData::SetPrintData at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPageSetupDialogData::SetPrintData\n");
	}
}
/* }}} */

/* {{{ proto  wxPageSetupDialogData::wxPageSetupDialogData()
   Default constructor. */
PHP_METHOD(php_wxPageSetupDialogData, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPageSetupDialogData::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPageSetupDialogData* current_object;
	wxPageSetupDialogData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* printData1 = 0;
	wxPrintData* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&printData1, php_wxPrintData_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &printData1, php_wxPrintData_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(printData1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPrintData*) zend_object_store_get_object(printData1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPrintData*) zend_object_store_get_object(printData1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxPrintData*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'printData' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(printData1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'printData' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxPageSetupDialogData_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxPrintData*) object_pointer1_0)\n");
				#endif

				native_object = new wxPageSetupDialogData_php(*(wxPrintData*) object_pointer1_0);

				native_object->references.Initialize();
				((wxPageSetupDialogData_php*) native_object)->references.AddReference(printData1, "wxPageSetupDialogData::wxPageSetupDialogData at call with 1 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxPageSetupDialogData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxPageSetupDialogData::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPrintData_free(void *object TSRMLS_DC) 
{
    zo_wxPrintData* custom_object = (zo_wxPrintData*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPrintData_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxPrintData done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxPrintData_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPrintData_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxPrintData* custom_object;
    custom_object = (zo_wxPrintData*) emalloc(sizeof(zo_wxPrintData));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPRINTDATA_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxPrintData_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto wxPrintBin wxPrintData::GetBin()
   Returns the current bin (papersource). */
PHP_METHOD(php_wxPrintData, GetBin)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::GetBin\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::GetBin call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPrintData::GetBin())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPrintData_php*)native_object)->GetBin());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::GetBin\n");
	}
}
/* }}} */

/* {{{ proto bool wxPrintData::GetCollate()
   Returns true if collation is on. */
PHP_METHOD(php_wxPrintData, GetCollate)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::GetCollate\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::GetCollate call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPrintData::GetCollate())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPrintData_php*)native_object)->GetCollate());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::GetCollate\n");
	}
}
/* }}} */

/* {{{ proto bool wxPrintData::GetColour()
   Returns true if colour printing is on. */
PHP_METHOD(php_wxPrintData, GetColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::GetColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::GetColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPrintData::GetColour())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPrintData_php*)native_object)->GetColour());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::GetColour\n");
	}
}
/* }}} */

/* {{{ proto wxDuplexMode wxPrintData::GetDuplex()
   Returns the duplex mode. */
PHP_METHOD(php_wxPrintData, GetDuplex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::GetDuplex\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::GetDuplex call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPrintData::GetDuplex())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPrintData_php*)native_object)->GetDuplex());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::GetDuplex\n");
	}
}
/* }}} */

/* {{{ proto string wxPrintData::GetFilename() */
PHP_METHOD(php_wxPrintData, GetFilename)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::GetFilename\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::GetFilename call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxPrintData::GetFilename().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxPrintData_php*)native_object)->GetFilename();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::GetFilename\n");
	}
}
/* }}} */

/* {{{ proto int wxPrintData::GetNoCopies()
   Returns the number of copies requested by the user. */
PHP_METHOD(php_wxPrintData, GetNoCopies)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::GetNoCopies\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::GetNoCopies call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPrintData::GetNoCopies())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPrintData_php*)native_object)->GetNoCopies());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::GetNoCopies\n");
	}
}
/* }}} */

/* {{{ proto wxPrintOrientation wxPrintData::GetOrientation()
   Gets the orientation. */
PHP_METHOD(php_wxPrintData, GetOrientation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::GetOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::GetOrientation call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPrintData::GetOrientation())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPrintData_php*)native_object)->GetOrientation());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::GetOrientation\n");
	}
}
/* }}} */

/* {{{ proto wxPaperSize wxPrintData::GetPaperId()
   Returns the paper size id. */
PHP_METHOD(php_wxPrintData, GetPaperId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::GetPaperId\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::GetPaperId call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPrintData::GetPaperId())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPrintData_php*)native_object)->GetPaperId());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::GetPaperId\n");
	}
}
/* }}} */

/* {{{ proto wxPrintMode wxPrintData::GetPrintMode() */
PHP_METHOD(php_wxPrintData, GetPrintMode)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::GetPrintMode\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::GetPrintMode call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPrintData::GetPrintMode())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPrintData_php*)native_object)->GetPrintMode());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::GetPrintMode\n");
	}
}
/* }}} */

/* {{{ proto string wxPrintData::GetPrinterName()
   Returns the printer name. */
PHP_METHOD(php_wxPrintData, GetPrinterName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::GetPrinterName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::GetPrinterName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxPrintData::GetPrinterName().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxPrintData_php*)native_object)->GetPrinterName();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::GetPrinterName\n");
	}
}
/* }}} */

/* {{{ proto int wxPrintData::GetQuality()
   Returns the current print quality. */
PHP_METHOD(php_wxPrintData, GetQuality)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::GetQuality\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::GetQuality call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPrintData::GetQuality())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPrintData_php*)native_object)->GetQuality());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::GetQuality\n");
	}
}
/* }}} */

/* {{{ proto bool wxPrintData::IsOk()
   Returns true if the print data is valid for using in print dialogs. */
PHP_METHOD(php_wxPrintData, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::IsOk call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPrintData::IsOk())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPrintData_php*)native_object)->IsOk());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::IsOk\n");
	}
}
/* }}} */

/* {{{ proto  wxPrintData::SetBin(wxPrintBin flag)
   Sets the current bin. */
PHP_METHOD(php_wxPrintData, SetBin)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::SetBin\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::SetBin call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flag0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPrintData::SetBin((wxPrintBin) flag0)\n\n");
				#endif

				((wxPrintData_php*)native_object)->SetBin((wxPrintBin) flag0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::SetBin\n");
	}
}
/* }}} */

/* {{{ proto  wxPrintData::SetCollate(bool flag)
   Sets collation to on or off. */
PHP_METHOD(php_wxPrintData, SetCollate)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::SetCollate\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::SetCollate call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&flag0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPrintData::SetCollate(flag0)\n\n");
				#endif

				((wxPrintData_php*)native_object)->SetCollate(flag0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::SetCollate\n");
	}
}
/* }}} */

/* {{{ proto  wxPrintData::SetColour(bool flag)
   Sets colour printing on or off. */
PHP_METHOD(php_wxPrintData, SetColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::SetColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::SetColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&flag0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPrintData::SetColour(flag0)\n\n");
				#endif

				((wxPrintData_php*)native_object)->SetColour(flag0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::SetColour\n");
	}
}
/* }}} */

/* {{{ proto  wxPrintData::SetDuplex(wxDuplexMode mode)
   Returns the duplex mode. */
PHP_METHOD(php_wxPrintData, SetDuplex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::SetDuplex\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::SetDuplex call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long mode0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&mode0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &mode0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPrintData::SetDuplex((wxDuplexMode) mode0)\n\n");
				#endif

				((wxPrintData_php*)native_object)->SetDuplex((wxDuplexMode) mode0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::SetDuplex\n");
	}
}
/* }}} */

/* {{{ proto  wxPrintData::SetFilename(string filename) */
PHP_METHOD(php_wxPrintData, SetFilename)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::SetFilename\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::SetFilename call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* filename0;
	long filename_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&filename0, &filename_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filename0, &filename_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPrintData::SetFilename(wxString(filename0, wxConvUTF8))\n\n");
				#endif

				((wxPrintData_php*)native_object)->SetFilename(wxString(filename0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::SetFilename\n");
	}
}
/* }}} */

/* {{{ proto  wxPrintData::SetNoCopies(int n)
   Sets the default number of copies to be printed out. */
PHP_METHOD(php_wxPrintData, SetNoCopies)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::SetNoCopies\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::SetNoCopies call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPrintData::SetNoCopies((int) n0)\n\n");
				#endif

				((wxPrintData_php*)native_object)->SetNoCopies((int) n0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::SetNoCopies\n");
	}
}
/* }}} */

/* {{{ proto  wxPrintData::SetOrientation(wxPrintOrientation orientation)
   Sets the orientation. */
PHP_METHOD(php_wxPrintData, SetOrientation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::SetOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::SetOrientation call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long orientation0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&orientation0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &orientation0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPrintData::SetOrientation((wxPrintOrientation) orientation0)\n\n");
				#endif

				((wxPrintData_php*)native_object)->SetOrientation((wxPrintOrientation) orientation0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::SetOrientation\n");
	}
}
/* }}} */

/* {{{ proto  wxPrintData::SetPaperId(wxPaperSize paperId)
   Sets the paper id. */
PHP_METHOD(php_wxPrintData, SetPaperId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::SetPaperId\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::SetPaperId call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long paperId0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&paperId0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &paperId0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPrintData::SetPaperId((wxPaperSize) paperId0)\n\n");
				#endif

				((wxPrintData_php*)native_object)->SetPaperId((wxPaperSize) paperId0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::SetPaperId\n");
	}
}
/* }}} */

/* {{{ proto  wxPrintData::SetPrintMode(wxPrintMode printMode) */
PHP_METHOD(php_wxPrintData, SetPrintMode)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::SetPrintMode\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::SetPrintMode call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long printMode0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&printMode0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &printMode0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPrintData::SetPrintMode((wxPrintMode) printMode0)\n\n");
				#endif

				((wxPrintData_php*)native_object)->SetPrintMode((wxPrintMode) printMode0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::SetPrintMode\n");
	}
}
/* }}} */

/* {{{ proto  wxPrintData::SetPrinterName(string printerName)
   Sets the printer name. */
PHP_METHOD(php_wxPrintData, SetPrinterName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::SetPrinterName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::SetPrinterName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* printerName0;
	long printerName_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&printerName0, &printerName_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &printerName0, &printerName_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPrintData::SetPrinterName(wxString(printerName0, wxConvUTF8))\n\n");
				#endif

				((wxPrintData_php*)native_object)->SetPrinterName(wxString(printerName0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::SetPrinterName\n");
	}
}
/* }}} */

/* {{{ proto  wxPrintData::SetQuality(int quality)
   Sets the desired print quality. */
PHP_METHOD(php_wxPrintData, SetQuality)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::SetQuality\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxphp_object_type current_object_type;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPrintData::SetQuality call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPRINTDATA_TYPE){
				references = &((wxPrintData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long quality0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&quality0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &quality0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPrintData::SetQuality((wxPrintQuality) quality0)\n\n");
				#endif

				((wxPrintData_php*)native_object)->SetQuality((wxPrintQuality) quality0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPrintData::SetQuality\n");
	}
}
/* }}} */

/* {{{ proto  wxPrintData::wxPrintData()
   Default constructor. */
PHP_METHOD(php_wxPrintData, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPrintData::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPrintData* current_object;
	wxPrintData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxPrintData_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxPrintData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxPrintData::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxRealPoint_free(void *object TSRMLS_DC) 
{
    zo_wxRealPoint* custom_object = (zo_wxRealPoint*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxRealPoint_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxRealPoint done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxRealPoint_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxRealPoint_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxRealPoint* custom_object;
    custom_object = (zo_wxRealPoint*) emalloc(sizeof(zo_wxRealPoint));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXREALPOINT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxRealPoint_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxRealPoint::wxRealPoint()
   Initializes to zero the x and y members. */
PHP_METHOD(php_wxRealPoint, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRealPoint::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRealPoint* current_object;
	wxRealPoint_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	double x1;
	double y1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* pt2 = 0;
	wxPoint* object_pointer2_0 = 0;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'dd' (&x1, &y1)\n");
		#endif

		char parse_parameters_string[] = "dd";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x1, &y1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt2, php_wxPoint_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt2, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pt2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pt2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxPoint*) argument_native_object;
					if (!object_pointer2_0 )
					{
						zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxRealPoint_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(x1, y1)\n");
				#endif

				native_object = new wxRealPoint_php(x1, y1);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxPoint*) object_pointer2_0)\n");
				#endif

				native_object = new wxRealPoint_php(*(wxPoint*) object_pointer2_0);

				native_object->references.Initialize();
				((wxRealPoint_php*) native_object)->references.AddReference(pt2, "wxRealPoint::wxRealPoint at call with 1 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxRealPoint*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxRealPoint::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

PHP_METHOD(php_wxRealPoint, __get)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRealPoint::__get\n");
	php_printf("===========================================\n");
	#endif
	
	int arguments_received = ZEND_NUM_ARGS();
	zo_wxRealPoint* current_object;
	wxRealPoint_php* native_object;
	
	char* name;
	int name_len;
	
	//Get native object of the php object that called the method
	if (getThis() != NULL) 
	{
		current_object = (zo_wxRealPoint*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRealPoint::wxRealPoint call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
		}
	}
	else
	{
		zend_error(E_ERROR, "Could not process __get call as static\n");
	}
	
	char parse_parameters_string[] = "s";
	
	if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name, &name_len ) == FAILURE)
	{
		RETVAL_NULL();
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Property to get: %s\n", name);
	php_printf("===========================================\n\n");
	#endif
	
	if(false){}
	else if(strcmp("x", name) == 0)
	{
		RETVAL_DOUBLE(*((double*) native_object->properties[0]));
	}
	else if(strcmp("y", name) == 0)
	{
		RETVAL_DOUBLE(*((double*) native_object->properties[1]));
	}
	else
	{
		RETVAL_NULL();
	}
}
BEGIN_EXTERN_C()
void php_wxRect_free(void *object TSRMLS_DC) 
{
    zo_wxRect* custom_object = (zo_wxRect*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxRect_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxRect done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxRect_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxRect_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxRect* custom_object;
    custom_object = (zo_wxRect*) emalloc(sizeof(zo_wxRect));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXRECT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxRect_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxRect::wxRect()
   Default constructor. */
PHP_METHOD(php_wxRect, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	long x1;
	long y1;
	long width1;
	long height1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* topLeft2 = 0;
	wxPoint* object_pointer2_0 = 0;
	zval* bottomRight2 = 0;
	wxPoint* object_pointer2_1 = 0;
	bool overload2_called = false;
	//Parameters for overload 3
	zval* pos3 = 0;
	wxPoint* object_pointer3_0 = 0;
	zval* size3 = 0;
	wxSize* object_pointer3_1 = 0;
	bool overload3_called = false;
	//Parameters for overload 4
	zval* size4 = 0;
	wxSize* object_pointer4_0 = 0;
	bool overload4_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll' (&x1, &y1, &width1, &height1)\n");
		#endif

		char parse_parameters_string[] = "llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x1, &y1, &width1, &height1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&topLeft2, php_wxPoint_entry, &bottomRight2, php_wxPoint_entry)\n");
		#endif

		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &topLeft2, php_wxPoint_entry, &bottomRight2, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(topLeft2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(topLeft2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(topLeft2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxPoint*) argument_native_object;
					if (!object_pointer2_0 )
					{
						goto overload3;
					}
				}
				else if(Z_TYPE_P(topLeft2) != IS_NULL)
				{
					goto overload3;
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(bottomRight2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(bottomRight2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(bottomRight2 TSRMLS_CC))->native_object;
					object_pointer2_1 = (wxPoint*) argument_native_object;
					if (!object_pointer2_1 )
					{
						goto overload3;
					}
				}
				else if(Z_TYPE_P(bottomRight2) != IS_NULL)
				{
					goto overload3;
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&pos3, php_wxPoint_entry, &size3, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos3, php_wxPoint_entry, &size3, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pos3) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pos3 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pos3 TSRMLS_CC))->native_object;
					object_pointer3_0 = (wxPoint*) argument_native_object;
					if (!object_pointer3_0 )
					{
						goto overload4;
					}
				}
				else if(Z_TYPE_P(pos3) != IS_NULL)
				{
					goto overload4;
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(size3) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size3 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size3 TSRMLS_CC))->native_object;
					object_pointer3_1 = (wxSize*) argument_native_object;
					if (!object_pointer3_1 )
					{
						goto overload4;
					}
				}
				else if(Z_TYPE_P(size3) != IS_NULL)
				{
					goto overload4;
				}
			}

			overload3_called = true;
			already_called = true;
		}
	}

	//Overload 4
	overload4:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size4, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size4, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size4) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size4 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size4 TSRMLS_CC))->native_object;
					object_pointer4_0 = (wxSize*) argument_native_object;
					if (!object_pointer4_0 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size4) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			overload4_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxRect_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) x1, (int) y1, (int) width1, (int) height1)\n");
				#endif

				native_object = new wxRect_php((int) x1, (int) y1, (int) width1, (int) height1);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxPoint*) object_pointer2_0, *(wxPoint*) object_pointer2_1)\n");
				#endif

				native_object = new wxRect_php(*(wxPoint*) object_pointer2_0, *(wxPoint*) object_pointer2_1);

				native_object->references.Initialize();
				((wxRect_php*) native_object)->references.AddReference(topLeft2, "wxRect::wxRect at call with 2 argument(s)");
				((wxRect_php*) native_object)->references.AddReference(bottomRight2, "wxRect::wxRect at call with 2 argument(s)");
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxPoint*) object_pointer3_0, *(wxSize*) object_pointer3_1)\n");
				#endif

				native_object = new wxRect_php(*(wxPoint*) object_pointer3_0, *(wxSize*) object_pointer3_1);

				native_object->references.Initialize();
				((wxRect_php*) native_object)->references.AddReference(pos3, "wxRect::wxRect at call with 2 argument(s)");
				((wxRect_php*) native_object)->references.AddReference(size3, "wxRect::wxRect at call with 2 argument(s)");
				break;
			}
		}
	}

	if(overload4_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxSize*) object_pointer4_0)\n");
				#endif

				native_object = new wxRect_php(*(wxSize*) object_pointer4_0);

				native_object->references.Initialize();
				((wxRect_php*) native_object)->references.AddReference(size4, "wxRect::wxRect at call with 1 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxRect::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

PHP_METHOD(php_wxRect, __get)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::__get\n");
	php_printf("===========================================\n");
	#endif
	
	int arguments_received = ZEND_NUM_ARGS();
	zo_wxRect* current_object;
	wxRect_php* native_object;
	
	char* name;
	int name_len;
	
	//Get native object of the php object that called the method
	if (getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::wxRect call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
		}
	}
	else
	{
		zend_error(E_ERROR, "Could not process __get call as static\n");
	}
	
	char parse_parameters_string[] = "s";
	
	if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name, &name_len ) == FAILURE)
	{
		RETVAL_NULL();
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Property to get: %s\n", name);
	php_printf("===========================================\n\n");
	#endif
	
	if(false){}
	else if(strcmp("height", name) == 0)
	{
		RETVAL_LONG(*((int*) native_object->properties[0]));
	}
	else if(strcmp("width", name) == 0)
	{
		RETVAL_LONG(*((int*) native_object->properties[1]));
	}
	else if(strcmp("x", name) == 0)
	{
		RETVAL_LONG(*((int*) native_object->properties[2]));
	}
	else if(strcmp("y", name) == 0)
	{
		RETVAL_LONG(*((int*) native_object->properties[3]));
	}
	else
	{
		RETVAL_NULL();
	}
}
/* {{{ proto  wxRect::SetX(int x)
   Sets the x position. */
PHP_METHOD(php_wxRect, SetX)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::SetX\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::SetX call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&x0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::SetX((int) x0)\n\n");
				#endif

				((wxRect_php*)native_object)->SetX((int) x0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::SetX\n");
	}
}
/* }}} */

/* {{{ proto  wxRect::SetY(int y)
   Sets the y position. */
PHP_METHOD(php_wxRect, SetY)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::SetY\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::SetY call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long y0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&y0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::SetY((int) y0)\n\n");
				#endif

				((wxRect_php*)native_object)->SetY((int) y0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::SetY\n");
	}
}
/* }}} */

/* {{{ proto wxRect wxRect::Union(wxRect rect)
   Modifies the rectangle to contain the bounding box of this rectangle and the one passed in as parameter. */
PHP_METHOD(php_wxRect, Union)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::Union\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::Union call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* rect0 = 0;
	wxRect* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxRect*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::Union(*(wxRect*) object_pointer0_0) to return object reference\n\n");
				#endif

				wxRect_php* value_to_return1;
				value_to_return1 = (wxRect_php*) &((wxRect_php*)native_object)->Union(*(wxRect*) object_pointer0_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxRect_entry);
					((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxRect::Union at call with 1 argument(s)");
				}

				references->AddReference(rect0, "wxRect::Union at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::Union\n");
	}
}
/* }}} */

/* {{{ proto  wxRect::SetWidth(int width)
   Sets the width. */
PHP_METHOD(php_wxRect, SetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::SetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::SetWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::SetWidth((int) width0)\n\n");
				#endif

				((wxRect_php*)native_object)->SetWidth((int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::SetWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxRect::SetSize(wxSize s)
   Sets the size. */
PHP_METHOD(php_wxRect, SetSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::SetSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::SetSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* s0 = 0;
	wxSize* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&s0, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s0, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(s0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(s0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(s0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxSize*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 's' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(s0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 's' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::SetSize(*(wxSize*) object_pointer0_0)\n\n");
				#endif

				((wxRect_php*)native_object)->SetSize(*(wxSize*) object_pointer0_0);

				references->AddReference(s0, "wxRect::SetSize at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::SetSize\n");
	}
}
/* }}} */

/* {{{ proto  wxRect::SetHeight(int height)
   Sets the height. */
PHP_METHOD(php_wxRect, SetHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::SetHeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::SetHeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long height0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&height0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::SetHeight((int) height0)\n\n");
				#endif

				((wxRect_php*)native_object)->SetHeight((int) height0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::SetHeight\n");
	}
}
/* }}} */

/* {{{ proto  wxRect::Offset(int dx, int dy)
   Moves the rectangle by the specified offset. */
PHP_METHOD(php_wxRect, Offset)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::Offset\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::Offset call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long dx0;
	long dy0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* pt1 = 0;
	wxPoint* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&dx0, &dy0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dx0, &dy0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt1, php_wxPoint_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt1, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pt1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pt1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxPoint*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::Offset((wxCoord) dx0, (wxCoord) dy0)\n\n");
				#endif

				((wxRect_php*)native_object)->Offset((wxCoord) dx0, (wxCoord) dy0);


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::Offset(*(wxPoint*) object_pointer1_0)\n\n");
				#endif

				((wxRect_php*)native_object)->Offset(*(wxPoint*) object_pointer1_0);

				references->AddReference(pt1, "wxRect::Offset at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::Offset\n");
	}
}
/* }}} */

/* {{{ proto bool wxRect::IsEmpty()
   Returns true if this rectangle has a width or height less than or equal to 0 and false otherwise. */
PHP_METHOD(php_wxRect, IsEmpty)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::IsEmpty\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::IsEmpty call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRect::IsEmpty())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRect_php*)native_object)->IsEmpty());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::IsEmpty\n");
	}
}
/* }}} */

/* {{{ proto bool wxRect::Intersects(wxRect rect)
   Returns true if this rectangle has a non-empty intersection with the rectangle rect and false otherwise. */
PHP_METHOD(php_wxRect, Intersects)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::Intersects\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::Intersects call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* rect0 = 0;
	wxRect* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxRect*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRect::Intersects(*(wxRect*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRect_php*)native_object)->Intersects(*(wxRect*) object_pointer0_0));

				references->AddReference(rect0, "wxRect::Intersects at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::Intersects\n");
	}
}
/* }}} */

/* {{{ proto wxRect wxRect::Intersect(wxRect rect)
   Returns the overlapping portion of this rectangle and the one passed in as parameter. */
PHP_METHOD(php_wxRect, Intersect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::Intersect\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::Intersect call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* rect0 = 0;
	wxRect* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* rect1 = 0;
	wxRect* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxRect*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&rect1, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect1, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxRect*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::Intersect(*(wxRect*) object_pointer0_0) to return new object\n\n");
				#endif

				wxRect value_to_return1;
				value_to_return1 = ((wxRect_php*)native_object)->Intersect(*(wxRect*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) ptr;

				references->AddReference(rect0, "wxRect::Intersect at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::Intersect(*(wxRect*) object_pointer1_0) to return object reference\n\n");
				#endif

				wxRect_php* value_to_return1;
				value_to_return1 = (wxRect_php*) &((wxRect_php*)native_object)->Intersect(*(wxRect*) object_pointer1_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxRect_entry);
					((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxRect::Intersect at call with 1 argument(s)");
				}

				references->AddReference(rect1, "wxRect::Intersect at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::Intersect\n");
	}
}
/* }}} */

/* {{{ proto wxRect wxRect::Inflate(int dx, int dy)
   Increases the size of the rectangle. */
PHP_METHOD(php_wxRect, Inflate)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::Inflate\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::Inflate call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long dx0;
	long dy0;
	bool overload0_called = false;
	//Parameters for overload 1
	long diff1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* diff2 = 0;
	wxSize* object_pointer2_0 = 0;
	bool overload2_called = false;
	//Parameters for overload 3
	long dx3;
	long dy3;
	bool overload3_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&dx0, &dy0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dx0, &dy0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&diff1)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &diff1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&diff2, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &diff2, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(diff2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(diff2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(diff2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxSize*) argument_native_object;
					if (!object_pointer2_0 )
					{
						goto overload3;
					}
				}
				else if(Z_TYPE_P(diff2) != IS_NULL)
				{
					goto overload3;
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&dx3, &dy3)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dx3, &dy3 ) == SUCCESS)
		{
			overload3_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::Inflate((wxCoord) dx0, (wxCoord) dy0) to return new object\n\n");
				#endif

				wxRect value_to_return2;
				value_to_return2 = ((wxRect_php*)native_object)->Inflate((wxCoord) dx0, (wxCoord) dy0);
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) ptr;


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::Inflate((wxCoord) diff1) to return object reference\n\n");
				#endif

				wxRect_php* value_to_return1;
				value_to_return1 = (wxRect_php*) &((wxRect_php*)native_object)->Inflate((wxCoord) diff1);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxRect_entry);
					((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxRect::Inflate at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::Inflate(*(wxSize*) object_pointer2_0) to return object reference\n\n");
				#endif

				wxRect_php* value_to_return1;
				value_to_return1 = (wxRect_php*) &((wxRect_php*)native_object)->Inflate(*(wxSize*) object_pointer2_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxRect_entry);
					((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxRect::Inflate at call with 1 argument(s)");
				}

				references->AddReference(diff2, "wxRect::Inflate at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::Inflate((wxCoord) dx3, (wxCoord) dy3) to return object reference\n\n");
				#endif

				wxRect_php* value_to_return2;
				value_to_return2 = (wxRect_php*) &((wxRect_php*)native_object)->Inflate((wxCoord) dx3, (wxCoord) dy3);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxRect_entry);
					((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) value_to_return2;
				}

				if((void*)value_to_return2 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxRect::Inflate at call with 2 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::Inflate\n");
	}
}
/* }}} */

/* {{{ proto int wxRect::GetY()
   Gets the y member. */
PHP_METHOD(php_wxRect, GetY)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::GetY\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::GetY call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRect::GetY())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxRect_php*)native_object)->GetY());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::GetY\n");
	}
}
/* }}} */

/* {{{ proto int wxRect::GetX()
   Gets the x member. */
PHP_METHOD(php_wxRect, GetX)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::GetX\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::GetX call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRect::GetX())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxRect_php*)native_object)->GetX());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::GetX\n");
	}
}
/* }}} */

/* {{{ proto int wxRect::GetWidth()
   Gets the width member. */
PHP_METHOD(php_wxRect, GetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::GetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::GetWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRect::GetWidth())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxRect_php*)native_object)->GetWidth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::GetWidth\n");
	}
}
/* }}} */

/* {{{ proto wxPoint wxRect::GetTopRight()
   Gets the position of the top right corner. */
PHP_METHOD(php_wxRect, GetTopRight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::GetTopRight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::GetTopRight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::GetTopRight() to return new object\n\n");
				#endif

				wxPoint value_to_return0;
				value_to_return0 = ((wxRect_php*)native_object)->GetTopRight();
				void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxPoint));
				object_init_ex(return_value, php_wxPoint_entry);
				((zo_wxPoint*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPoint_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::GetTopRight\n");
	}
}
/* }}} */

/* {{{ proto wxPoint wxRect::GetTopLeft()
   Gets the position of the top left corner of the rectangle, same as GetPosition(). */
PHP_METHOD(php_wxRect, GetTopLeft)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::GetTopLeft\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::GetTopLeft call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::GetTopLeft() to return new object\n\n");
				#endif

				wxPoint value_to_return0;
				value_to_return0 = ((wxRect_php*)native_object)->GetTopLeft();
				void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxPoint));
				object_init_ex(return_value, php_wxPoint_entry);
				((zo_wxPoint*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPoint_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::GetTopLeft\n");
	}
}
/* }}} */

/* {{{ proto int wxRect::GetTop()
   Gets the top point of the rectangle (the same as GetY()). */
PHP_METHOD(php_wxRect, GetTop)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::GetTop\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::GetTop call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRect::GetTop())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxRect_php*)native_object)->GetTop());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::GetTop\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxRect::GetSize()
   Gets the size. */
PHP_METHOD(php_wxRect, GetSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::GetSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::GetSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::GetSize() to return new object\n\n");
				#endif

				wxSize value_to_return0;
				value_to_return0 = ((wxRect_php*)native_object)->GetSize();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				((zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxSize_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::GetSize\n");
	}
}
/* }}} */

/* {{{ proto int wxRect::GetRight()
   Gets the right point of the rectangle. */
PHP_METHOD(php_wxRect, GetRight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::GetRight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::GetRight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRect::GetRight())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxRect_php*)native_object)->GetRight());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::GetRight\n");
	}
}
/* }}} */

/* {{{ proto wxPoint wxRect::GetPosition()
   Gets the position. */
PHP_METHOD(php_wxRect, GetPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::GetPosition\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::GetPosition call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::GetPosition() to return new object\n\n");
				#endif

				wxPoint value_to_return0;
				value_to_return0 = ((wxRect_php*)native_object)->GetPosition();
				void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxPoint));
				object_init_ex(return_value, php_wxPoint_entry);
				((zo_wxPoint*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPoint_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::GetPosition\n");
	}
}
/* }}} */

/* {{{ proto wxRect wxRect::CenterIn(wxRect r, int dir)
   Returns the rectangle having the same size as this one but centered relatively to the given rectangle r. */
PHP_METHOD(php_wxRect, CenterIn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::CenterIn\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::CenterIn call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* r0 = 0;
	wxRect* object_pointer0_0 = 0;
	long dir0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&r0, php_wxRect_entry, &dir0)\n");
		#endif

		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &r0, php_wxRect_entry, &dir0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(r0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(r0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(r0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxRect*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'r' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(r0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'r' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::CenterIn(*(wxRect*) object_pointer0_0) to return new object\n\n");
				#endif

				wxRect value_to_return1;
				value_to_return1 = ((wxRect_php*)native_object)->CenterIn(*(wxRect*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) ptr;

				references->AddReference(r0, "wxRect::CenterIn at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::CenterIn(*(wxRect*) object_pointer0_0, (int) dir0) to return new object\n\n");
				#endif

				wxRect value_to_return2;
				value_to_return2 = ((wxRect_php*)native_object)->CenterIn(*(wxRect*) object_pointer0_0, (int) dir0);
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) ptr;

				references->AddReference(r0, "wxRect::CenterIn at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::CenterIn\n");
	}
}
/* }}} */

/* {{{ proto wxRect wxRect::CentreIn(wxRect r, int dir)
   Returns the rectangle having the same size as this one but centered relatively to the given rectangle r. */
PHP_METHOD(php_wxRect, CentreIn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::CentreIn\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::CentreIn call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* r0 = 0;
	wxRect* object_pointer0_0 = 0;
	long dir0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&r0, php_wxRect_entry, &dir0)\n");
		#endif

		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &r0, php_wxRect_entry, &dir0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(r0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(r0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(r0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxRect*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'r' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(r0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'r' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::CentreIn(*(wxRect*) object_pointer0_0) to return new object\n\n");
				#endif

				wxRect value_to_return1;
				value_to_return1 = ((wxRect_php*)native_object)->CentreIn(*(wxRect*) object_pointer0_0);
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) ptr;

				references->AddReference(r0, "wxRect::CentreIn at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::CentreIn(*(wxRect*) object_pointer0_0, (int) dir0) to return new object\n\n");
				#endif

				wxRect value_to_return2;
				value_to_return2 = ((wxRect_php*)native_object)->CentreIn(*(wxRect*) object_pointer0_0, (int) dir0);
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) ptr;

				references->AddReference(r0, "wxRect::CentreIn at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::CentreIn\n");
	}
}
/* }}} */

/* {{{ proto bool wxRect::Contains(int x, int y)
   Returns true if the given point is inside the rectangle (or on its boundary) and false otherwise. */
PHP_METHOD(php_wxRect, Contains)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::Contains\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::Contains call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* pt1 = 0;
	wxPoint* object_pointer1_0 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* rect2 = 0;
	wxRect* object_pointer2_0 = 0;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt1, php_wxPoint_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt1, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pt1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pt1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxPoint*) argument_native_object;
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(pt1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&rect2, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect2, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxRect*) argument_native_object;
					if (!object_pointer2_0 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRect::Contains((int) x0, (int) y0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRect_php*)native_object)->Contains((int) x0, (int) y0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRect::Contains(*(wxPoint*) object_pointer1_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRect_php*)native_object)->Contains(*(wxPoint*) object_pointer1_0));

				references->AddReference(pt1, "wxRect::Contains at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRect::Contains(*(wxRect*) object_pointer2_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRect_php*)native_object)->Contains(*(wxRect*) object_pointer2_0));

				references->AddReference(rect2, "wxRect::Contains at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::Contains\n");
	}
}
/* }}} */

/* {{{ proto wxRect wxRect::Deflate(int dx, int dy)
   Decrease the rectangle size. */
PHP_METHOD(php_wxRect, Deflate)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::Deflate\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::Deflate call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long dx0;
	long dy0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* diff1 = 0;
	wxSize* object_pointer1_0 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	long diff2;
	bool overload2_called = false;
	//Parameters for overload 3
	long dx3;
	long dy3;
	bool overload3_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&dx0, &dy0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dx0, &dy0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&diff1, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &diff1, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(diff1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(diff1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(diff1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxSize*) argument_native_object;
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(diff1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&diff2)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &diff2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&dx3, &dy3)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dx3, &dy3 ) == SUCCESS)
		{
			overload3_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::Deflate((wxCoord) dx0, (wxCoord) dy0) to return object reference\n\n");
				#endif

				wxRect_php* value_to_return2;
				value_to_return2 = (wxRect_php*) &((wxRect_php*)native_object)->Deflate((wxCoord) dx0, (wxCoord) dy0);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxRect_entry);
					((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) value_to_return2;
				}

				if((void*)value_to_return2 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxRect::Deflate at call with 2 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::Deflate(*(wxSize*) object_pointer1_0) to return object reference\n\n");
				#endif

				wxRect_php* value_to_return1;
				value_to_return1 = (wxRect_php*) &((wxRect_php*)native_object)->Deflate(*(wxSize*) object_pointer1_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxRect_entry);
					((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxRect::Deflate at call with 1 argument(s)");
				}

				references->AddReference(diff1, "wxRect::Deflate at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::Deflate((wxCoord) diff2) to return object reference\n\n");
				#endif

				wxRect_php* value_to_return1;
				value_to_return1 = (wxRect_php*) &((wxRect_php*)native_object)->Deflate((wxCoord) diff2);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxRect_entry);
					((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxRect::Deflate at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::Deflate((wxCoord) dx3, (wxCoord) dy3) to return new object\n\n");
				#endif

				wxRect value_to_return2;
				value_to_return2 = ((wxRect_php*)native_object)->Deflate((wxCoord) dx3, (wxCoord) dy3);
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::Deflate\n");
	}
}
/* }}} */

/* {{{ proto int wxRect::GetBottom()
   Gets the bottom point of the rectangle. */
PHP_METHOD(php_wxRect, GetBottom)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::GetBottom\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::GetBottom call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRect::GetBottom())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxRect_php*)native_object)->GetBottom());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::GetBottom\n");
	}
}
/* }}} */

/* {{{ proto wxPoint wxRect::GetBottomLeft()
   Gets the position of the bottom left corner. */
PHP_METHOD(php_wxRect, GetBottomLeft)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::GetBottomLeft\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::GetBottomLeft call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::GetBottomLeft() to return new object\n\n");
				#endif

				wxPoint value_to_return0;
				value_to_return0 = ((wxRect_php*)native_object)->GetBottomLeft();
				void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxPoint));
				object_init_ex(return_value, php_wxPoint_entry);
				((zo_wxPoint*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPoint_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::GetBottomLeft\n");
	}
}
/* }}} */

/* {{{ proto wxPoint wxRect::GetBottomRight()
   Gets the position of the bottom right corner. */
PHP_METHOD(php_wxRect, GetBottomRight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::GetBottomRight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::GetBottomRight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRect::GetBottomRight() to return new object\n\n");
				#endif

				wxPoint value_to_return0;
				value_to_return0 = ((wxRect_php*)native_object)->GetBottomRight();
				void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxPoint));
				object_init_ex(return_value, php_wxPoint_entry);
				((zo_wxPoint*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPoint_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::GetBottomRight\n");
	}
}
/* }}} */

/* {{{ proto int wxRect::GetHeight()
   Gets the height member. */
PHP_METHOD(php_wxRect, GetHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::GetHeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::GetHeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRect::GetHeight())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxRect_php*)native_object)->GetHeight());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::GetHeight\n");
	}
}
/* }}} */

/* {{{ proto int wxRect::GetLeft()
   Gets the left point of the rectangle (the same as GetX()). */
PHP_METHOD(php_wxRect, GetLeft)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRect::GetLeft\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRect* current_object;
	wxphp_object_type current_object_type;
	wxRect_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRect*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRect::GetLeft call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRECT_TYPE){
				references = &((wxRect_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRect::GetLeft())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxRect_php*)native_object)->GetLeft());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRect::GetLeft\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPoint_free(void *object TSRMLS_DC) 
{
    zo_wxPoint* custom_object = (zo_wxPoint*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPoint_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxPoint done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxPoint_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPoint_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxPoint* custom_object;
    custom_object = (zo_wxPoint*) emalloc(sizeof(zo_wxPoint));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPOINT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxPoint_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxPoint::wxPoint()
   Constructs a point. */
PHP_METHOD(php_wxPoint, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint* current_object;
	wxPoint_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	long x1;
	long y1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* pt2 = 0;
	wxRealPoint* object_pointer2_0 = 0;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x1, &y1)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x1, &y1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt2, php_wxRealPoint_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt2, php_wxRealPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRealPoint*) zend_object_store_get_object(pt2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRealPoint*) zend_object_store_get_object(pt2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxRealPoint*) argument_native_object;
					if (!object_pointer2_0 )
					{
						zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxPoint_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) x1, (int) y1)\n");
				#endif

				native_object = new wxPoint_php((int) x1, (int) y1);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxRealPoint*) object_pointer2_0)\n");
				#endif

				native_object = new wxPoint_php(*(wxRealPoint*) object_pointer2_0);

				native_object->references.Initialize();
				((wxPoint_php*) native_object)->references.AddReference(pt2, "wxPoint::wxPoint at call with 1 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxPoint*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxPoint::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

PHP_METHOD(php_wxPoint, __get)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint::__get\n");
	php_printf("===========================================\n");
	#endif
	
	int arguments_received = ZEND_NUM_ARGS();
	zo_wxPoint* current_object;
	wxPoint_php* native_object;
	
	char* name;
	int name_len;
	
	//Get native object of the php object that called the method
	if (getThis() != NULL) 
	{
		current_object = (zo_wxPoint*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint::wxPoint call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
		}
	}
	else
	{
		zend_error(E_ERROR, "Could not process __get call as static\n");
	}
	
	char parse_parameters_string[] = "s";
	
	if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name, &name_len ) == FAILURE)
	{
		RETVAL_NULL();
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Property to get: %s\n", name);
	php_printf("===========================================\n\n");
	#endif
	
	if(false){}
	else if(strcmp("x", name) == 0)
	{
		RETVAL_LONG(*((int*) native_object->properties[0]));
	}
	else if(strcmp("y", name) == 0)
	{
		RETVAL_LONG(*((int*) native_object->properties[1]));
	}
	else
	{
		RETVAL_NULL();
	}
}
/* {{{ proto bool wxPoint::IsFullySpecified()
   Returns true if neither of the point components is equal to wxDefaultCoord. */
PHP_METHOD(php_wxPoint, IsFullySpecified)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint::IsFullySpecified\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint* current_object;
	wxphp_object_type current_object_type;
	wxPoint_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint::IsFullySpecified call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT_TYPE){
				references = &((wxPoint_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPoint::IsFullySpecified())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPoint_php*)native_object)->IsFullySpecified());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint::IsFullySpecified\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxSize_free(void *object TSRMLS_DC) 
{
    zo_wxSize* custom_object = (zo_wxSize*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxSize_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxSize done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxSize_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxSize_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxSize* custom_object;
    custom_object = (zo_wxSize*) emalloc(sizeof(zo_wxSize));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXSIZE_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxSize_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxSize::wxSize()
   Initializes this size object with zero width and height. */
PHP_METHOD(php_wxSize, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSize::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxSize* current_object;
	wxSize_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	long width1;
	long height1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&width1, &height1)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width1, &height1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxSize_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width1, (int) height1)\n");
				#endif

				native_object = new wxSize_php((int) width1, (int) height1);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxSize*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxSize::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxSize::SetWidth(int width)
   Sets the width. */
PHP_METHOD(php_wxSize, SetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSize::SetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxSize* current_object;
	wxphp_object_type current_object_type;
	wxSize_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxSize*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxSize::SetWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXSIZE_TYPE){
				references = &((wxSize_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSize::SetWidth((int) width0)\n\n");
				#endif

				((wxSize_php*)native_object)->SetWidth((int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSize::SetWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxSize::SetHeight(int height)
   Sets the height. */
PHP_METHOD(php_wxSize, SetHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSize::SetHeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxSize* current_object;
	wxphp_object_type current_object_type;
	wxSize_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxSize*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxSize::SetHeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXSIZE_TYPE){
				references = &((wxSize_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long height0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&height0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSize::SetHeight((int) height0)\n\n");
				#endif

				((wxSize_php*)native_object)->SetHeight((int) height0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSize::SetHeight\n");
	}
}
/* }}} */

/* {{{ proto  wxSize::SetDefaults(wxSize sizeDefault)
   Combine this size object with another one replacing the default (i.e. */
PHP_METHOD(php_wxSize, SetDefaults)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSize::SetDefaults\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxSize* current_object;
	wxphp_object_type current_object_type;
	wxSize_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxSize*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxSize::SetDefaults call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXSIZE_TYPE){
				references = &((wxSize_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* sizeDefault0 = 0;
	wxSize* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&sizeDefault0, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &sizeDefault0, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(sizeDefault0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(sizeDefault0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(sizeDefault0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxSize*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'sizeDefault' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(sizeDefault0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'sizeDefault' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSize::SetDefaults(*(wxSize*) object_pointer0_0)\n\n");
				#endif

				((wxSize_php*)native_object)->SetDefaults(*(wxSize*) object_pointer0_0);

				references->AddReference(sizeDefault0, "wxSize::SetDefaults at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSize::SetDefaults\n");
	}
}
/* }}} */

/* {{{ proto  wxSize::Set(int width, int height)
   Sets the width and height members. */
PHP_METHOD(php_wxSize, Set)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSize::Set\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxSize* current_object;
	wxphp_object_type current_object_type;
	wxSize_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxSize*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxSize::Set call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXSIZE_TYPE){
				references = &((wxSize_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	long height0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&width0, &height0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSize::Set((int) width0, (int) height0)\n\n");
				#endif

				((wxSize_php*)native_object)->Set((int) width0, (int) height0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSize::Set\n");
	}
}
/* }}} */

/* {{{ proto int wxSize::GetHeight()
   Gets the height member. */
PHP_METHOD(php_wxSize, GetHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSize::GetHeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxSize* current_object;
	wxphp_object_type current_object_type;
	wxSize_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxSize*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxSize::GetHeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXSIZE_TYPE){
				references = &((wxSize_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSize::GetHeight())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxSize_php*)native_object)->GetHeight());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSize::GetHeight\n");
	}
}
/* }}} */

/* {{{ proto int wxSize::GetWidth()
   Gets the width member. */
PHP_METHOD(php_wxSize, GetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSize::GetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxSize* current_object;
	wxphp_object_type current_object_type;
	wxSize_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxSize*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxSize::GetWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXSIZE_TYPE){
				references = &((wxSize_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxSize::GetWidth())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxSize_php*)native_object)->GetWidth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSize::GetWidth\n");
	}
}
/* }}} */

/* {{{ proto bool wxSize::IsFullySpecified()
   Returns true if neither of the size object components is equal to -1, which is used as default for the size values in wxWidgets (hence the predefined wxDefaultSize has both of its components equal to -1). */
PHP_METHOD(php_wxSize, IsFullySpecified)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSize::IsFullySpecified\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxSize* current_object;
	wxphp_object_type current_object_type;
	wxSize_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxSize*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxSize::IsFullySpecified call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXSIZE_TYPE){
				references = &((wxSize_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxSize::IsFullySpecified())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxSize_php*)native_object)->IsFullySpecified());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSize::IsFullySpecified\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxSize::Scale(float xscale, float yscale)
   Scales the dimensions of this object by the given factors. */
PHP_METHOD(php_wxSize, Scale)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSize::Scale\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxSize* current_object;
	wxphp_object_type current_object_type;
	wxSize_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxSize*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxSize::Scale call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXSIZE_TYPE){
				references = &((wxSize_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	double xscale0;
	double yscale0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'dd' (&xscale0, &yscale0)\n");
		#endif

		char parse_parameters_string[] = "dd";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &xscale0, &yscale0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSize::Scale(xscale0, yscale0) to return object reference\n\n");
				#endif

				wxSize_php* value_to_return2;
				value_to_return2 = (wxSize_php*) &((wxSize_php*)native_object)->Scale(xscale0, yscale0);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxSize_entry);
					((zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxSize_php*) value_to_return2;
				}

				if((void*)value_to_return2 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxSize::Scale at call with 2 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSize::Scale\n");
	}
}
/* }}} */

/* {{{ proto  wxSize::DecTo(wxSize size)
   Decrements this object so that both of its dimensions are not greater than the corresponding dimensions of the size. */
PHP_METHOD(php_wxSize, DecTo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSize::DecTo\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxSize* current_object;
	wxphp_object_type current_object_type;
	wxSize_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxSize*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxSize::DecTo call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXSIZE_TYPE){
				references = &((wxSize_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* size0 = 0;
	wxSize* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size0, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size0, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxSize*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSize::DecTo(*(wxSize*) object_pointer0_0)\n\n");
				#endif

				((wxSize_php*)native_object)->DecTo(*(wxSize*) object_pointer0_0);

				references->AddReference(size0, "wxSize::DecTo at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSize::DecTo\n");
	}
}
/* }}} */

/* {{{ proto  wxSize::IncTo(wxSize size)
   Increments this object so that both of its dimensions are not less than the corresponding dimensions of the size. */
PHP_METHOD(php_wxSize, IncTo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxSize::IncTo\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxSize* current_object;
	wxphp_object_type current_object_type;
	wxSize_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxSize*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxSize::IncTo call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXSIZE_TYPE){
				references = &((wxSize_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* size0 = 0;
	wxSize* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size0, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size0, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxSize*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxSize::IncTo(*(wxSize*) object_pointer0_0)\n\n");
				#endif

				((wxSize_php*)native_object)->IncTo(*(wxSize*) object_pointer0_0);

				references->AddReference(size0, "wxSize::IncTo at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxSize::IncTo\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxListItemAttr_free(void *object TSRMLS_DC) 
{
    zo_wxListItemAttr* custom_object = (zo_wxListItemAttr*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxListItemAttr_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxListItemAttr done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxListItemAttr_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxListItemAttr_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxListItemAttr* custom_object;
    custom_object = (zo_wxListItemAttr*) emalloc(sizeof(zo_wxListItemAttr));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXLISTITEMATTR_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxListItemAttr_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto wxColour wxListItemAttr::GetBackgroundColour()
   Returns the currently set background color. */
PHP_METHOD(php_wxListItemAttr, GetBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItemAttr::GetBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItemAttr* current_object;
	wxphp_object_type current_object_type;
	wxListItemAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItemAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItemAttr::GetBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEMATTR_TYPE){
				references = &((wxListItemAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItemAttr::GetBackgroundColour() to return object reference\n\n");
				#endif

				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxListItemAttr_php*)native_object)->GetBackgroundColour();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxListItemAttr::GetBackgroundColour at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItemAttr::GetBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto  wxListItemAttr::wxListItemAttr()
   Default Constructor. */
PHP_METHOD(php_wxListItemAttr, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItemAttr::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItemAttr* current_object;
	wxListItemAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* colText1 = 0;
	wxColour* object_pointer1_0 = 0;
	zval* colBack1 = 0;
	wxColour* object_pointer1_1 = 0;
	zval* font1 = 0;
	wxFont* object_pointer1_2 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OOO' (&colText1, php_wxColour_entry, &colBack1, php_wxColour_entry, &font1, php_wxFont_entry)\n");
		#endif

		char parse_parameters_string[] = "OOO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colText1, php_wxColour_entry, &colBack1, php_wxColour_entry, &font1, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colText1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colText1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colText1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxColour*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'colText' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colText1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colText' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(colBack1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colBack1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colBack1 TSRMLS_CC))->native_object;
					object_pointer1_1 = (wxColour*) argument_native_object;
					if (!object_pointer1_1 )
					{
						zend_error(E_ERROR, "Parameter 'colBack' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colBack1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colBack' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(font1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font1 TSRMLS_CC))->native_object;
					object_pointer1_2 = (wxFont*) argument_native_object;
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxListItemAttr_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1, *(wxFont*) object_pointer1_2)\n");
				#endif

				native_object = new wxListItemAttr_php(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1, *(wxFont*) object_pointer1_2);

				native_object->references.Initialize();
				((wxListItemAttr_php*) native_object)->references.AddReference(colText1, "wxListItemAttr::wxListItemAttr at call with 3 argument(s)");
				((wxListItemAttr_php*) native_object)->references.AddReference(colBack1, "wxListItemAttr::wxListItemAttr at call with 3 argument(s)");
				((wxListItemAttr_php*) native_object)->references.AddReference(font1, "wxListItemAttr::wxListItemAttr at call with 3 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxListItemAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxListItemAttr::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxListItemAttr::SetTextColour(wxColour colour)
   Sets a new text color. */
PHP_METHOD(php_wxListItemAttr, SetTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItemAttr::SetTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItemAttr* current_object;
	wxphp_object_type current_object_type;
	wxListItemAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItemAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItemAttr::SetTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEMATTR_TYPE){
				references = &((wxListItemAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colour0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItemAttr::SetTextColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxListItemAttr_php*)native_object)->SetTextColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colour0, "wxListItemAttr::SetTextColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItemAttr::SetTextColour\n");
	}
}
/* }}} */

/* {{{ proto  wxListItemAttr::SetFont(wxFont font)
   Sets a new font. */
PHP_METHOD(php_wxListItemAttr, SetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItemAttr::SetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItemAttr* current_object;
	wxphp_object_type current_object_type;
	wxListItemAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItemAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItemAttr::SetFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEMATTR_TYPE){
				references = &((wxListItemAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* font0 = 0;
	wxFont* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxFont*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItemAttr::SetFont(*(wxFont*) object_pointer0_0)\n\n");
				#endif

				((wxListItemAttr_php*)native_object)->SetFont(*(wxFont*) object_pointer0_0);

				references->AddReference(font0, "wxListItemAttr::SetFont at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItemAttr::SetFont\n");
	}
}
/* }}} */

/* {{{ proto  wxListItemAttr::SetBackgroundColour(wxColour colour)
   Sets a new background color. */
PHP_METHOD(php_wxListItemAttr, SetBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItemAttr::SetBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItemAttr* current_object;
	wxphp_object_type current_object_type;
	wxListItemAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItemAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItemAttr::SetBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEMATTR_TYPE){
				references = &((wxListItemAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colour0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItemAttr::SetBackgroundColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxListItemAttr_php*)native_object)->SetBackgroundColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colour0, "wxListItemAttr::SetBackgroundColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItemAttr::SetBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto bool wxListItemAttr::HasTextColour()
   Returns true if the currently set text color is valid. */
PHP_METHOD(php_wxListItemAttr, HasTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItemAttr::HasTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItemAttr* current_object;
	wxphp_object_type current_object_type;
	wxListItemAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItemAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItemAttr::HasTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEMATTR_TYPE){
				references = &((wxListItemAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListItemAttr::HasTextColour())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxListItemAttr_php*)native_object)->HasTextColour());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItemAttr::HasTextColour\n");
	}
}
/* }}} */

/* {{{ proto bool wxListItemAttr::HasFont()
   Returns true if the currently set font is valid. */
PHP_METHOD(php_wxListItemAttr, HasFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItemAttr::HasFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItemAttr* current_object;
	wxphp_object_type current_object_type;
	wxListItemAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItemAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItemAttr::HasFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEMATTR_TYPE){
				references = &((wxListItemAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListItemAttr::HasFont())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxListItemAttr_php*)native_object)->HasFont());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItemAttr::HasFont\n");
	}
}
/* }}} */

/* {{{ proto bool wxListItemAttr::HasBackgroundColour()
   Returns true if the currently set background color is valid. */
PHP_METHOD(php_wxListItemAttr, HasBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItemAttr::HasBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItemAttr* current_object;
	wxphp_object_type current_object_type;
	wxListItemAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItemAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItemAttr::HasBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEMATTR_TYPE){
				references = &((wxListItemAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxListItemAttr::HasBackgroundColour())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxListItemAttr_php*)native_object)->HasBackgroundColour());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItemAttr::HasBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxListItemAttr::GetTextColour()
   Returns the currently set text color. */
PHP_METHOD(php_wxListItemAttr, GetTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItemAttr::GetTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItemAttr* current_object;
	wxphp_object_type current_object_type;
	wxListItemAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItemAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItemAttr::GetTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEMATTR_TYPE){
				references = &((wxListItemAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItemAttr::GetTextColour() to return object reference\n\n");
				#endif

				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxListItemAttr_php*)native_object)->GetTextColour();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxListItemAttr::GetTextColour at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItemAttr::GetTextColour\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxListItemAttr::GetFont()
   Returns the currently set font. */
PHP_METHOD(php_wxListItemAttr, GetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItemAttr::GetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItemAttr* current_object;
	wxphp_object_type current_object_type;
	wxListItemAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItemAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItemAttr::GetFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEMATTR_TYPE){
				references = &((wxListItemAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItemAttr::GetFont() to return object reference\n\n");
				#endif

				wxFont_php* value_to_return0;
				value_to_return0 = (wxFont_php*) &((wxListItemAttr_php*)native_object)->GetFont();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxListItemAttr::GetFont at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItemAttr::GetFont\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxListItem_free(void *object TSRMLS_DC) 
{
    zo_wxListItem* custom_object = (zo_wxListItem*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxListItem_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxListItem done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxListItem_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxListItem_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxListItem* custom_object;
    custom_object = (zo_wxListItem*) emalloc(sizeof(zo_wxListItem));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXLISTITEM_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxListItem_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxListItem::Clear()
   Resets the item state to the default. */
PHP_METHOD(php_wxListItem, Clear)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::Clear\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::Clear call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::Clear()\n\n");
				#endif

				((wxListItem_php*)native_object)->Clear();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::Clear\n");
	}
}
/* }}} */

/* {{{ proto  wxListItem::wxListItem()
   Constructor. */
PHP_METHOD(php_wxListItem, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxListItem_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxListItem::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxListItem::SetWidth(int width)
   Meaningful only for column headers in report mode. */
PHP_METHOD(php_wxListItem, SetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::SetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::SetWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::SetWidth((int) width0)\n\n");
				#endif

				((wxListItem_php*)native_object)->SetWidth((int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::SetWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxListItem::SetTextColour(wxColour colText)
   Sets the text colour for the item. */
PHP_METHOD(php_wxListItem, SetTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::SetTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::SetTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colText0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colText0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colText0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colText0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colText0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colText0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colText' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colText0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colText' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::SetTextColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxListItem_php*)native_object)->SetTextColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colText0, "wxListItem::SetTextColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::SetTextColour\n");
	}
}
/* }}} */

/* {{{ proto  wxListItem::SetText(string text)
   Sets the text label for the item. */
PHP_METHOD(php_wxListItem, SetText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::SetText\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::SetText call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&text0, &text_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::SetText(wxString(text0, wxConvUTF8))\n\n");
				#endif

				((wxListItem_php*)native_object)->SetText(wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::SetText\n");
	}
}
/* }}} */

/* {{{ proto  wxListItem::SetStateMask(int stateMask)
   Sets the bitmask that is used to determine which of the state flags are to be set. */
PHP_METHOD(php_wxListItem, SetStateMask)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::SetStateMask\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::SetStateMask call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long stateMask0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&stateMask0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stateMask0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::SetStateMask((long) stateMask0)\n\n");
				#endif

				((wxListItem_php*)native_object)->SetStateMask((long) stateMask0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::SetStateMask\n");
	}
}
/* }}} */

/* {{{ proto  wxListItem::SetState(int state)
   Sets the item state flags (note that the valid state flags are influenced by the value of the state mask, see wxListItem::SetStateMask). */
PHP_METHOD(php_wxListItem, SetState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::SetState\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::SetState call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&state0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::SetState((long) state0)\n\n");
				#endif

				((wxListItem_php*)native_object)->SetState((long) state0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::SetState\n");
	}
}
/* }}} */

/* {{{ proto  wxListItem::SetMask(int mask)
   Sets the mask of valid fields. */
PHP_METHOD(php_wxListItem, SetMask)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::SetMask\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::SetMask call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long mask0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&mask0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &mask0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::SetMask((long) mask0)\n\n");
				#endif

				((wxListItem_php*)native_object)->SetMask((long) mask0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::SetMask\n");
	}
}
/* }}} */

/* {{{ proto  wxListItem::SetImage(int image)
   Sets the zero-based index of the image associated with the item into the image list. */
PHP_METHOD(php_wxListItem, SetImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::SetImage\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::SetImage call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long image0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&image0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &image0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::SetImage((int) image0)\n\n");
				#endif

				((wxListItem_php*)native_object)->SetImage((int) image0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::SetImage\n");
	}
}
/* }}} */

/* {{{ proto  wxListItem::SetId(int id)
   Sets the zero-based item position. */
PHP_METHOD(php_wxListItem, SetId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::SetId\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::SetId call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::SetId((long) id0)\n\n");
				#endif

				((wxListItem_php*)native_object)->SetId((long) id0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::SetId\n");
	}
}
/* }}} */

/* {{{ proto  wxListItem::SetFont(wxFont font)
   Sets the font for the item. */
PHP_METHOD(php_wxListItem, SetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::SetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::SetFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* font0 = 0;
	wxFont* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxFont*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::SetFont(*(wxFont*) object_pointer0_0)\n\n");
				#endif

				((wxListItem_php*)native_object)->SetFont(*(wxFont*) object_pointer0_0);

				references->AddReference(font0, "wxListItem::SetFont at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::SetFont\n");
	}
}
/* }}} */

/* {{{ proto  wxListItem::SetData(int data)
   Sets client data for the item. */
PHP_METHOD(php_wxListItem, SetData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::SetData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::SetData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long data0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&data0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &data0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::SetData((long) data0)\n\n");
				#endif

				((wxListItem_php*)native_object)->SetData((long) data0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::SetData\n");
	}
}
/* }}} */

/* {{{ proto  wxListItem::SetColumn(int col)
   Sets the zero-based column. */
PHP_METHOD(php_wxListItem, SetColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::SetColumn\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::SetColumn call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::SetColumn((int) col0)\n\n");
				#endif

				((wxListItem_php*)native_object)->SetColumn((int) col0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::SetColumn\n");
	}
}
/* }}} */

/* {{{ proto  wxListItem::SetBackgroundColour(wxColour colBack)
   Sets the background colour for the item. */
PHP_METHOD(php_wxListItem, SetBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::SetBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::SetBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colBack0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colBack0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colBack0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colBack0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colBack0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colBack0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colBack' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colBack0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colBack' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::SetBackgroundColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxListItem_php*)native_object)->SetBackgroundColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colBack0, "wxListItem::SetBackgroundColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::SetBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto  wxListItem::SetAlign(wxListColumnFormat align)
   Sets the alignment for the item. */
PHP_METHOD(php_wxListItem, SetAlign)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::SetAlign\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::SetAlign call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long align0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&align0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &align0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::SetAlign((wxListColumnFormat) align0)\n\n");
				#endif

				((wxListItem_php*)native_object)->SetAlign((wxListColumnFormat) align0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::SetAlign\n");
	}
}
/* }}} */

/* {{{ proto int wxListItem::GetWidth()
   Meaningful only for column headers in report mode. */
PHP_METHOD(php_wxListItem, GetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::GetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::GetWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListItem::GetWidth())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxListItem_php*)native_object)->GetWidth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::GetWidth\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxListItem::GetTextColour()
   Returns the text colour. */
PHP_METHOD(php_wxListItem, GetTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::GetTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::GetTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::GetTextColour() to return new object\n\n");
				#endif

				wxColour value_to_return0;
				value_to_return0 = ((wxListItem_php*)native_object)->GetTextColour();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::GetTextColour\n");
	}
}
/* }}} */

/* {{{ proto string wxListItem::GetText()
   Returns the label/header text. */
PHP_METHOD(php_wxListItem, GetText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::GetText\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::GetText call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxListItem::GetText().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxListItem_php*)native_object)->GetText();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::GetText\n");
	}
}
/* }}} */

/* {{{ proto int wxListItem::GetState()
   Returns a bit field representing the state of the item. */
PHP_METHOD(php_wxListItem, GetState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::GetState\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::GetState call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListItem::GetState())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxListItem_php*)native_object)->GetState());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::GetState\n");
	}
}
/* }}} */

/* {{{ proto int wxListItem::GetMask()
   Returns a bit mask indicating which fields of the structure are valid. */
PHP_METHOD(php_wxListItem, GetMask)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::GetMask\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::GetMask call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListItem::GetMask())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxListItem_php*)native_object)->GetMask());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::GetMask\n");
	}
}
/* }}} */

/* {{{ proto int wxListItem::GetImage()
   Returns the zero-based index of the image associated with the item into the image list. */
PHP_METHOD(php_wxListItem, GetImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::GetImage\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::GetImage call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListItem::GetImage())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxListItem_php*)native_object)->GetImage());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::GetImage\n");
	}
}
/* }}} */

/* {{{ proto int wxListItem::GetId()
   Returns the zero-based item position. */
PHP_METHOD(php_wxListItem, GetId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::GetId\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::GetId call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListItem::GetId())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxListItem_php*)native_object)->GetId());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::GetId\n");
	}
}
/* }}} */

/* {{{ proto wxListColumnFormat wxListItem::GetAlign()
   Returns the alignment for this item. */
PHP_METHOD(php_wxListItem, GetAlign)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::GetAlign\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::GetAlign call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListItem::GetAlign())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxListItem_php*)native_object)->GetAlign());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::GetAlign\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxListItem::GetBackgroundColour()
   Returns the background colour for this item. */
PHP_METHOD(php_wxListItem, GetBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::GetBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::GetBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::GetBackgroundColour() to return new object\n\n");
				#endif

				wxColour value_to_return0;
				value_to_return0 = ((wxListItem_php*)native_object)->GetBackgroundColour();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::GetBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto int wxListItem::GetColumn()
   Returns the zero-based column; meaningful only in report mode. */
PHP_METHOD(php_wxListItem, GetColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::GetColumn\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::GetColumn call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxListItem::GetColumn())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxListItem_php*)native_object)->GetColumn());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::GetColumn\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxListItem::GetFont()
   Returns the font used to display the item. */
PHP_METHOD(php_wxListItem, GetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxListItem::GetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxListItem* current_object;
	wxphp_object_type current_object_type;
	wxListItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxListItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxListItem::GetFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLISTITEM_TYPE){
				references = &((wxListItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxListItem::GetFont() to return new object\n\n");
				#endif

				wxFont_php *value_to_return0;
				value_to_return0 = new wxFont_php(((wxListItem_php *) native_object)->GetFont());
				object_init_ex(return_value, php_wxFont_entry);
				zo_wxFont* zo0 = (zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = value_to_return0;
				zo0->is_user_initialized = 1;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxListItem::GetFont\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFileType_free(void *object TSRMLS_DC) 
{
    zo_wxFileType* custom_object = (zo_wxFileType*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFileType_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxFileType done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxFileType_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFileType_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxFileType* custom_object;
    custom_object = (zo_wxFileType*) emalloc(sizeof(zo_wxFileType));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFILETYPE_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxFileType_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto bool wxFileType::GetDescription(string &desc)
   If the function returns true, the string pointed to by desc is filled with a brief description for this file type: for example, "text document" for the "text/plain" MIME type. */
PHP_METHOD(php_wxFileType, GetDescription)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileType::GetDescription\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileType* current_object;
	wxphp_object_type current_object_type;
	wxFileType_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileType*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileType::GetDescription call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILETYPE_TYPE){
				references = &((wxFileType_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* desc0;
	long desc_len0;
	zval* desc0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&desc0, &desc_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &desc0, &desc_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &desc0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				wxString string_arg0_0 = wxString(desc0, wxConvUTF8);
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileType::GetDescription(&string_arg0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxFileType_php*)native_object)->GetDescription(&string_arg0_0));

				char* temp_string0_0;
				temp_string0_0 = (char*)malloc(sizeof(wxChar)*(string_arg0_0.size()+1));
				strcpy (temp_string0_0, (const char *) string_arg0_0.char_str() );
				ZVAL_STRING(desc0_ref, (char*) temp_string0_0, 1);
				free(temp_string0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileType::GetDescription\n");
	}
}
/* }}} */

/* {{{ proto bool wxFileType::GetExtensions(array &extensions)
   If the function returns true, the array extensions is filled with all extensions associated with this file type: for example, it may contain the following two elements for the MIME type "text/html" (notice the absence of the leading dot): "html" and "htm". */
PHP_METHOD(php_wxFileType, GetExtensions)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileType::GetExtensions\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileType* current_object;
	wxphp_object_type current_object_type;
	wxFileType_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileType*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileType::GetExtensions call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILETYPE_TYPE){
				references = &((wxFileType_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* extensions0 = 0;
	zval* extensions0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&extensions0)\n");
		#endif

		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &extensions0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(extensions0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileType::GetExtensions(strings_array0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxFileType_php*)native_object)->GetExtensions(strings_array0_0));

				char* temp_string0_0;
				array_init(extensions0);
				for(size_t i=0; i<strings_array0_0.GetCount(); i++)
				{
					temp_string0_0 = (char*)malloc(sizeof(wxChar)*(strings_array0_0[i].size()+1));
					strcpy (temp_string0_0, (const char *) strings_array0_0[i].char_str() );
					add_next_index_string(extensions0, (char*) temp_string0_0, 1);
					free(temp_string0_0);

				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileType::GetExtensions\n");
	}
}
/* }}} */

/* {{{ proto bool wxFileType::GetMimeType(string &mimeType)
   If the function returns true, the string pointed to by mimeType is filled with full MIME type specification for this file type: for example, "text/plain". */
PHP_METHOD(php_wxFileType, GetMimeType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileType::GetMimeType\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileType* current_object;
	wxphp_object_type current_object_type;
	wxFileType_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileType*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileType::GetMimeType call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILETYPE_TYPE){
				references = &((wxFileType_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* mimeType0;
	long mimeType_len0;
	zval* mimeType0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&mimeType0, &mimeType_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &mimeType0, &mimeType_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &mimeType0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				wxString string_arg0_0 = wxString(mimeType0, wxConvUTF8);
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileType::GetMimeType(&string_arg0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxFileType_php*)native_object)->GetMimeType(&string_arg0_0));

				char* temp_string0_0;
				temp_string0_0 = (char*)malloc(sizeof(wxChar)*(string_arg0_0.size()+1));
				strcpy (temp_string0_0, (const char *) string_arg0_0.char_str() );
				ZVAL_STRING(mimeType0_ref, (char*) temp_string0_0, 1);
				free(temp_string0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileType::GetMimeType\n");
	}
}
/* }}} */

/* {{{ proto bool wxFileType::GetMimeTypes(array &mimeTypes)
   Same as GetMimeType() but returns array of MIME types. */
PHP_METHOD(php_wxFileType, GetMimeTypes)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileType::GetMimeTypes\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileType* current_object;
	wxphp_object_type current_object_type;
	wxFileType_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileType*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileType::GetMimeTypes call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILETYPE_TYPE){
				references = &((wxFileType_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* mimeTypes0 = 0;
	zval* mimeTypes0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&mimeTypes0)\n");
		#endif

		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &mimeTypes0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(mimeTypes0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFileType::GetMimeTypes(strings_array0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxFileType_php*)native_object)->GetMimeTypes(strings_array0_0));

				char* temp_string0_0;
				array_init(mimeTypes0);
				for(size_t i=0; i<strings_array0_0.GetCount(); i++)
				{
					temp_string0_0 = (char*)malloc(sizeof(wxChar)*(strings_array0_0[i].size()+1));
					strcpy (temp_string0_0, (const char *) strings_array0_0[i].char_str() );
					add_next_index_string(mimeTypes0, (char*) temp_string0_0, 1);
					free(temp_string0_0);

				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileType::GetMimeTypes\n");
	}
}
/* }}} */

/* {{{ proto string wxFileType::GetOpenCommand(string filename)
   With the first version of this method, if the true is returned, the string pointed to by command is filled with the command which must be executed (see wxExecute()) in order to open the file of the given type. */
PHP_METHOD(php_wxFileType, GetOpenCommand)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileType::GetOpenCommand\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileType* current_object;
	wxphp_object_type current_object_type;
	wxFileType_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileType*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileType::GetOpenCommand call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILETYPE_TYPE){
				references = &((wxFileType_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* filename0;
	long filename_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&filename0, &filename_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filename0, &filename_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileType::GetOpenCommand(wxString(filename0, wxConvUTF8)).fn_str(), 1)\n\n");
				#endif

				wxString value_to_return1;
				value_to_return1 = ((wxFileType_php*)native_object)->GetOpenCommand(wxString(filename0, wxConvUTF8));
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileType::GetOpenCommand\n");
	}
}
/* }}} */

/* {{{ proto  wxFileType::wxFileType(wxFileTypeInfo ftInfo)
   Copy ctor. */
PHP_METHOD(php_wxFileType, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileType::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileType* current_object;
	wxFileType_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* ftInfo0 = 0;
	wxFileTypeInfo* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&ftInfo0, php_wxFileTypeInfo_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &ftInfo0, php_wxFileTypeInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(ftInfo0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFileTypeInfo*) zend_object_store_get_object(ftInfo0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFileTypeInfo*) zend_object_store_get_object(ftInfo0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxFileTypeInfo*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'ftInfo' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(ftInfo0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'ftInfo' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxFileTypeInfo*) object_pointer0_0)\n");
				#endif

				native_object = new wxFileType_php(*(wxFileTypeInfo*) object_pointer0_0);

				native_object->references.Initialize();
				((wxFileType_php*) native_object)->references.AddReference(ftInfo0, "wxFileType::wxFileType at call with 1 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxFileType*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxFileType::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPosition_free(void *object TSRMLS_DC) 
{
    zo_wxPosition* custom_object = (zo_wxPosition*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPosition_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxPosition done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxPosition_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPosition_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxPosition* custom_object;
    custom_object = (zo_wxPosition*) emalloc(sizeof(zo_wxPosition));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPOSITION_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxPosition_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto int wxPosition::GetCol()
   A synonym for GetColumn(). */
PHP_METHOD(php_wxPosition, GetCol)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPosition::GetCol\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPosition* current_object;
	wxphp_object_type current_object_type;
	wxPosition_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPosition*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPosition::GetCol call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOSITION_TYPE){
				references = &((wxPosition_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPosition::GetCol())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPosition_php*)native_object)->GetCol());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPosition::GetCol\n");
	}
}
/* }}} */

/* {{{ proto int wxPosition::GetColumn()
   Get the current row value. */
PHP_METHOD(php_wxPosition, GetColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPosition::GetColumn\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPosition* current_object;
	wxphp_object_type current_object_type;
	wxPosition_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPosition*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPosition::GetColumn call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOSITION_TYPE){
				references = &((wxPosition_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPosition::GetColumn())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPosition_php*)native_object)->GetColumn());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPosition::GetColumn\n");
	}
}
/* }}} */

/* {{{ proto int wxPosition::GetRow()
   Get the current row value. */
PHP_METHOD(php_wxPosition, GetRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPosition::GetRow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPosition* current_object;
	wxphp_object_type current_object_type;
	wxPosition_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPosition*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPosition::GetRow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOSITION_TYPE){
				references = &((wxPosition_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPosition::GetRow())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPosition_php*)native_object)->GetRow());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPosition::GetRow\n");
	}
}
/* }}} */

/* {{{ proto  wxPosition::SetCol(int column)
   A synonym for SetColumn(). */
PHP_METHOD(php_wxPosition, SetCol)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPosition::SetCol\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPosition* current_object;
	wxphp_object_type current_object_type;
	wxPosition_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPosition*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPosition::SetCol call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOSITION_TYPE){
				references = &((wxPosition_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long column0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&column0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &column0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPosition::SetCol((int) column0)\n\n");
				#endif

				((wxPosition_php*)native_object)->SetCol((int) column0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPosition::SetCol\n");
	}
}
/* }}} */

/* {{{ proto  wxPosition::SetColumn(int column)
   Set a new column value. */
PHP_METHOD(php_wxPosition, SetColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPosition::SetColumn\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPosition* current_object;
	wxphp_object_type current_object_type;
	wxPosition_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPosition*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPosition::SetColumn call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOSITION_TYPE){
				references = &((wxPosition_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long column0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&column0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &column0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPosition::SetColumn((int) column0)\n\n");
				#endif

				((wxPosition_php*)native_object)->SetColumn((int) column0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPosition::SetColumn\n");
	}
}
/* }}} */

/* {{{ proto  wxPosition::SetRow(int row)
   Set a new row value. */
PHP_METHOD(php_wxPosition, SetRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPosition::SetRow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPosition* current_object;
	wxphp_object_type current_object_type;
	wxPosition_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPosition*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPosition::SetRow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOSITION_TYPE){
				references = &((wxPosition_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPosition::SetRow((int) row0)\n\n");
				#endif

				((wxPosition_php*)native_object)->SetRow((int) row0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPosition::SetRow\n");
	}
}
/* }}} */

/* {{{ proto  wxPosition::wxPosition()
   Construct a new wxPosition, setting the row and column to the default value of (0, 0). */
PHP_METHOD(php_wxPosition, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPosition::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPosition* current_object;
	wxPosition_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	long row1;
	long col1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row1, &col1)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row1, &col1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxPosition_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) row1, (int) col1)\n");
				#endif

				native_object = new wxPosition_php((int) row1, (int) col1);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxPosition*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxPosition::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxRegion_free(void *object TSRMLS_DC) 
{
    zo_wxRegion* custom_object = (zo_wxRegion*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxRegion_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxRegion done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxRegion_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxRegion_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxRegion* custom_object;
    custom_object = (zo_wxRegion*) emalloc(sizeof(zo_wxRegion));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXREGION_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxRegion_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxRegion::Clear()
   Clears the current region. */
PHP_METHOD(php_wxRegion, Clear)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRegion::Clear\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRegion* current_object;
	wxphp_object_type current_object_type;
	wxRegion_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRegion*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRegion::Clear call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXREGION_TYPE){
				references = &((wxRegion_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRegion::Clear()\n\n");
				#endif

				((wxRegion_php*)native_object)->Clear();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRegion::Clear\n");
	}
}
/* }}} */

/* {{{ proto wxRegionContain wxRegion::Contains(int x, int y)
   Returns a value indicating whether the given point is contained within the region. */
PHP_METHOD(php_wxRegion, Contains)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRegion::Contains\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRegion* current_object;
	wxphp_object_type current_object_type;
	wxRegion_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRegion*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRegion::Contains call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXREGION_TYPE){
				references = &((wxRegion_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* pt1 = 0;
	wxPoint* object_pointer1_0 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	long x2;
	long y2;
	long width2;
	long height2;
	bool overload2_called = false;
	//Parameters for overload 3
	zval* rect3 = 0;
	wxRect* object_pointer3_0 = 0;
	bool overload3_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt1, php_wxPoint_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt1, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pt1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pt1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxPoint*) argument_native_object;
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(pt1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll' (&x2, &y2, &width2, &height2)\n");
		#endif

		char parse_parameters_string[] = "llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x2, &y2, &width2, &height2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&rect3, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect3, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect3) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect3 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect3 TSRMLS_CC))->native_object;
					object_pointer3_0 = (wxRect*) argument_native_object;
					if (!object_pointer3_0 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect3) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload3_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRegion::Contains((wxCoord) x0, (wxCoord) y0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxRegion_php*)native_object)->Contains((wxCoord) x0, (wxCoord) y0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRegion::Contains(*(wxPoint*) object_pointer1_0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxRegion_php*)native_object)->Contains(*(wxPoint*) object_pointer1_0));

				references->AddReference(pt1, "wxRegion::Contains at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRegion::Contains((wxCoord) x2, (wxCoord) y2, (wxCoord) width2, (wxCoord) height2))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxRegion_php*)native_object)->Contains((wxCoord) x2, (wxCoord) y2, (wxCoord) width2, (wxCoord) height2));


				return;
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxRegion::Contains(*(wxRect*) object_pointer3_0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxRegion_php*)native_object)->Contains(*(wxRect*) object_pointer3_0));

				references->AddReference(rect3, "wxRegion::Contains at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRegion::Contains\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxRegion::ConvertToBitmap()
   Convert the region to a black and white bitmap with the white pixels being inside the region. */
PHP_METHOD(php_wxRegion, ConvertToBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRegion::ConvertToBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRegion* current_object;
	wxphp_object_type current_object_type;
	wxRegion_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRegion*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRegion::ConvertToBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXREGION_TYPE){
				references = &((wxRegion_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRegion::ConvertToBitmap() to return new object\n\n");
				#endif

				wxBitmap value_to_return0;
				value_to_return0 = ((wxRegion_php*)native_object)->ConvertToBitmap();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				((zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmap_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRegion::ConvertToBitmap\n");
	}
}
/* }}} */

/* {{{ proto  wxRegion::GetBox(int x, int y, int width, int height)
   Returns the outer bounds of the region. */
PHP_METHOD(php_wxRegion, GetBox)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRegion::GetBox\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRegion* current_object;
	wxphp_object_type current_object_type;
	wxRegion_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRegion*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRegion::GetBox call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXREGION_TYPE){
				references = &((wxRegion_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	long width0;
	long height0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll' (&x0, &y0, &width0, &height0)\n");
		#endif

		char parse_parameters_string[] = "llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0, &width0, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRegion::GetBox((wxCoord&) x0, (wxCoord&) y0, (wxCoord&) width0, (wxCoord&) height0)\n\n");
				#endif

				((wxRegion_php*)native_object)->GetBox((wxCoord&) x0, (wxCoord&) y0, (wxCoord&) width0, (wxCoord&) height0);


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxRegion::GetBox() to return new object\n\n");
				#endif

				wxRect value_to_return0;
				value_to_return0 = ((wxRegion_php*)native_object)->GetBox();
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRegion::GetBox\n");
	}
}
/* }}} */

/* {{{ proto bool wxRegion::Intersect(int x, int y, int width, int height)
   Finds the intersection of this region and another, rectangular region, specified using position and size. */
PHP_METHOD(php_wxRegion, Intersect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRegion::Intersect\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRegion* current_object;
	wxphp_object_type current_object_type;
	wxRegion_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRegion*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRegion::Intersect call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXREGION_TYPE){
				references = &((wxRegion_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	long width0;
	long height0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* rect1 = 0;
	wxRect* object_pointer1_0 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* region2 = 0;
	wxRegion* object_pointer2_0 = 0;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll' (&x0, &y0, &width0, &height0)\n");
		#endif

		char parse_parameters_string[] = "llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0, &width0, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&rect1, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect1, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxRect*) argument_native_object;
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(rect1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&region2, php_wxRegion_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &region2, php_wxRegion_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(region2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRegion*) zend_object_store_get_object(region2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRegion*) zend_object_store_get_object(region2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxRegion*) argument_native_object;
					if (!object_pointer2_0 )
					{
						zend_error(E_ERROR, "Parameter 'region' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(region2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'region' not null, could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::Intersect((wxCoord) x0, (wxCoord) y0, (wxCoord) width0, (wxCoord) height0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->Intersect((wxCoord) x0, (wxCoord) y0, (wxCoord) width0, (wxCoord) height0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::Intersect(*(wxRect*) object_pointer1_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->Intersect(*(wxRect*) object_pointer1_0));

				references->AddReference(rect1, "wxRegion::Intersect at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::Intersect(*(wxRegion*) object_pointer2_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->Intersect(*(wxRegion*) object_pointer2_0));

				references->AddReference(region2, "wxRegion::Intersect at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRegion::Intersect\n");
	}
}
/* }}} */

/* {{{ proto bool wxRegion::IsEmpty()
   Returns true if the region is empty, false otherwise. */
PHP_METHOD(php_wxRegion, IsEmpty)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRegion::IsEmpty\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRegion* current_object;
	wxphp_object_type current_object_type;
	wxRegion_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRegion*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRegion::IsEmpty call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXREGION_TYPE){
				references = &((wxRegion_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::IsEmpty())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->IsEmpty());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRegion::IsEmpty\n");
	}
}
/* }}} */

/* {{{ proto bool wxRegion::IsEqual(wxRegion region)
   Returns true if the region is equal to, i.e. */
PHP_METHOD(php_wxRegion, IsEqual)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRegion::IsEqual\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRegion* current_object;
	wxphp_object_type current_object_type;
	wxRegion_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRegion*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRegion::IsEqual call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXREGION_TYPE){
				references = &((wxRegion_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* region0 = 0;
	wxRegion* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&region0, php_wxRegion_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &region0, php_wxRegion_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(region0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRegion*) zend_object_store_get_object(region0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRegion*) zend_object_store_get_object(region0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxRegion*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'region' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(region0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'region' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::IsEqual(*(wxRegion*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->IsEqual(*(wxRegion*) object_pointer0_0));

				references->AddReference(region0, "wxRegion::IsEqual at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRegion::IsEqual\n");
	}
}
/* }}} */

/* {{{ proto bool wxRegion::Offset(int x, int y)
   Moves the region by the specified offsets in horizontal and vertical directions. */
PHP_METHOD(php_wxRegion, Offset)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRegion::Offset\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRegion* current_object;
	wxphp_object_type current_object_type;
	wxRegion_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRegion*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRegion::Offset call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXREGION_TYPE){
				references = &((wxRegion_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* pt1 = 0;
	wxPoint* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt1, php_wxPoint_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt1, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pt1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pt1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxPoint*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::Offset((wxCoord) x0, (wxCoord) y0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->Offset((wxCoord) x0, (wxCoord) y0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::Offset(*(wxPoint*) object_pointer1_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->Offset(*(wxPoint*) object_pointer1_0));

				references->AddReference(pt1, "wxRegion::Offset at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRegion::Offset\n");
	}
}
/* }}} */

/* {{{ proto bool wxRegion::Subtract(wxRect rect)
   Subtracts a rectangular region from this region. */
PHP_METHOD(php_wxRegion, Subtract)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRegion::Subtract\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRegion* current_object;
	wxphp_object_type current_object_type;
	wxRegion_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRegion*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRegion::Subtract call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXREGION_TYPE){
				references = &((wxRegion_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* rect0 = 0;
	wxRect* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* region1 = 0;
	wxRegion* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxRect*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&region1, php_wxRegion_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &region1, php_wxRegion_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(region1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRegion*) zend_object_store_get_object(region1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRegion*) zend_object_store_get_object(region1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxRegion*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'region' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(region1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'region' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::Subtract(*(wxRect*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->Subtract(*(wxRect*) object_pointer0_0));

				references->AddReference(rect0, "wxRegion::Subtract at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::Subtract(*(wxRegion*) object_pointer1_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->Subtract(*(wxRegion*) object_pointer1_0));

				references->AddReference(region1, "wxRegion::Subtract at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRegion::Subtract\n");
	}
}
/* }}} */

/* {{{ proto bool wxRegion::Union(int x, int y, int width, int height)
   Finds the union of this region and another, rectangular region, specified using position and size. */
PHP_METHOD(php_wxRegion, Union)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRegion::Union\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRegion* current_object;
	wxphp_object_type current_object_type;
	wxRegion_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRegion*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRegion::Union call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXREGION_TYPE){
				references = &((wxRegion_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	long width0;
	long height0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* rect1 = 0;
	wxRect* object_pointer1_0 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* region2 = 0;
	wxRegion* object_pointer2_0 = 0;
	bool overload2_called = false;
	//Parameters for overload 3
	zval* bmp3 = 0;
	wxBitmap* object_pointer3_0 = 0;
	bool overload3_called = false;
	//Parameters for overload 4
	zval* bmp4 = 0;
	wxBitmap* object_pointer4_0 = 0;
	zval* transColour4 = 0;
	wxColour* object_pointer4_1 = 0;
	long tolerance4;
	bool overload4_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll' (&x0, &y0, &width0, &height0)\n");
		#endif

		char parse_parameters_string[] = "llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0, &width0, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&rect1, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect1, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxRect*) argument_native_object;
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(rect1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&region2, php_wxRegion_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &region2, php_wxRegion_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(region2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRegion*) zend_object_store_get_object(region2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRegion*) zend_object_store_get_object(region2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxRegion*) argument_native_object;
					if (!object_pointer2_0 )
					{
						goto overload3;
					}
				}
				else if(Z_TYPE_P(region2) != IS_NULL)
				{
					goto overload3;
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bmp3, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmp3, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmp3) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bmp3 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bmp3 TSRMLS_CC))->native_object;
					object_pointer3_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer3_0 )
					{
						goto overload4;
					}
				}
				else if(Z_TYPE_P(bmp3) != IS_NULL)
				{
					goto overload4;
				}
			}

			overload3_called = true;
			already_called = true;
		}
	}

	//Overload 4
	overload4:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO|l' (&bmp4, php_wxBitmap_entry, &transColour4, php_wxColour_entry, &tolerance4)\n");
		#endif

		char parse_parameters_string[] = "OO|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmp4, php_wxBitmap_entry, &transColour4, php_wxColour_entry, &tolerance4 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmp4) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bmp4 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bmp4 TSRMLS_CC))->native_object;
					object_pointer4_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer4_0 )
					{
						zend_error(E_ERROR, "Parameter 'bmp' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmp4) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bmp' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(transColour4) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(transColour4 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(transColour4 TSRMLS_CC))->native_object;
					object_pointer4_1 = (wxColour*) argument_native_object;
					if (!object_pointer4_1 )
					{
						zend_error(E_ERROR, "Parameter 'transColour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(transColour4) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'transColour' not null, could not be retreived correctly.");
				}
			}

			overload4_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::Union((wxCoord) x0, (wxCoord) y0, (wxCoord) width0, (wxCoord) height0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->Union((wxCoord) x0, (wxCoord) y0, (wxCoord) width0, (wxCoord) height0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::Union(*(wxRect*) object_pointer1_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->Union(*(wxRect*) object_pointer1_0));

				references->AddReference(rect1, "wxRegion::Union at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::Union(*(wxRegion*) object_pointer2_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->Union(*(wxRegion*) object_pointer2_0));

				references->AddReference(region2, "wxRegion::Union at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::Union(*(wxBitmap*) object_pointer3_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->Union(*(wxBitmap*) object_pointer3_0));

				references->AddReference(bmp3, "wxRegion::Union at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload4_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::Union(*(wxBitmap*) object_pointer4_0, *(wxColour*) object_pointer4_1))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->Union(*(wxBitmap*) object_pointer4_0, *(wxColour*) object_pointer4_1));

				references->AddReference(bmp4, "wxRegion::Union at call with 2 argument(s)");
				references->AddReference(transColour4, "wxRegion::Union at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::Union(*(wxBitmap*) object_pointer4_0, *(wxColour*) object_pointer4_1, (int) tolerance4))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->Union(*(wxBitmap*) object_pointer4_0, *(wxColour*) object_pointer4_1, (int) tolerance4));

				references->AddReference(bmp4, "wxRegion::Union at call with 3 argument(s)");
				references->AddReference(transColour4, "wxRegion::Union at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRegion::Union\n");
	}
}
/* }}} */

/* {{{ proto bool wxRegion::Xor(int x, int y, int width, int height)
   Finds the Xor of this region and another, rectangular region, specified using position and size. */
PHP_METHOD(php_wxRegion, XorMethod)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRegion::Xor\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRegion* current_object;
	wxphp_object_type current_object_type;
	wxRegion_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRegion*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRegion::Xor call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXREGION_TYPE){
				references = &((wxRegion_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	long width0;
	long height0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* rect1 = 0;
	wxRect* object_pointer1_0 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* region2 = 0;
	wxRegion* object_pointer2_0 = 0;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll' (&x0, &y0, &width0, &height0)\n");
		#endif

		char parse_parameters_string[] = "llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0, &width0, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&rect1, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect1, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxRect*) argument_native_object;
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(rect1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&region2, php_wxRegion_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &region2, php_wxRegion_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(region2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRegion*) zend_object_store_get_object(region2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRegion*) zend_object_store_get_object(region2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxRegion*) argument_native_object;
					if (!object_pointer2_0 )
					{
						zend_error(E_ERROR, "Parameter 'region' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(region2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'region' not null, could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::Xor((wxCoord) x0, (wxCoord) y0, (wxCoord) width0, (wxCoord) height0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->Xor((wxCoord) x0, (wxCoord) y0, (wxCoord) width0, (wxCoord) height0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::Xor(*(wxRect*) object_pointer1_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->Xor(*(wxRect*) object_pointer1_0));

				references->AddReference(rect1, "wxRegion::Xor at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxRegion::Xor(*(wxRegion*) object_pointer2_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxRegion_php*)native_object)->Xor(*(wxRegion*) object_pointer2_0));

				references->AddReference(region2, "wxRegion::Xor at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRegion::Xor\n");
	}
}
/* }}} */

/* {{{ proto  wxRegion::wxRegion()
   Default constructor. */
PHP_METHOD(php_wxRegion, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRegion::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRegion* current_object;
	wxRegion_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	long x1;
	long y1;
	long width1;
	long height1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* topLeft2 = 0;
	wxPoint* object_pointer2_0 = 0;
	zval* bottomRight2 = 0;
	wxPoint* object_pointer2_1 = 0;
	bool overload2_called = false;
	//Parameters for overload 3
	zval* rect3 = 0;
	wxRect* object_pointer3_0 = 0;
	bool overload3_called = false;
	//Parameters for overload 4
	zval* region4 = 0;
	wxRegion* object_pointer4_0 = 0;
	bool overload4_called = false;
	//Parameters for overload 5
	long n5;
	zval* points5 = 0;
	wxPoint* object_pointer5_1 = 0;
	long fillStyle5;
	bool overload5_called = false;
	//Parameters for overload 6
	zval* bmp6 = 0;
	wxBitmap* object_pointer6_0 = 0;
	bool overload6_called = false;
	//Parameters for overload 7
	zval* bmp7 = 0;
	wxBitmap* object_pointer7_0 = 0;
	zval* transColour7 = 0;
	wxColour* object_pointer7_1 = 0;
	long tolerance7;
	bool overload7_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll' (&x1, &y1, &width1, &height1)\n");
		#endif

		char parse_parameters_string[] = "llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x1, &y1, &width1, &height1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&topLeft2, php_wxPoint_entry, &bottomRight2, php_wxPoint_entry)\n");
		#endif

		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &topLeft2, php_wxPoint_entry, &bottomRight2, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(topLeft2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(topLeft2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(topLeft2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxPoint*) argument_native_object;
					if (!object_pointer2_0 )
					{
						goto overload3;
					}
				}
				else if(Z_TYPE_P(topLeft2) != IS_NULL)
				{
					goto overload3;
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(bottomRight2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(bottomRight2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(bottomRight2 TSRMLS_CC))->native_object;
					object_pointer2_1 = (wxPoint*) argument_native_object;
					if (!object_pointer2_1 )
					{
						goto overload3;
					}
				}
				else if(Z_TYPE_P(bottomRight2) != IS_NULL)
				{
					goto overload3;
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&rect3, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect3, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect3) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect3 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect3 TSRMLS_CC))->native_object;
					object_pointer3_0 = (wxRect*) argument_native_object;
					if (!object_pointer3_0 )
					{
						goto overload4;
					}
				}
				else if(Z_TYPE_P(rect3) != IS_NULL)
				{
					goto overload4;
				}
			}

			overload3_called = true;
			already_called = true;
		}
	}

	//Overload 4
	overload4:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&region4, php_wxRegion_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &region4, php_wxRegion_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(region4) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRegion*) zend_object_store_get_object(region4 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRegion*) zend_object_store_get_object(region4 TSRMLS_CC))->native_object;
					object_pointer4_0 = (wxRegion*) argument_native_object;
					if (!object_pointer4_0 )
					{
						goto overload5;
					}
				}
				else if(Z_TYPE_P(region4) != IS_NULL)
				{
					goto overload5;
				}
			}

			overload4_called = true;
			already_called = true;
		}
	}

	//Overload 5
	overload5:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lz|l' (&n5, &points5, &fillStyle5)\n");
		#endif

		char parse_parameters_string[] = "lz|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n5, &points5, &fillStyle5 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(points5) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(points5 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(points5 TSRMLS_CC))->native_object;
					object_pointer5_1 = (wxPoint*) argument_native_object;
					if (!object_pointer5_1 || (argument_type != PHP_WXPOINT_TYPE))
					{
						goto overload6;
					}
				}
				else if(Z_TYPE_P(points5) != IS_NULL)
				{
					goto overload6;
				}
			}

			overload5_called = true;
			already_called = true;
		}
	}

	//Overload 6
	overload6:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bmp6, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmp6, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmp6) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bmp6 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bmp6 TSRMLS_CC))->native_object;
					object_pointer6_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer6_0 )
					{
						goto overload7;
					}
				}
				else if(Z_TYPE_P(bmp6) != IS_NULL)
				{
					goto overload7;
				}
			}

			overload6_called = true;
			already_called = true;
		}
	}

	//Overload 7
	overload7:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO|l' (&bmp7, php_wxBitmap_entry, &transColour7, php_wxColour_entry, &tolerance7)\n");
		#endif

		char parse_parameters_string[] = "OO|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmp7, php_wxBitmap_entry, &transColour7, php_wxColour_entry, &tolerance7 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmp7) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bmp7 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bmp7 TSRMLS_CC))->native_object;
					object_pointer7_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer7_0 )
					{
						zend_error(E_ERROR, "Parameter 'bmp' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmp7) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bmp' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(transColour7) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(transColour7 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(transColour7 TSRMLS_CC))->native_object;
					object_pointer7_1 = (wxColour*) argument_native_object;
					if (!object_pointer7_1 )
					{
						zend_error(E_ERROR, "Parameter 'transColour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(transColour7) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'transColour' not null, could not be retreived correctly.");
				}
			}

			overload7_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxRegion_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxCoord) x1, (wxCoord) y1, (wxCoord) width1, (wxCoord) height1)\n");
				#endif

				native_object = new wxRegion_php((wxCoord) x1, (wxCoord) y1, (wxCoord) width1, (wxCoord) height1);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxPoint*) object_pointer2_0, *(wxPoint*) object_pointer2_1)\n");
				#endif

				native_object = new wxRegion_php(*(wxPoint*) object_pointer2_0, *(wxPoint*) object_pointer2_1);

				native_object->references.Initialize();
				((wxRegion_php*) native_object)->references.AddReference(topLeft2, "wxRegion::wxRegion at call with 2 argument(s)");
				((wxRegion_php*) native_object)->references.AddReference(bottomRight2, "wxRegion::wxRegion at call with 2 argument(s)");
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxRect*) object_pointer3_0)\n");
				#endif

				native_object = new wxRegion_php(*(wxRect*) object_pointer3_0);

				native_object->references.Initialize();
				((wxRegion_php*) native_object)->references.AddReference(rect3, "wxRegion::wxRegion at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload4_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxRegion*) object_pointer4_0)\n");
				#endif

				native_object = new wxRegion_php(*(wxRegion*) object_pointer4_0);

				native_object->references.Initialize();
				((wxRegion_php*) native_object)->references.AddReference(region4, "wxRegion::wxRegion at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload5_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((size_t) n5, (const wxPoint*) object_pointer5_1)\n");
				#endif

				native_object = new wxRegion_php((size_t) n5, (const wxPoint*) object_pointer5_1);

				native_object->references.Initialize();
				((wxRegion_php*) native_object)->references.AddReference(points5, "wxRegion::wxRegion at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((size_t) n5, (const wxPoint*) object_pointer5_1, (wxPolygonFillMode) fillStyle5)\n");
				#endif

				native_object = new wxRegion_php((size_t) n5, (const wxPoint*) object_pointer5_1, (wxPolygonFillMode) fillStyle5);

				native_object->references.Initialize();
				((wxRegion_php*) native_object)->references.AddReference(points5, "wxRegion::wxRegion at call with 3 argument(s)");
				break;
			}
		}
	}

	if(overload6_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer6_0)\n");
				#endif

				native_object = new wxRegion_php(*(wxBitmap*) object_pointer6_0);

				native_object->references.Initialize();
				((wxRegion_php*) native_object)->references.AddReference(bmp6, "wxRegion::wxRegion at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload7_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer7_0, *(wxColour*) object_pointer7_1)\n");
				#endif

				native_object = new wxRegion_php(*(wxBitmap*) object_pointer7_0, *(wxColour*) object_pointer7_1);

				native_object->references.Initialize();
				((wxRegion_php*) native_object)->references.AddReference(bmp7, "wxRegion::wxRegion at call with 2 argument(s)");
				((wxRegion_php*) native_object)->references.AddReference(transColour7, "wxRegion::wxRegion at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer7_0, *(wxColour*) object_pointer7_1, (int) tolerance7)\n");
				#endif

				native_object = new wxRegion_php(*(wxBitmap*) object_pointer7_0, *(wxColour*) object_pointer7_1, (int) tolerance7);

				native_object->references.Initialize();
				((wxRegion_php*) native_object)->references.AddReference(bmp7, "wxRegion::wxRegion at call with 3 argument(s)");
				((wxRegion_php*) native_object)->references.AddReference(transColour7, "wxRegion::wxRegion at call with 3 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxRegion*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxRegion::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxStatusBarPane_free(void *object TSRMLS_DC) 
{
    zo_wxStatusBarPane* custom_object = (zo_wxStatusBarPane*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxStatusBarPane_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxStatusBarPane done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxStatusBarPane_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxStatusBarPane_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxStatusBarPane* custom_object;
    custom_object = (zo_wxStatusBarPane*) emalloc(sizeof(zo_wxStatusBarPane));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXSTATUSBARPANE_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxStatusBarPane_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto string wxStatusBarPane::GetText()
   Returns the text currently shown in this pane. */
PHP_METHOD(php_wxStatusBarPane, GetText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStatusBarPane::GetText\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxStatusBarPane* current_object;
	wxphp_object_type current_object_type;
	wxStatusBarPane_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxStatusBarPane*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxStatusBarPane::GetText call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXSTATUSBARPANE_TYPE){
				references = &((wxStatusBarPane_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxStatusBarPane::GetText().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxStatusBarPane_php*)native_object)->GetText();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxStatusBarPane::GetText\n");
	}
}
/* }}} */

/* {{{ proto int wxStatusBarPane::GetStyle()
   Returns the pane style. */
PHP_METHOD(php_wxStatusBarPane, GetStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStatusBarPane::GetStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxStatusBarPane* current_object;
	wxphp_object_type current_object_type;
	wxStatusBarPane_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxStatusBarPane*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxStatusBarPane::GetStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXSTATUSBARPANE_TYPE){
				references = &((wxStatusBarPane_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxStatusBarPane::GetStyle())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxStatusBarPane_php*)native_object)->GetStyle());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxStatusBarPane::GetStyle\n");
	}
}
/* }}} */

/* {{{ proto int wxStatusBarPane::GetWidth()
   Returns the pane width; it maybe negative, indicating a variable-width field. */
PHP_METHOD(php_wxStatusBarPane, GetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStatusBarPane::GetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxStatusBarPane* current_object;
	wxphp_object_type current_object_type;
	wxStatusBarPane_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxStatusBarPane*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxStatusBarPane::GetWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXSTATUSBARPANE_TYPE){
				references = &((wxStatusBarPane_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxStatusBarPane::GetWidth())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxStatusBarPane_php*)native_object)->GetWidth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxStatusBarPane::GetWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxStatusBarPane::wxStatusBarPane(int style, int width)
   Constructs the pane with the given style and width. */
PHP_METHOD(php_wxStatusBarPane, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxStatusBarPane::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxStatusBarPane* current_object;
	wxStatusBarPane_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	long style0;
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|ll' (&style0, &width0)\n");
		#endif

		char parse_parameters_string[] = "|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxStatusBarPane_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) style0)\n");
				#endif

				native_object = new wxStatusBarPane_php((int) style0);

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) style0, (size_t) width0)\n");
				#endif

				native_object = new wxStatusBarPane_php((int) style0, (size_t) width0);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxStatusBarPane*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxStatusBarPane::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxTreeItemId_free(void *object TSRMLS_DC) 
{
    zo_wxTreeItemId* custom_object = (zo_wxTreeItemId*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTreeItemId_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxTreeItemId done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxTreeItemId_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTreeItemId_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxTreeItemId* custom_object;
    custom_object = (zo_wxTreeItemId*) emalloc(sizeof(zo_wxTreeItemId));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXTREEITEMID_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxTreeItemId_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxTreeItemId::wxTreeItemId()
   Default constructor. */
PHP_METHOD(php_wxTreeItemId, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeItemId::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTreeItemId* current_object;
	wxTreeItemId_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxTreeItemId_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxTreeItemId*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxTreeItemId::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto bool wxTreeItemId::IsOk()
   Returns true if this instance is referencing a valid tree item. */
PHP_METHOD(php_wxTreeItemId, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTreeItemId::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTreeItemId* current_object;
	wxphp_object_type current_object_type;
	wxTreeItemId_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTreeItemId*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTreeItemId::IsOk call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTREEITEMID_TYPE){
				references = &((wxTreeItemId_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTreeItemId::IsOk())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTreeItemId_php*)native_object)->IsOk());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTreeItemId::IsOk\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxVariant_free(void *object TSRMLS_DC) 
{
    zo_wxVariant* custom_object = (zo_wxVariant*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxVariant_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxVariant done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxVariant_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxVariant_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxVariant* custom_object;
    custom_object = (zo_wxVariant*) emalloc(sizeof(zo_wxVariant));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXVARIANT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxVariant_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxVariant::Append(wxVariant value)
   Appends a value to the list. */
PHP_METHOD(php_wxVariant, Append)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::Append\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::Append call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* value0 = 0;
	wxVariant* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&value0, php_wxVariant_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, php_wxVariant_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(value0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxVariant*) zend_object_store_get_object(value0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxVariant*) zend_object_store_get_object(value0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxVariant*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'value' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(value0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'value' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVariant::Append(*(wxVariant*) object_pointer0_0)\n\n");
				#endif

				((wxVariant_php*)native_object)->Append(*(wxVariant*) object_pointer0_0);

				references->AddReference(value0, "wxVariant::Append at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::Append\n");
	}
}
/* }}} */

/* {{{ proto  wxVariant::Clear()
   Makes the variant null by deleting the internal data and set the name to wxEmptyString. */
PHP_METHOD(php_wxVariant, Clear)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::Clear\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::Clear call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVariant::Clear()\n\n");
				#endif

				((wxVariant_php*)native_object)->Clear();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::Clear\n");
	}
}
/* }}} */

/* {{{ proto  wxVariant::ClearList()
   Deletes the contents of the list. */
PHP_METHOD(php_wxVariant, ClearList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::ClearList\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::ClearList call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVariant::ClearList()\n\n");
				#endif

				((wxVariant_php*)native_object)->ClearList();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::ClearList\n");
	}
}
/* }}} */

/* {{{ proto bool wxVariant::Convert(int &value)
   Retrieves and converts the value of this variant to the type that value is. */
PHP_METHOD(php_wxVariant, Convert)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::Convert\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::Convert call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long* value0;
	zval* value0_ref;
	bool overload0_called = false;
	//Parameters for overload 1
	bool* value1;
	zval* value1_ref;
	bool overload1_called = false;
	//Parameters for overload 2
	double* value2;
	zval* value2_ref;
	bool overload2_called = false;
	//Parameters for overload 3
	long value3;
	zval* value3_ref;
	bool overload3_called = false;
	//Parameters for overload 4
	char* value4;
	long value_len4;
	zval* value4_ref;
	bool overload4_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (value0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, value0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &value0_ref );
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (value1)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, value1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;

			char parse_references_string[] = "z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &value1_ref );
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'd' (value2)\n");
		#endif

		char parse_parameters_string[] = "d";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, value2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;

			char parse_references_string[] = "z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &value2_ref );
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&value3)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value3 ) == SUCCESS)
		{
			overload3_called = true;
			already_called = true;

			char parse_references_string[] = "z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &value3_ref );
		}
	}

	//Overload 4
	overload4:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&value4, &value_len4)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value4, &value_len4 ) == SUCCESS)
		{
			overload4_called = true;
			already_called = true;

			char parse_references_string[] = "z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &value4_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVariant::Convert((long*) value0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxVariant_php*)native_object)->Convert((long*) value0));

				size_t elements_returned0_0 = sizeof(value0)/sizeof(*value0);
				array_init(value0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(value0_ref, value0[i]);
				}

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVariant::Convert(value1))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxVariant_php*)native_object)->Convert(value1));

				size_t elements_returned1_0 = sizeof(value1)/sizeof(*value1);
				array_init(value1_ref);
				for(size_t i=0; i<elements_returned1_0; i++)
				{
					add_next_index_long(value1_ref, value1[i]);
				}

				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVariant::Convert(value2))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxVariant_php*)native_object)->Convert(value2));

				size_t elements_returned2_0 = sizeof(value2)/sizeof(*value2);
				array_init(value2_ref);
				for(size_t i=0; i<elements_returned2_0; i++)
				{
					add_next_index_long(value2_ref, value2[i]);
				}

				return;
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				wxDateTime date_time3_0 = wxDateTime(value3);
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVariant::Convert(&date_time3_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxVariant_php*)native_object)->Convert(&date_time3_0));

				ZVAL_LONG(value3_ref, date_time3_0.GetTicks());

				return;
				break;
			}
		}
	}

	if(overload4_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				wxString string_arg4_0 = wxString(value4, wxConvUTF8);
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVariant::Convert(&string_arg4_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxVariant_php*)native_object)->Convert(&string_arg4_0));

				char* temp_string4_0;
				temp_string4_0 = (char*)malloc(sizeof(wxChar)*(string_arg4_0.size()+1));
				strcpy (temp_string4_0, (const char *) string_arg4_0.char_str() );
				ZVAL_STRING(value4_ref, (char*) temp_string4_0, 1);
				free(temp_string4_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::Convert\n");
	}
}
/* }}} */

/* {{{ proto bool wxVariant::Delete(int item)
   Deletes the zero-based item from the list. */
PHP_METHOD(php_wxVariant, Delete)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::Delete\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::Delete call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long item0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&item0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &item0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVariant::Delete((size_t) item0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxVariant_php*)native_object)->Delete((size_t) item0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::Delete\n");
	}
}
/* }}} */

/* {{{ proto array wxVariant::GetArrayString()
   Returns the string array value. */
PHP_METHOD(php_wxVariant, GetArrayString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::GetArrayString\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::GetArrayString call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVariant::GetArrayString() to return strings array\n\n");
				#endif

				wxArrayString value_to_return0;
				value_to_return0 = ((wxVariant_php*)native_object)->GetArrayString();
				char* temp_string0;
				array_init(return_value);
				for(size_t i=0; i<value_to_return0.GetCount(); i++)
				{
					temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0[i].size()+1));
					strcpy (temp_string0, (const char *) value_to_return0[i].char_str() );
					add_next_index_string(return_value, (char*) temp_string0, 1);
					free(temp_string0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::GetArrayString\n");
	}
}
/* }}} */

/* {{{ proto bool wxVariant::GetBool()
   Returns the boolean value. */
PHP_METHOD(php_wxVariant, GetBool)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::GetBool\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::GetBool call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVariant::GetBool())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxVariant_php*)native_object)->GetBool());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::GetBool\n");
	}
}
/* }}} */

/* {{{ proto wxVariantData wxVariant::GetData()
   Returns a pointer to the internal variant data. */
PHP_METHOD(php_wxVariant, GetData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::GetData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::GetData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVariant::GetData() to return object pointer\n\n");
				#endif

				wxVariantData_php* value_to_return0;
				value_to_return0 = (wxVariantData_php*) ((wxVariant_php*)native_object)->GetData();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxVariantData_entry);
					((zo_wxVariantData*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxVariantData_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxVariant::GetData at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::GetData\n");
	}
}
/* }}} */

/* {{{ proto timestamp wxVariant::GetDateTime()
   Returns the date value. */
PHP_METHOD(php_wxVariant, GetDateTime)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::GetDateTime\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::GetDateTime call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVariant::GetDateTime() to return timestamp\n\n");
				#endif

				long value_to_return0;
				value_to_return0 = ((wxVariant_php*)native_object)->GetDateTime().GetTicks();
				ZVAL_LONG(return_value, value_to_return0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::GetDateTime\n");
	}
}
/* }}} */

/* {{{ proto float wxVariant::GetDouble()
   Returns the floating point value. */
PHP_METHOD(php_wxVariant, GetDouble)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::GetDouble\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::GetDouble call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxVariant::GetDouble())\n\n");
				#endif

				ZVAL_DOUBLE(return_value, ((wxVariant_php*)native_object)->GetDouble());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::GetDouble\n");
	}
}
/* }}} */

/* {{{ proto int wxVariant::GetLong()
   Returns the integer value. */
PHP_METHOD(php_wxVariant, GetLong)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::GetLong\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::GetLong call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxVariant::GetLong())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxVariant_php*)native_object)->GetLong());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::GetLong\n");
	}
}
/* }}} */

/* {{{ proto string wxVariant::GetName()
   Returns a constant reference to the variant name. */
PHP_METHOD(php_wxVariant, GetName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::GetName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::GetName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxVariant::GetName().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxVariant_php*)native_object)->GetName();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::GetName\n");
	}
}
/* }}} */

/* {{{ proto string wxVariant::GetType()
   Returns the value type as a string. */
PHP_METHOD(php_wxVariant, GetType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::GetType\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::GetType call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxVariant::GetType().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxVariant_php*)native_object)->GetType();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::GetType\n");
	}
}
/* }}} */

/* {{{ proto void wxVariant::GetVoidPtr()
   Gets the void pointer value. */
PHP_METHOD(php_wxVariant, GetVoidPtr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::GetVoidPtr\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::GetVoidPtr call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVariant::GetVoidPtr()\n\n");
				#endif

				ZVAL_STRING(return_value, (char*) ((wxVariant_php*)native_object)->GetVoidPtr(), 1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::GetVoidPtr\n");
	}
}
/* }}} */

/* {{{ proto wxObject wxVariant::GetWxObjectPtr()
   Gets the wxObject pointer value. */
PHP_METHOD(php_wxVariant, GetWxObjectPtr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::GetWxObjectPtr\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::GetWxObjectPtr call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVariant::GetWxObjectPtr() to return object pointer\n\n");
				#endif

				wxObject_php* value_to_return0;
				value_to_return0 = (wxObject_php*) ((wxVariant_php*)native_object)->GetWxObjectPtr();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxObject_entry);
					((zo_wxObject*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxObject_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxVariant::GetWxObjectPtr at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::GetWxObjectPtr\n");
	}
}
/* }}} */

/* {{{ proto  wxVariant::Insert(wxVariant value)
   Inserts a value at the front of the list. */
PHP_METHOD(php_wxVariant, Insert)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::Insert\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::Insert call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* value0 = 0;
	wxVariant* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&value0, php_wxVariant_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, php_wxVariant_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(value0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxVariant*) zend_object_store_get_object(value0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxVariant*) zend_object_store_get_object(value0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxVariant*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'value' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(value0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'value' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVariant::Insert(*(wxVariant*) object_pointer0_0)\n\n");
				#endif

				((wxVariant_php*)native_object)->Insert(*(wxVariant*) object_pointer0_0);

				references->AddReference(value0, "wxVariant::Insert at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::Insert\n");
	}
}
/* }}} */

/* {{{ proto bool wxVariant::IsNull()
   Returns true if there is no data associated with this variant, false if there is data. */
PHP_METHOD(php_wxVariant, IsNull)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::IsNull\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::IsNull call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVariant::IsNull())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxVariant_php*)native_object)->IsNull());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::IsNull\n");
	}
}
/* }}} */

/* {{{ proto bool wxVariant::IsValueKindOf(wxClassInfo type)
   Returns true if the data is derived from the class described by type, false otherwise. */
PHP_METHOD(php_wxVariant, IsValueKindOf)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::IsValueKindOf\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::IsValueKindOf call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* type0 = 0;
	wxClassInfo* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&type0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &type0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(type0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxClassInfo*) zend_object_store_get_object(type0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxClassInfo*) zend_object_store_get_object(type0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxClassInfo*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXCLASSINFO_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'type' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(type0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'type' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVariant::IsValueKindOf((const wxClassInfo*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxVariant_php*)native_object)->IsValueKindOf((const wxClassInfo*) object_pointer0_0));

				references->AddReference(type0, "wxVariant::IsValueKindOf at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::IsValueKindOf\n");
	}
}
/* }}} */

/* {{{ proto  wxVariant::MakeNull()
   Makes the variant null by deleting the internal data. */
PHP_METHOD(php_wxVariant, MakeNull)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::MakeNull\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::MakeNull call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVariant::MakeNull()\n\n");
				#endif

				((wxVariant_php*)native_object)->MakeNull();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::MakeNull\n");
	}
}
/* }}} */

/* {{{ proto string wxVariant::MakeString()
   Makes a string representation of the variant value (for any type). */
PHP_METHOD(php_wxVariant, MakeString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::MakeString\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::MakeString call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxVariant::MakeString().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxVariant_php*)native_object)->MakeString();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::MakeString\n");
	}
}
/* }}} */

/* {{{ proto bool wxVariant::Member(wxVariant value)
   Returns true if value matches an element in the list. */
PHP_METHOD(php_wxVariant, Member)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::Member\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::Member call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* value0 = 0;
	wxVariant* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&value0, php_wxVariant_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, php_wxVariant_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(value0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxVariant*) zend_object_store_get_object(value0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxVariant*) zend_object_store_get_object(value0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxVariant*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'value' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(value0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'value' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVariant::Member(*(wxVariant*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxVariant_php*)native_object)->Member(*(wxVariant*) object_pointer0_0));

				references->AddReference(value0, "wxVariant::Member at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::Member\n");
	}
}
/* }}} */

/* {{{ proto bool wxVariant::IsType(string type)
   Returns true if type matches the type of the variant, false otherwise. */
PHP_METHOD(php_wxVariant, IsType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::IsType\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::IsType call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* type0;
	long type_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&type0, &type_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &type0, &type_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVariant::IsType(wxString(type0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxVariant_php*)native_object)->IsType(wxString(type0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::IsType\n");
	}
}
/* }}} */

/* {{{ proto string wxVariant::GetString()
   Gets the string value. */
PHP_METHOD(php_wxVariant, GetString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::GetString\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::GetString call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxVariant::GetString().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxVariant_php*)native_object)->GetString();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::GetString\n");
	}
}
/* }}} */

/* {{{ proto int wxVariant::GetCount()
   Returns the number of elements in the list. */
PHP_METHOD(php_wxVariant, GetCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::GetCount\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::GetCount call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxVariant::GetCount())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxVariant_php*)native_object)->GetCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::GetCount\n");
	}
}
/* }}} */

/* {{{ proto  wxVariant::NullList()
   Makes an empty list. */
PHP_METHOD(php_wxVariant, NullList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::NullList\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::NullList call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVariant::NullList()\n\n");
				#endif

				((wxVariant_php*)native_object)->NullList();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::NullList\n");
	}
}
/* }}} */

/* {{{ proto  wxVariant::SetData(wxVariantData &data)
   Sets the internal variant data, deleting the existing data if there is any. */
PHP_METHOD(php_wxVariant, SetData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::SetData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxphp_object_type current_object_type;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariant::SetData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANT_TYPE){
				references = &((wxVariant_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* data0 = 0;
	wxVariantData* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&data0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(data0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxVariantData*) zend_object_store_get_object(data0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxVariantData*) zend_object_store_get_object(data0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxVariantData*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXVARIANTDATA_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'data' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(data0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'data' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVariant::SetData((wxVariantData*) object_pointer0_0)\n\n");
				#endif

				((wxVariant_php*)native_object)->SetData((wxVariantData*) object_pointer0_0);

				references->AddReference(data0, "wxVariant::SetData at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariant::SetData\n");
	}
}
/* }}} */

/* {{{ proto  wxVariant::wxVariant(string value, string name)
   Constructs a variant from a string. */
PHP_METHOD(php_wxVariant, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariant::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariant* current_object;
	wxVariant_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	char* value0;
	long value_len0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	long value1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
	//Parameters for overload 2
	bool value2;
	char* name2;
	long name_len2;
	bool overload2_called = false;
	//Parameters for overload 3
	double value3;
	char* name3;
	long name_len3;
	bool overload3_called = false;
	//Parameters for overload 4
	char* value4;
	long value_len4;
	zval* value4_ref;
	char* name4;
	long name_len4;
	bool overload4_called = false;
	//Parameters for overload 5
	zval* value5 = 0;
	wxObject* object_pointer5_0 = 0;
	char* name5;
	long name_len5;
	bool overload5_called = false;
	//Parameters for overload 6
	long val6;
	char* name6;
	long name_len6;
	bool overload6_called = false;
	//Parameters for overload 7
	zval* val7 = 0;
	char* name7;
	long name_len7;
	bool overload7_called = false;
	//Parameters for overload 8
	zval* variant8 = 0;
	wxVariant* object_pointer8_0 = 0;
	bool overload8_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|s' (&value0, &value_len0, &name0, &name_len0)\n");
		#endif

		char parse_parameters_string[] = "s|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, &value_len0, &name0, &name_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|s' (&value1, &name1, &name_len1)\n");
		#endif

		char parse_parameters_string[] = "l|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value1, &name1, &name_len1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b|s' (&value2, &name2, &name_len2)\n");
		#endif

		char parse_parameters_string[] = "b|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value2, &name2, &name_len2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'd|s' (&value3, &name3, &name_len3)\n");
		#endif

		char parse_parameters_string[] = "d|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value3, &name3, &name_len3 ) == SUCCESS)
		{
			overload3_called = true;
			already_called = true;
		}
	}

	//Overload 4
	overload4:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|s' (&value4, &value_len4, &name4, &name_len4)\n");
		#endif

		char parse_parameters_string[] = "s|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value4, &value_len4, &name4, &name_len4 ) == SUCCESS)
		{
			overload4_called = true;
			already_called = true;

			char parse_references_string[] = "z|z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &value4_ref, &dummy );
		}
	}

	//Overload 5
	overload5:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|s' (&value5, &name5, &name_len5)\n");
		#endif

		char parse_parameters_string[] = "z|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value5, &name5, &name_len5 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(value5) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxObject*) zend_object_store_get_object(value5 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxObject*) zend_object_store_get_object(value5 TSRMLS_CC))->native_object;
					object_pointer5_0 = (wxObject*) argument_native_object;
					if (!object_pointer5_0 || (argument_type != PHP_WXOBJECT_TYPE && argument_type != PHP_WXEVTHANDLER_TYPE && argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXPAGESETUPDIALOG_TYPE && argument_type != PHP_WXPRINTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE && argument_type != PHP_WXVALIDATOR_TYPE && argument_type != PHP_WXTEXTVALIDATOR_TYPE && argument_type != PHP_WXGENERICVALIDATOR_TYPE && argument_type != PHP_WXMENU_TYPE && argument_type != PHP_WXAUIMANAGER_TYPE && argument_type != PHP_WXMOUSEEVENTSMANAGER_TYPE && argument_type != PHP_WXTIMER_TYPE && argument_type != PHP_WXEVENTBLOCKER_TYPE && argument_type != PHP_WXPROCESS_TYPE && argument_type != PHP_WXFILESYSTEMWATCHER_TYPE && argument_type != PHP_WXTASKBARICON_TYPE && argument_type != PHP_WXNOTIFICATIONMESSAGE_TYPE && argument_type != PHP_WXBITMAPHANDLER_TYPE && argument_type != PHP_WXIMAGE_TYPE && argument_type != PHP_WXSIZER_TYPE && argument_type != PHP_WXBOXSIZER_TYPE && argument_type != PHP_WXSTATICBOXSIZER_TYPE && argument_type != PHP_WXWRAPSIZER_TYPE && argument_type != PHP_WXSTDDIALOGBUTTONSIZER_TYPE && argument_type != PHP_WXGRIDSIZER_TYPE && argument_type != PHP_WXFLEXGRIDSIZER_TYPE && argument_type != PHP_WXGRIDBAGSIZER_TYPE && argument_type != PHP_WXSIZERITEM_TYPE && argument_type != PHP_WXGBSIZERITEM_TYPE && argument_type != PHP_WXIMAGELIST_TYPE && argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE && argument_type != PHP_WXCOLOUR_TYPE && argument_type != PHP_WXMENUITEM_TYPE && argument_type != PHP_WXEVENT_TYPE && argument_type != PHP_WXMENUEVENT_TYPE && argument_type != PHP_WXKEYEVENT_TYPE && argument_type != PHP_WXCOMMANDEVENT_TYPE && argument_type != PHP_WXNOTIFYEVENT_TYPE && argument_type != PHP_WXTREEEVENT_TYPE && argument_type != PHP_WXBOOKCTRLEVENT_TYPE && argument_type != PHP_WXAUINOTEBOOKEVENT_TYPE && argument_type != PHP_WXAUITOOLBAREVENT_TYPE && argument_type != PHP_WXLISTEVENT_TYPE && argument_type != PHP_WXSPINEVENT_TYPE && argument_type != PHP_WXSPLITTEREVENT_TYPE && argument_type != PHP_WXSPINDOUBLEEVENT_TYPE && argument_type != PHP_WXGRIDSIZEEVENT_TYPE && argument_type != PHP_WXWIZARDEVENT_TYPE && argument_type != PHP_WXGRIDEVENT_TYPE && argument_type != PHP_WXGRIDRANGESELECTEVENT_TYPE && argument_type != PHP_WXDATAVIEWEVENT_TYPE && argument_type != PHP_WXHEADERCTRLEVENT_TYPE && argument_type != PHP_WXRIBBONBAREVENT_TYPE && argument_type != PHP_WXWEBVIEWEVENT_TYPE && argument_type != PHP_WXSTYLEDTEXTEVENT_TYPE && argument_type != PHP_WXCHILDFOCUSEVENT_TYPE && argument_type != PHP_WXHTMLCELLEVENT_TYPE && argument_type != PHP_WXHTMLLINKEVENT_TYPE && argument_type != PHP_WXHYPERLINKEVENT_TYPE && argument_type != PHP_WXCOLOURPICKEREVENT_TYPE && argument_type != PHP_WXFONTPICKEREVENT_TYPE && argument_type != PHP_WXSCROLLEVENT_TYPE && argument_type != PHP_WXWINDOWMODALDIALOGEVENT_TYPE && argument_type != PHP_WXDATEEVENT_TYPE && argument_type != PHP_WXCALENDAREVENT_TYPE && argument_type != PHP_WXWINDOWCREATEEVENT_TYPE && argument_type != PHP_WXWINDOWDESTROYEVENT_TYPE && argument_type != PHP_WXUPDATEUIEVENT_TYPE && argument_type != PHP_WXHELPEVENT_TYPE && argument_type != PHP_WXGRIDEDITORCREATEDEVENT_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANEEVENT_TYPE && argument_type != PHP_WXCLIPBOARDTEXTEVENT_TYPE && argument_type != PHP_WXFILECTRLEVENT_TYPE && argument_type != PHP_WXSASHEVENT_TYPE && argument_type != PHP_WXFILEDIRPICKEREVENT_TYPE && argument_type != PHP_WXCONTEXTMENUEVENT_TYPE && argument_type != PHP_WXRIBBONBUTTONBAREVENT_TYPE && argument_type != PHP_WXRIBBONGALLERYEVENT_TYPE && argument_type != PHP_WXCLOSEEVENT_TYPE && argument_type != PHP_WXACTIVATEEVENT_TYPE && argument_type != PHP_WXAUIMANAGEREVENT_TYPE && argument_type != PHP_WXSIZEEVENT_TYPE && argument_type != PHP_WXMOUSEEVENT_TYPE && argument_type != PHP_WXMOVEEVENT_TYPE && argument_type != PHP_WXTIMEREVENT_TYPE && argument_type != PHP_WXTHREADEVENT_TYPE && argument_type != PHP_WXSCROLLWINEVENT_TYPE && argument_type != PHP_WXSYSCOLOURCHANGEDEVENT_TYPE && argument_type != PHP_WXPROCESSEVENT_TYPE && argument_type != PHP_WXERASEEVENT_TYPE && argument_type != PHP_WXSETCURSOREVENT_TYPE && argument_type != PHP_WXIDLEEVENT_TYPE && argument_type != PHP_WXPAINTEVENT_TYPE && argument_type != PHP_WXPALETTECHANGEDEVENT_TYPE && argument_type != PHP_WXINITDIALOGEVENT_TYPE && argument_type != PHP_WXMAXIMIZEEVENT_TYPE && argument_type != PHP_WXNAVIGATIONKEYEVENT_TYPE && argument_type != PHP_WXFOCUSEVENT_TYPE && argument_type != PHP_WXFILESYSTEMWATCHEREVENT_TYPE && argument_type != PHP_WXDISPLAYCHANGEDEVENT_TYPE && argument_type != PHP_WXCALCULATELAYOUTEVENT_TYPE && argument_type != PHP_WXQUERYLAYOUTINFOEVENT_TYPE && argument_type != PHP_WXTASKBARICONEVENT_TYPE && argument_type != PHP_WXACCELERATORTABLE_TYPE && argument_type != PHP_WXGDIOBJECT_TYPE && argument_type != PHP_WXBITMAP_TYPE && argument_type != PHP_WXPALETTE_TYPE && argument_type != PHP_WXICON_TYPE && argument_type != PHP_WXFONT_TYPE && argument_type != PHP_WXANIMATION_TYPE && argument_type != PHP_WXICONBUNDLE_TYPE && argument_type != PHP_WXCURSOR_TYPE && argument_type != PHP_WXREGION_TYPE && argument_type != PHP_WXPEN_TYPE && argument_type != PHP_WXBRUSH_TYPE && argument_type != PHP_WXARTPROVIDER_TYPE && argument_type != PHP_WXHTMLCELL_TYPE && argument_type != PHP_WXHTMLCONTAINERCELL_TYPE && argument_type != PHP_WXHTMLCOLOURCELL_TYPE && argument_type != PHP_WXHTMLWIDGETCELL_TYPE && argument_type != PHP_WXHTMLEASYPRINTING_TYPE && argument_type != PHP_WXHTMLLINKINFO_TYPE && argument_type != PHP_WXFINDREPLACEDATA_TYPE && argument_type != PHP_WXSOUND_TYPE && argument_type != PHP_WXFILESYSTEM_TYPE && argument_type != PHP_WXFILESYSTEMHANDLER_TYPE && argument_type != PHP_WXMASK_TYPE && argument_type != PHP_WXTOOLTIP_TYPE && argument_type != PHP_WXGRAPHICSRENDERER_TYPE && argument_type != PHP_WXLAYOUTCONSTRAINTS_TYPE && argument_type != PHP_WXFSFILE_TYPE && argument_type != PHP_WXCOLOURDATA_TYPE && argument_type != PHP_WXFONTDATA_TYPE && argument_type != PHP_WXGRIDTABLEBASE_TYPE && argument_type != PHP_WXDATAVIEWRENDERER_TYPE && argument_type != PHP_WXDATAVIEWBITMAPRENDERER_TYPE && argument_type != PHP_WXDATAVIEWCHOICERENDERER_TYPE && argument_type != PHP_WXDATAVIEWCUSTOMRENDERER_TYPE && argument_type != PHP_WXDATAVIEWSPINRENDERER_TYPE && argument_type != PHP_WXDATAVIEWDATERENDERER_TYPE && argument_type != PHP_WXDATAVIEWICONTEXTRENDERER_TYPE && argument_type != PHP_WXDATAVIEWPROGRESSRENDERER_TYPE && argument_type != PHP_WXDATAVIEWTEXTRENDERER_TYPE && argument_type != PHP_WXDATAVIEWTOGGLERENDERER_TYPE && argument_type != PHP_WXDATAVIEWICONTEXT_TYPE && argument_type != PHP_WXVARIANT_TYPE && argument_type != PHP_WXCLIPBOARD_TYPE && argument_type != PHP_WXCONFIGBASE_TYPE && argument_type != PHP_WXFILECONFIG_TYPE && argument_type != PHP_WXXMLRESOURCE_TYPE && argument_type != PHP_WXPAGESETUPDIALOGDATA_TYPE && argument_type != PHP_WXPRINTDIALOGDATA_TYPE && argument_type != PHP_WXPRINTDATA_TYPE && argument_type != PHP_WXPRINTPREVIEW_TYPE && argument_type != PHP_WXPRINTER_TYPE && argument_type != PHP_WXPRINTOUT_TYPE && argument_type != PHP_WXHTMLPRINTOUT_TYPE && argument_type != PHP_WXHTMLDCRENDERER_TYPE && argument_type != PHP_WXHTMLFILTER_TYPE && argument_type != PHP_WXHTMLHELPDATA_TYPE && argument_type != PHP_WXHTMLTAGHANDLER_TYPE && argument_type != PHP_WXHTMLWINTAGHANDLER_TYPE && argument_type != PHP_WXMODULE_TYPE && argument_type != PHP_WXHTMLTAGSMODULE_TYPE && argument_type != PHP_WXIMAGEHANDLER_TYPE && argument_type != PHP_WXXMLRESOURCEHANDLER_TYPE && argument_type != PHP_WXXMLDOCUMENT_TYPE && argument_type != PHP_WXLAYOUTALGORITHM_TYPE && argument_type != PHP_WXFILEHISTORY_TYPE && argument_type != PHP_WXTOOLBARTOOLBASE_TYPE))
					{
						goto overload6;
					}
				}
				else if(Z_TYPE_P(value5) != IS_NULL)
				{
					goto overload6;
				}
			}

			overload5_called = true;
			already_called = true;
		}
	}

	//Overload 6
	overload6:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|s' (&val6, &name6, &name_len6)\n");
		#endif

		char parse_parameters_string[] = "l|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &val6, &name6, &name_len6 ) == SUCCESS)
		{
			overload6_called = true;
			already_called = true;
		}
	}

	//Overload 7
	overload7:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a|s' (&val7, &name7, &name_len7)\n");
		#endif

		char parse_parameters_string[] = "a|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &val7, &name7, &name_len7 ) == SUCCESS)
		{
			overload7_called = true;
			already_called = true;
		}
	}

	//Overload 8
	overload8:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&variant8, php_wxVariant_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &variant8, php_wxVariant_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(variant8) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxVariant*) zend_object_store_get_object(variant8 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxVariant*) zend_object_store_get_object(variant8 TSRMLS_CC))->native_object;
					object_pointer8_0 = (wxVariant*) argument_native_object;
					if (!object_pointer8_0 )
					{
						zend_error(E_ERROR, "Parameter 'variant' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(variant8) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'variant' not null, could not be retreived correctly.");
				}
			}

			overload8_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(value0, wxConvUTF8))\n");
				#endif

				native_object = new wxVariant_php(wxString(value0, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(value0, wxConvUTF8), wxString(name0, wxConvUTF8))\n");
				#endif

				native_object = new wxVariant_php(wxString(value0, wxConvUTF8), wxString(name0, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((long) value1)\n");
				#endif

				native_object = new wxVariant_php((long) value1);

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((long) value1, wxString(name1, wxConvUTF8))\n");
				#endif

				native_object = new wxVariant_php((long) value1, wxString(name1, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(value2)\n");
				#endif

				native_object = new wxVariant_php(value2);

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(value2, wxString(name2, wxConvUTF8))\n");
				#endif

				native_object = new wxVariant_php(value2, wxString(name2, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(value3)\n");
				#endif

				native_object = new wxVariant_php(value3);

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(value3, wxString(name3, wxConvUTF8))\n");
				#endif

				native_object = new wxVariant_php(value3, wxString(name3, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload4_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((void*) value4)\n");
				#endif

				native_object = new wxVariant_php((void*) value4);

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((void*) value4, wxString(name4, wxConvUTF8))\n");
				#endif

				native_object = new wxVariant_php((void*) value4, wxString(name4, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload5_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxObject*) object_pointer5_0)\n");
				#endif

				native_object = new wxVariant_php((wxObject*) object_pointer5_0);

				native_object->references.Initialize();
				((wxVariant_php*) native_object)->references.AddReference(value5, "wxVariant::wxVariant at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxObject*) object_pointer5_0, wxString(name5, wxConvUTF8))\n");
				#endif

				native_object = new wxVariant_php((wxObject*) object_pointer5_0, wxString(name5, wxConvUTF8));

				native_object->references.Initialize();
				((wxVariant_php*) native_object)->references.AddReference(value5, "wxVariant::wxVariant at call with 2 argument(s)");
				break;
			}
		}
	}

	if(overload6_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxDateTime(val6))\n");
				#endif

				native_object = new wxVariant_php(wxDateTime(val6));

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxDateTime(val6), wxString(name6, wxConvUTF8))\n");
				#endif

				native_object = new wxVariant_php(wxDateTime(val6), wxString(name6, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload7_called)
	{
		wxArrayString strings_array7_0;
		bool strings_continue7_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index7_0 = 0;
				zval** temp_array_value7_0 = 0;
				while(strings_continue7_0)
				{
					if(zend_hash_index_find(HASH_OF(val7), array_index7_0, (void**)&temp_array_value7_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value7_0);
						strings_array7_0.Add(wxString(Z_STRVAL_PP(temp_array_value7_0), wxConvUTF8));
						array_index7_0++;
					}
					else
					{
						strings_continue7_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(strings_array7_0)\n");
				#endif

				native_object = new wxVariant_php(strings_array7_0);

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				int array_index7_0 = 0;
				zval** temp_array_value7_0 = 0;
				while(strings_continue7_0)
				{
					if(zend_hash_index_find(HASH_OF(val7), array_index7_0, (void**)&temp_array_value7_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value7_0);
						strings_array7_0.Add(wxString(Z_STRVAL_PP(temp_array_value7_0), wxConvUTF8));
						array_index7_0++;
					}
					else
					{
						strings_continue7_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(strings_array7_0, wxString(name7, wxConvUTF8))\n");
				#endif

				native_object = new wxVariant_php(strings_array7_0, wxString(name7, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload8_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxVariant*) object_pointer8_0)\n");
				#endif

				native_object = new wxVariant_php(*(wxVariant*) object_pointer8_0);

				native_object->references.Initialize();
				((wxVariant_php*) native_object)->references.AddReference(variant8, "wxVariant::wxVariant at call with 1 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxVariant*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxVariant::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxVariantData_free(void *object TSRMLS_DC) 
{
    zo_wxVariantData* custom_object = (zo_wxVariantData*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxVariantData_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxVariantData_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxVariantData_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxVariantData* custom_object;
    custom_object = (zo_wxVariantData*) emalloc(sizeof(zo_wxVariantData));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXVARIANTDATA_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxVariantData_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto wxVariantData wxVariantData::Clone()
   This function can be overridden to clone the data. */
PHP_METHOD(php_wxVariantData, CloneMethod)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariantData::Clone\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariantData* current_object;
	wxphp_object_type current_object_type;
	wxVariantData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariantData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariantData::Clone call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANTDATA_TYPE){
				references = &((wxVariantData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVariantData::Clone() to return object pointer\n\n");
				#endif

				wxVariantData_php* value_to_return0;
				value_to_return0 = (wxVariantData_php*) ((wxVariantData_php*)native_object)->Clone();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxVariantData_entry);
					((zo_wxVariantData*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxVariantData_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxVariantData::Clone at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariantData::Clone\n");
	}
}
/* }}} */

/* {{{ proto  wxVariantData::DecRef()
   Decreases reference count. */
PHP_METHOD(php_wxVariantData, DecRef)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariantData::DecRef\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariantData* current_object;
	wxphp_object_type current_object_type;
	wxVariantData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariantData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariantData::DecRef call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANTDATA_TYPE){
				references = &((wxVariantData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVariantData::DecRef()\n\n");
				#endif

				((wxVariantData_php*)native_object)->DecRef();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariantData::DecRef\n");
	}
}
/* }}} */

/* {{{ proto bool wxVariantData::Eq(wxVariantData &data)
   Returns true if this object is equal to data. */
bool wxVariantData_php::Eq(wxVariantData& data)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxVariantData::Eq\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "Eq", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxVariantData_entry);
	((zo_wxVariantData*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxVariantData_php*) &data;
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "Eq", 2, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxVariantData::Eq'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return Z_BVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto string wxVariantData::GetType()
   Returns the string type of the data. */
wxString wxVariantData_php::GetType()const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxVariantData::GetType\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetType", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetType", 7, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxVariantData::GetType'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return wxString(Z_STRVAL_P(return_value), wxConvUTF8);
	
}
/* }}} */

/* {{{ proto wxClassInfo wxVariantData::GetValueClassInfo()
   If the data is a wxObject returns a pointer to the objects wxClassInfo structure, if the data isn't a wxObject the method returns NULL. */
PHP_METHOD(php_wxVariantData, GetValueClassInfo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariantData::GetValueClassInfo\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariantData* current_object;
	wxphp_object_type current_object_type;
	wxVariantData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariantData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariantData::GetValueClassInfo call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANTDATA_TYPE){
				references = &((wxVariantData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVariantData::GetValueClassInfo() to return object pointer\n\n");
				#endif

				wxClassInfo_php* value_to_return0;
				value_to_return0 = (wxClassInfo_php*) ((wxVariantData_php*)native_object)->GetValueClassInfo();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxClassInfo_entry);
					((zo_wxClassInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxClassInfo_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxVariantData::GetValueClassInfo at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariantData::GetValueClassInfo\n");
	}
}
/* }}} */

/* {{{ proto  wxVariantData::IncRef()
   Increases reference count. */
PHP_METHOD(php_wxVariantData, IncRef)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariantData::IncRef\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariantData* current_object;
	wxphp_object_type current_object_type;
	wxVariantData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariantData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariantData::IncRef call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANTDATA_TYPE){
				references = &((wxVariantData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxVariantData::IncRef()\n\n");
				#endif

				((wxVariantData_php*)native_object)->IncRef();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariantData::IncRef\n");
	}
}
/* }}} */

/* {{{ proto bool wxVariantData::Read(string &string)
   Reads the data from string. */
PHP_METHOD(php_wxVariantData, Read)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariantData::Read\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariantData* current_object;
	wxphp_object_type current_object_type;
	wxVariantData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariantData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariantData::Read call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANTDATA_TYPE){
				references = &((wxVariantData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	zval* string0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&string0, &string_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &string0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				wxString string_arg0_0 = wxString(string0, wxConvUTF8);
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVariantData::Read(string_arg0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxVariantData_php*)native_object)->Read(string_arg0_0));

				char* temp_string0_0;
				temp_string0_0 = (char*)malloc(sizeof(wxChar)*(string_arg0_0.size()+1));
				strcpy (temp_string0_0, (const char *) string_arg0_0.char_str() );
				ZVAL_STRING(string0_ref, (char*) temp_string0_0, 1);
				free(temp_string0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariantData::Read\n");
	}
}
/* }}} */

/* {{{ proto bool wxVariantData::Write(string &string)
   Writes the data to string. */
PHP_METHOD(php_wxVariantData, Write)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariantData::Write\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariantData* current_object;
	wxphp_object_type current_object_type;
	wxVariantData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVariantData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVariantData::Write call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVARIANTDATA_TYPE){
				references = &((wxVariantData_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* string0;
	long string_len0;
	zval* string0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&string0, &string_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &string0, &string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &string0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				wxString string_arg0_0 = wxString(string0, wxConvUTF8);
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVariantData::Write(string_arg0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxVariantData_php*)native_object)->Write(string_arg0_0));

				char* temp_string0_0;
				temp_string0_0 = (char*)malloc(sizeof(wxChar)*(string_arg0_0.size()+1));
				strcpy (temp_string0_0, (const char *) string_arg0_0.char_str() );
				ZVAL_STRING(string0_ref, (char*) temp_string0_0, 1);
				free(temp_string0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVariantData::Write\n");
	}
}
/* }}} */

/* {{{ proto  wxVariantData::wxVariantData()
   Default constructor. */
PHP_METHOD(php_wxVariantData, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVariantData::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVariantData* current_object;
	wxVariantData_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxVariantData_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxVariantData*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxVariantData::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxVersionInfo_free(void *object TSRMLS_DC) 
{
    zo_wxVersionInfo* custom_object = (zo_wxVersionInfo*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxVersionInfo_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxVersionInfo done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxVersionInfo_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxVersionInfo_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxVersionInfo* custom_object;
    custom_object = (zo_wxVersionInfo*) emalloc(sizeof(zo_wxVersionInfo));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXVERSIONINFO_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxVersionInfo_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto string wxVersionInfo::ToString()
   Get the string representation of this version object. */
PHP_METHOD(php_wxVersionInfo, ToString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVersionInfo::ToString\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVersionInfo* current_object;
	wxphp_object_type current_object_type;
	wxVersionInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVersionInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVersionInfo::ToString call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVERSIONINFO_TYPE){
				references = &((wxVersionInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxVersionInfo::ToString().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxVersionInfo_php*)native_object)->ToString();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVersionInfo::ToString\n");
	}
}
/* }}} */

/* {{{ proto bool wxVersionInfo::HasCopyright()
   Returns true if a copyright string has been specified. */
PHP_METHOD(php_wxVersionInfo, HasCopyright)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVersionInfo::HasCopyright\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVersionInfo* current_object;
	wxphp_object_type current_object_type;
	wxVersionInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVersionInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVersionInfo::HasCopyright call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVERSIONINFO_TYPE){
				references = &((wxVersionInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVersionInfo::HasCopyright())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxVersionInfo_php*)native_object)->HasCopyright());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVersionInfo::HasCopyright\n");
	}
}
/* }}} */

/* {{{ proto string wxVersionInfo::GetVersionString()
   Get the string representation. */
PHP_METHOD(php_wxVersionInfo, GetVersionString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVersionInfo::GetVersionString\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVersionInfo* current_object;
	wxphp_object_type current_object_type;
	wxVersionInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVersionInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVersionInfo::GetVersionString call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVERSIONINFO_TYPE){
				references = &((wxVersionInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxVersionInfo::GetVersionString().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxVersionInfo_php*)native_object)->GetVersionString();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVersionInfo::GetVersionString\n");
	}
}
/* }}} */

/* {{{ proto string wxVersionInfo::GetName()
   Get the name of the object (library). */
PHP_METHOD(php_wxVersionInfo, GetName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVersionInfo::GetName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVersionInfo* current_object;
	wxphp_object_type current_object_type;
	wxVersionInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVersionInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVersionInfo::GetName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVERSIONINFO_TYPE){
				references = &((wxVersionInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxVersionInfo::GetName().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxVersionInfo_php*)native_object)->GetName();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVersionInfo::GetName\n");
	}
}
/* }}} */

/* {{{ proto int wxVersionInfo::GetMinor()
   Get the minor version number. */
PHP_METHOD(php_wxVersionInfo, GetMinor)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVersionInfo::GetMinor\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVersionInfo* current_object;
	wxphp_object_type current_object_type;
	wxVersionInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVersionInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVersionInfo::GetMinor call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVERSIONINFO_TYPE){
				references = &((wxVersionInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxVersionInfo::GetMinor())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxVersionInfo_php*)native_object)->GetMinor());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVersionInfo::GetMinor\n");
	}
}
/* }}} */

/* {{{ proto int wxVersionInfo::GetMicro()
   Get the micro version, or release number. */
PHP_METHOD(php_wxVersionInfo, GetMicro)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVersionInfo::GetMicro\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVersionInfo* current_object;
	wxphp_object_type current_object_type;
	wxVersionInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVersionInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVersionInfo::GetMicro call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVERSIONINFO_TYPE){
				references = &((wxVersionInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxVersionInfo::GetMicro())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxVersionInfo_php*)native_object)->GetMicro());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVersionInfo::GetMicro\n");
	}
}
/* }}} */

/* {{{ proto int wxVersionInfo::GetMajor()
   Get the major version number. */
PHP_METHOD(php_wxVersionInfo, GetMajor)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVersionInfo::GetMajor\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVersionInfo* current_object;
	wxphp_object_type current_object_type;
	wxVersionInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVersionInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVersionInfo::GetMajor call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVERSIONINFO_TYPE){
				references = &((wxVersionInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxVersionInfo::GetMajor())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxVersionInfo_php*)native_object)->GetMajor());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVersionInfo::GetMajor\n");
	}
}
/* }}} */

/* {{{ proto string wxVersionInfo::GetDescription()
   Get the description string. */
PHP_METHOD(php_wxVersionInfo, GetDescription)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVersionInfo::GetDescription\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVersionInfo* current_object;
	wxphp_object_type current_object_type;
	wxVersionInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVersionInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVersionInfo::GetDescription call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVERSIONINFO_TYPE){
				references = &((wxVersionInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxVersionInfo::GetDescription().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxVersionInfo_php*)native_object)->GetDescription();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVersionInfo::GetDescription\n");
	}
}
/* }}} */

/* {{{ proto string wxVersionInfo::GetCopyright()
   Get the copyright string. */
PHP_METHOD(php_wxVersionInfo, GetCopyright)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVersionInfo::GetCopyright\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVersionInfo* current_object;
	wxphp_object_type current_object_type;
	wxVersionInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVersionInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVersionInfo::GetCopyright call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVERSIONINFO_TYPE){
				references = &((wxVersionInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxVersionInfo::GetCopyright().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxVersionInfo_php*)native_object)->GetCopyright();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVersionInfo::GetCopyright\n");
	}
}
/* }}} */

/* {{{ proto  wxVersionInfo::wxVersionInfo(string name, int major, int minor, int micro, string description, string copyright)
   Constructor. */
PHP_METHOD(php_wxVersionInfo, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVersionInfo::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVersionInfo* current_object;
	wxVersionInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	long major0;
	long minor0;
	long micro0;
	char* description0;
	long description_len0;
	char* copyright0;
	long copyright_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|slllss' (&name0, &name_len0, &major0, &minor0, &micro0, &description0, &description_len0, &copyright0, &copyright_len0)\n");
		#endif

		char parse_parameters_string[] = "|slllss";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0, &major0, &minor0, &micro0, &description0, &description_len0, &copyright0, &copyright_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxVersionInfo_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name0, wxConvUTF8))\n");
				#endif

				native_object = new wxVersionInfo_php(wxString(name0, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name0, wxConvUTF8), (int) major0)\n");
				#endif

				native_object = new wxVersionInfo_php(wxString(name0, wxConvUTF8), (int) major0);

				native_object->references.Initialize();
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name0, wxConvUTF8), (int) major0, (int) minor0)\n");
				#endif

				native_object = new wxVersionInfo_php(wxString(name0, wxConvUTF8), (int) major0, (int) minor0);

				native_object->references.Initialize();
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name0, wxConvUTF8), (int) major0, (int) minor0, (int) micro0)\n");
				#endif

				native_object = new wxVersionInfo_php(wxString(name0, wxConvUTF8), (int) major0, (int) minor0, (int) micro0);

				native_object->references.Initialize();
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name0, wxConvUTF8), (int) major0, (int) minor0, (int) micro0, wxString(description0, wxConvUTF8))\n");
				#endif

				native_object = new wxVersionInfo_php(wxString(name0, wxConvUTF8), (int) major0, (int) minor0, (int) micro0, wxString(description0, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name0, wxConvUTF8), (int) major0, (int) minor0, (int) micro0, wxString(description0, wxConvUTF8), wxString(copyright0, wxConvUTF8))\n");
				#endif

				native_object = new wxVersionInfo_php(wxString(name0, wxConvUTF8), (int) major0, (int) minor0, (int) micro0, wxString(description0, wxConvUTF8), wxString(copyright0, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxVersionInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxVersionInfo::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto bool wxVersionInfo::HasDescription()
   Return true if a description string has been specified. */
PHP_METHOD(php_wxVersionInfo, HasDescription)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxVersionInfo::HasDescription\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxVersionInfo* current_object;
	wxphp_object_type current_object_type;
	wxVersionInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxVersionInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxVersionInfo::HasDescription call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXVERSIONINFO_TYPE){
				references = &((wxVersionInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxVersionInfo::HasDescription())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxVersionInfo_php*)native_object)->HasDescription());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxVersionInfo::HasDescription\n");
	}
}
/* }}} */

