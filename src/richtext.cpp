/*
 * @author Mário Soares
 * @contributors Jefferson González
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "webview.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


BEGIN_EXTERN_C()
void php_wxTextAttr_free(void *object TSRMLS_DC) 
{
    zo_wxTextAttr* custom_object = (zo_wxTextAttr*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTextAttr_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxTextAttr done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxTextAttr_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTextAttr_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxTextAttr* custom_object;
    custom_object = (zo_wxTextAttr*) emalloc(sizeof(zo_wxTextAttr));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXTEXTATTR_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxTextAttr_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxTextAttr::wxTextAttr(wxTextAttr attr)
   Constructors. */
PHP_METHOD(php_wxTextAttr, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* attr0 = 0;
	wxTextAttr* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* colText1 = 0;
	wxColour* object_pointer1_0 = 0;
	zval* colBack1 = 0;
	wxColour* object_pointer1_1 = 0;
	zval* font1 = 0;
	wxFont* object_pointer1_2 = 0;
	long alignment1;
	bool overload1_called = false;
	//Parameters for overload 2
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&attr0, php_wxTextAttr_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &attr0, php_wxTextAttr_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(attr0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxTextAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxTextAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxTextAttr*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(attr0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|OOl' (&colText1, php_wxColour_entry, &colBack1, php_wxColour_entry, &font1, php_wxFont_entry, &alignment1)\n");
		#endif

		char parse_parameters_string[] = "O|OOl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colText1, php_wxColour_entry, &colBack1, php_wxColour_entry, &font1, php_wxFont_entry, &alignment1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colText1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colText1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colText1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxColour*) argument_native_object;
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(colText1) != IS_NULL)
				{
					goto overload2;
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(colBack1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colBack1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colBack1 TSRMLS_CC))->native_object;
					object_pointer1_1 = (wxColour*) argument_native_object;
					if (!object_pointer1_1 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(colBack1) != IS_NULL)
				{
					goto overload2;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(font1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font1 TSRMLS_CC))->native_object;
					object_pointer1_2 = (wxFont*) argument_native_object;
					if (!object_pointer1_2 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(font1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload2_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxTextAttr*) object_pointer0_0)\n");
				#endif

				native_object = new wxTextAttr_php(*(wxTextAttr*) object_pointer0_0);

				native_object->references.Initialize();
				((wxTextAttr_php*) native_object)->references.AddReference(attr0, "wxTextAttr::wxTextAttr at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer1_0)\n");
				#endif

				native_object = new wxTextAttr_php(*(wxColour*) object_pointer1_0);

				native_object->references.Initialize();
				((wxTextAttr_php*) native_object)->references.AddReference(colText1, "wxTextAttr::wxTextAttr at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1)\n");
				#endif

				native_object = new wxTextAttr_php(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1);

				native_object->references.Initialize();
				((wxTextAttr_php*) native_object)->references.AddReference(colText1, "wxTextAttr::wxTextAttr at call with 2 argument(s)");
				((wxTextAttr_php*) native_object)->references.AddReference(colBack1, "wxTextAttr::wxTextAttr at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1, *(wxFont*) object_pointer1_2)\n");
				#endif

				native_object = new wxTextAttr_php(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1, *(wxFont*) object_pointer1_2);

				native_object->references.Initialize();
				((wxTextAttr_php*) native_object)->references.AddReference(colText1, "wxTextAttr::wxTextAttr at call with 3 argument(s)");
				((wxTextAttr_php*) native_object)->references.AddReference(colBack1, "wxTextAttr::wxTextAttr at call with 3 argument(s)");
				((wxTextAttr_php*) native_object)->references.AddReference(font1, "wxTextAttr::wxTextAttr at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1, *(wxFont*) object_pointer1_2, (wxTextAttrAlignment) alignment1)\n");
				#endif

				native_object = new wxTextAttr_php(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1, *(wxFont*) object_pointer1_2, (wxTextAttrAlignment) alignment1);

				native_object->references.Initialize();
				((wxTextAttr_php*) native_object)->references.AddReference(colText1, "wxTextAttr::wxTextAttr at call with 4 argument(s)");
				((wxTextAttr_php*) native_object)->references.AddReference(colBack1, "wxTextAttr::wxTextAttr at call with 4 argument(s)");
				((wxTextAttr_php*) native_object)->references.AddReference(font1, "wxTextAttr::wxTextAttr at call with 4 argument(s)");
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxTextAttr_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxTextAttr::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxTextAttr::SetURL(string url)
   Sets the URL for the content. */
PHP_METHOD(php_wxTextAttr, SetURL)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetURL\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetURL call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* url0;
	long url_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&url0, &url_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &url0, &url_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetURL(wxString(url0, wxConvUTF8))\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetURL(wxString(url0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetURL\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetTextEffects(int effects)
   Sets the text effects, a bit list of styles. */
PHP_METHOD(php_wxTextAttr, SetTextEffects)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetTextEffects\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetTextEffects call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long effects0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&effects0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &effects0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetTextEffects((int) effects0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetTextEffects((int) effects0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetTextEffects\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetTextEffectFlags(int flags)
   Sets the text effect bits of interest. */
PHP_METHOD(php_wxTextAttr, SetTextEffectFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetTextEffectFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetTextEffectFlags call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flags0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetTextEffectFlags((int) flags0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetTextEffectFlags((int) flags0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetTextEffectFlags\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetTextColour(wxColour colText)
   Sets the text foreground colour. */
PHP_METHOD(php_wxTextAttr, SetTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colText0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colText0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colText0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colText0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colText0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colText0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colText' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colText0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colText' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetTextColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetTextColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colText0, "wxTextAttr::SetTextColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetTextColour\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetRightIndent(int indent)
   Sets the right indent in tenths of a millimetre. */
PHP_METHOD(php_wxTextAttr, SetRightIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetRightIndent\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetRightIndent call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long indent0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&indent0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &indent0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetRightIndent((int) indent0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetRightIndent((int) indent0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetRightIndent\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetParagraphStyleName(string name)
   Sets the name of the paragraph style. */
PHP_METHOD(php_wxTextAttr, SetParagraphStyleName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetParagraphStyleName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetParagraphStyleName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetParagraphStyleName(wxString(name0, wxConvUTF8))\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetParagraphStyleName(wxString(name0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetParagraphStyleName\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetParagraphSpacingBefore(int spacing)
   Sets the spacing before a paragraph, in tenths of a millimetre. */
PHP_METHOD(php_wxTextAttr, SetParagraphSpacingBefore)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetParagraphSpacingBefore\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetParagraphSpacingBefore call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long spacing0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&spacing0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &spacing0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetParagraphSpacingBefore((int) spacing0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetParagraphSpacingBefore((int) spacing0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetParagraphSpacingBefore\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetParagraphSpacingAfter(int spacing)
   Sets the spacing after a paragraph, in tenths of a millimetre. */
PHP_METHOD(php_wxTextAttr, SetParagraphSpacingAfter)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetParagraphSpacingAfter\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetParagraphSpacingAfter call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long spacing0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&spacing0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &spacing0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetParagraphSpacingAfter((int) spacing0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetParagraphSpacingAfter((int) spacing0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetParagraphSpacingAfter\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetOutlineLevel(int level)
   Specifies the outline level. */
PHP_METHOD(php_wxTextAttr, SetOutlineLevel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetOutlineLevel\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetOutlineLevel call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long level0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&level0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &level0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetOutlineLevel((int) level0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetOutlineLevel((int) level0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetOutlineLevel\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetListStyleName(string name)
   Sets the list style name. */
PHP_METHOD(php_wxTextAttr, SetListStyleName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetListStyleName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetListStyleName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetListStyleName(wxString(name0, wxConvUTF8))\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetListStyleName(wxString(name0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetListStyleName\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetLineSpacing(int spacing)
   Sets the line spacing. */
PHP_METHOD(php_wxTextAttr, SetLineSpacing)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetLineSpacing\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetLineSpacing call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long spacing0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&spacing0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &spacing0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetLineSpacing((int) spacing0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetLineSpacing((int) spacing0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetLineSpacing\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetLeftIndent(int indent, int subIndent)
   Sets the left indent and left subindent in tenths of a millimetre. */
PHP_METHOD(php_wxTextAttr, SetLeftIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetLeftIndent\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetLeftIndent call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long indent0;
	long subIndent0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|l' (&indent0, &subIndent0)\n");
		#endif

		char parse_parameters_string[] = "l|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &indent0, &subIndent0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetLeftIndent((int) indent0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetLeftIndent((int) indent0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetLeftIndent((int) indent0, (int) subIndent0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetLeftIndent((int) indent0, (int) subIndent0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetLeftIndent\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetFontWeight(wxFontWeight fontWeight)
   Sets the font weight. */
PHP_METHOD(php_wxTextAttr, SetFontWeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetFontWeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetFontWeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long fontWeight0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&fontWeight0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &fontWeight0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetFontWeight((wxFontWeight) fontWeight0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetFontWeight((wxFontWeight) fontWeight0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetFontWeight\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetFontUnderlined(bool underlined)
   Sets the font underlining. */
PHP_METHOD(php_wxTextAttr, SetFontUnderlined)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetFontUnderlined\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetFontUnderlined call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool underlined0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&underlined0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &underlined0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetFontUnderlined(underlined0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetFontUnderlined(underlined0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetFontUnderlined\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetFontStyle(wxFontStyle fontStyle)
   Sets the font style (normal, italic or slanted). */
PHP_METHOD(php_wxTextAttr, SetFontStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetFontStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetFontStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long fontStyle0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&fontStyle0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &fontStyle0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetFontStyle((wxFontStyle) fontStyle0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetFontStyle((wxFontStyle) fontStyle0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetFontStyle\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetFontSize(int pointSize)
   Sets the font size in points. */
PHP_METHOD(php_wxTextAttr, SetFontSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetFontSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetFontSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pointSize0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pointSize0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pointSize0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetFontSize((int) pointSize0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetFontSize((int) pointSize0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetFontSize\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::Apply(wxTextAttr style, wxTextAttr compareWith)
   Applies the attributes in style to the original object, but not those attributes from style that are the same as those in compareWith (if passed). */
PHP_METHOD(php_wxTextAttr, Apply)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::Apply\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::Apply call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* style0 = 0;
	wxTextAttr* object_pointer0_0 = 0;
	zval* compareWith0 = 0;
	wxTextAttr* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|z' (&style0, php_wxTextAttr_entry, &compareWith0)\n");
		#endif

		char parse_parameters_string[] = "O|z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0, php_wxTextAttr_entry, &compareWith0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(style0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxTextAttr*) zend_object_store_get_object(style0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxTextAttr*) zend_object_store_get_object(style0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxTextAttr*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'style' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(style0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'style' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(compareWith0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxTextAttr*) zend_object_store_get_object(compareWith0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxTextAttr*) zend_object_store_get_object(compareWith0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxTextAttr*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXTEXTATTR_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'compareWith' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(compareWith0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'compareWith' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::Apply(*(wxTextAttr*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->Apply(*(wxTextAttr*) object_pointer0_0));

				references->AddReference(style0, "wxTextAttr::Apply at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::Apply(*(wxTextAttr*) object_pointer0_0, (const wxTextAttr*) object_pointer0_1))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->Apply(*(wxTextAttr*) object_pointer0_0, (const wxTextAttr*) object_pointer0_1));

				references->AddReference(style0, "wxTextAttr::Apply at call with 2 argument(s)");
				references->AddReference(compareWith0, "wxTextAttr::Apply at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::Apply\n");
	}
}
/* }}} */

/* {{{ proto wxTextAttrAlignment wxTextAttr::GetAlignment()
   Returns the alignment flags. */
PHP_METHOD(php_wxTextAttr, GetAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetAlignment())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetAlignment());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetAlignment\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxTextAttr::GetBackgroundColour()
   Returns the background colour. */
PHP_METHOD(php_wxTextAttr, GetBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::GetBackgroundColour() to return object reference\n\n");
				#endif

				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxTextAttr_php*)native_object)->GetBackgroundColour();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxTextAttr::GetBackgroundColour at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto string wxTextAttr::GetBulletFont()
   Returns a string containing the name of the font associated with the bullet symbol. */
PHP_METHOD(php_wxTextAttr, GetBulletFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetBulletFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetBulletFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextAttr::GetBulletFont().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxTextAttr_php*)native_object)->GetBulletFont();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetBulletFont\n");
	}
}
/* }}} */

/* {{{ proto string wxTextAttr::GetBulletName()
   Returns the standard bullet name, applicable if the bullet style is wxTEXT_ATTR_BULLET_STYLE_STANDARD. */
PHP_METHOD(php_wxTextAttr, GetBulletName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetBulletName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetBulletName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextAttr::GetBulletName().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxTextAttr_php*)native_object)->GetBulletName();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetBulletName\n");
	}
}
/* }}} */

/* {{{ proto int wxTextAttr::GetBulletNumber()
   Returns the bullet number. */
PHP_METHOD(php_wxTextAttr, GetBulletNumber)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetBulletNumber\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetBulletNumber call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetBulletNumber())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetBulletNumber());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetBulletNumber\n");
	}
}
/* }}} */

/* {{{ proto int wxTextAttr::GetBulletStyle()
   Returns the bullet style. */
PHP_METHOD(php_wxTextAttr, GetBulletStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetBulletStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetBulletStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetBulletStyle())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetBulletStyle());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetBulletStyle\n");
	}
}
/* }}} */

/* {{{ proto string wxTextAttr::GetBulletText()
   Returns the bullet text, which could be a symbol, or (for example) cached outline text. */
PHP_METHOD(php_wxTextAttr, GetBulletText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetBulletText\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetBulletText call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextAttr::GetBulletText().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxTextAttr_php*)native_object)->GetBulletText();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetBulletText\n");
	}
}
/* }}} */

/* {{{ proto string wxTextAttr::GetCharacterStyleName()
   Returns the name of the character style. */
PHP_METHOD(php_wxTextAttr, GetCharacterStyleName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetCharacterStyleName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetCharacterStyleName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextAttr::GetCharacterStyleName().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxTextAttr_php*)native_object)->GetCharacterStyleName();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetCharacterStyleName\n");
	}
}
/* }}} */

/* {{{ proto int wxTextAttr::GetFlags()
   Returns flags indicating which attributes are applicable. */
PHP_METHOD(php_wxTextAttr, GetFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetFlags call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetFlags())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetFlags());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetFlags\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxTextAttr::GetFont()
   Creates and returns a font specified by the font attributes in the wxTextAttr object. */
PHP_METHOD(php_wxTextAttr, GetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::GetFont() to return new object\n\n");
				#endif

				wxFont value_to_return0;
				value_to_return0 = ((wxTextAttr_php*)native_object)->GetFont();
				void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxFont));
				object_init_ex(return_value, php_wxFont_entry);
				((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetFont\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::GetFontAttributes(wxFont font, int flags)
   Gets the font attributes from the given font, using only the attributes specified by flags. */
PHP_METHOD(php_wxTextAttr, GetFontAttributes)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetFontAttributes\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetFontAttributes call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* font0 = 0;
	wxFont* object_pointer0_0 = 0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&font0, php_wxFont_entry, &flags0)\n");
		#endif

		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry, &flags0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxFont*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::GetFontAttributes(*(wxFont*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->GetFontAttributes(*(wxFont*) object_pointer0_0));

				references->AddReference(font0, "wxTextAttr::GetFontAttributes at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::GetFontAttributes(*(wxFont*) object_pointer0_0, (int) flags0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->GetFontAttributes(*(wxFont*) object_pointer0_0, (int) flags0));

				references->AddReference(font0, "wxTextAttr::GetFontAttributes at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetFontAttributes\n");
	}
}
/* }}} */

/* {{{ proto wxFontEncoding wxTextAttr::GetFontEncoding()
   Returns the font encoding. */
PHP_METHOD(php_wxTextAttr, GetFontEncoding)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetFontEncoding\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetFontEncoding call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetFontEncoding())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetFontEncoding());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetFontEncoding\n");
	}
}
/* }}} */

/* {{{ proto string wxTextAttr::GetFontFaceName()
   Returns the font face name. */
PHP_METHOD(php_wxTextAttr, GetFontFaceName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetFontFaceName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetFontFaceName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextAttr::GetFontFaceName().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxTextAttr_php*)native_object)->GetFontFaceName();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetFontFaceName\n");
	}
}
/* }}} */

/* {{{ proto wxFontFamily wxTextAttr::GetFontFamily()
   Returns the font family. */
PHP_METHOD(php_wxTextAttr, GetFontFamily)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetFontFamily\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetFontFamily call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetFontFamily())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetFontFamily());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetFontFamily\n");
	}
}
/* }}} */

/* {{{ proto int wxTextAttr::GetFontSize()
   Returns the font size in points. */
PHP_METHOD(php_wxTextAttr, GetFontSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetFontSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetFontSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetFontSize())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetFontSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetFontSize\n");
	}
}
/* }}} */

/* {{{ proto wxFontStyle wxTextAttr::GetFontStyle()
   Returns the font style. */
PHP_METHOD(php_wxTextAttr, GetFontStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetFontStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetFontStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetFontStyle())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetFontStyle());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetFontStyle\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::GetFontUnderlined()
   Returns true if the font is underlined. */
PHP_METHOD(php_wxTextAttr, GetFontUnderlined)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetFontUnderlined\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetFontUnderlined call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::GetFontUnderlined())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->GetFontUnderlined());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetFontUnderlined\n");
	}
}
/* }}} */

/* {{{ proto wxFontWeight wxTextAttr::GetFontWeight()
   Returns the font weight. */
PHP_METHOD(php_wxTextAttr, GetFontWeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetFontWeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetFontWeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetFontWeight())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetFontWeight());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetFontWeight\n");
	}
}
/* }}} */

/* {{{ proto int wxTextAttr::GetLeftIndent()
   Returns the left indent in tenths of a millimetre. */
PHP_METHOD(php_wxTextAttr, GetLeftIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetLeftIndent\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetLeftIndent call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetLeftIndent())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetLeftIndent());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetLeftIndent\n");
	}
}
/* }}} */

/* {{{ proto int wxTextAttr::GetLeftSubIndent()
   Returns the left sub-indent in tenths of a millimetre. */
PHP_METHOD(php_wxTextAttr, GetLeftSubIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetLeftSubIndent\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetLeftSubIndent call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetLeftSubIndent())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetLeftSubIndent());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetLeftSubIndent\n");
	}
}
/* }}} */

/* {{{ proto int wxTextAttr::GetLineSpacing()
   Returns the line spacing value, one of wxTextAttrLineSpacing values. */
PHP_METHOD(php_wxTextAttr, GetLineSpacing)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetLineSpacing\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetLineSpacing call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetLineSpacing())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetLineSpacing());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetLineSpacing\n");
	}
}
/* }}} */

/* {{{ proto string wxTextAttr::GetListStyleName()
   Returns the name of the list style. */
PHP_METHOD(php_wxTextAttr, GetListStyleName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetListStyleName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetListStyleName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextAttr::GetListStyleName().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxTextAttr_php*)native_object)->GetListStyleName();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetListStyleName\n");
	}
}
/* }}} */

/* {{{ proto int wxTextAttr::GetOutlineLevel()
   Returns the outline level. */
PHP_METHOD(php_wxTextAttr, GetOutlineLevel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetOutlineLevel\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetOutlineLevel call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetOutlineLevel())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetOutlineLevel());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetOutlineLevel\n");
	}
}
/* }}} */

/* {{{ proto int wxTextAttr::GetParagraphSpacingAfter()
   Returns the space in tenths of a millimeter after the paragraph. */
PHP_METHOD(php_wxTextAttr, GetParagraphSpacingAfter)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetParagraphSpacingAfter\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetParagraphSpacingAfter call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetParagraphSpacingAfter())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetParagraphSpacingAfter());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetParagraphSpacingAfter\n");
	}
}
/* }}} */

/* {{{ proto int wxTextAttr::GetParagraphSpacingBefore()
   Returns the space in tenths of a millimeter before the paragraph. */
PHP_METHOD(php_wxTextAttr, GetParagraphSpacingBefore)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetParagraphSpacingBefore\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetParagraphSpacingBefore call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetParagraphSpacingBefore())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetParagraphSpacingBefore());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetParagraphSpacingBefore\n");
	}
}
/* }}} */

/* {{{ proto string wxTextAttr::GetParagraphStyleName()
   Returns the name of the paragraph style. */
PHP_METHOD(php_wxTextAttr, GetParagraphStyleName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetParagraphStyleName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetParagraphStyleName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextAttr::GetParagraphStyleName().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxTextAttr_php*)native_object)->GetParagraphStyleName();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetParagraphStyleName\n");
	}
}
/* }}} */

/* {{{ proto int wxTextAttr::GetRightIndent()
   Returns the right indent in tenths of a millimeter. */
PHP_METHOD(php_wxTextAttr, GetRightIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetRightIndent\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetRightIndent call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetRightIndent())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetRightIndent());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetRightIndent\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxTextAttr::GetTextColour()
   Returns the text foreground colour. */
PHP_METHOD(php_wxTextAttr, GetTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::GetTextColour() to return object reference\n\n");
				#endif

				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxTextAttr_php*)native_object)->GetTextColour();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxTextAttr::GetTextColour at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetTextColour\n");
	}
}
/* }}} */

/* {{{ proto int wxTextAttr::GetTextEffectFlags()
   Returns the text effect bits of interest. */
PHP_METHOD(php_wxTextAttr, GetTextEffectFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetTextEffectFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetTextEffectFlags call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetTextEffectFlags())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetTextEffectFlags());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetTextEffectFlags\n");
	}
}
/* }}} */

/* {{{ proto int wxTextAttr::GetTextEffects()
   Returns the text effects, a bit list of styles. */
PHP_METHOD(php_wxTextAttr, GetTextEffects)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetTextEffects\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetTextEffects call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxTextAttr::GetTextEffects())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxTextAttr_php*)native_object)->GetTextEffects());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetTextEffects\n");
	}
}
/* }}} */

/* {{{ proto string wxTextAttr::GetURL()
   Returns the URL for the content. */
PHP_METHOD(php_wxTextAttr, GetURL)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::GetURL\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::GetURL call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxTextAttr::GetURL().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxTextAttr_php*)native_object)->GetURL();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::GetURL\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasAlignment()
   Returns true if the attribute object specifies alignment. */
PHP_METHOD(php_wxTextAttr, HasAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasAlignment())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasAlignment());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasAlignment\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasBackgroundColour()
   Returns true if the attribute object specifies a background colour. */
PHP_METHOD(php_wxTextAttr, HasBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasBackgroundColour())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasBackgroundColour());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasBulletName()
   Returns true if the attribute object specifies a standard bullet name. */
PHP_METHOD(php_wxTextAttr, HasBulletName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasBulletName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasBulletName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasBulletName())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasBulletName());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasBulletName\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasBulletNumber()
   Returns true if the attribute object specifies a bullet number. */
PHP_METHOD(php_wxTextAttr, HasBulletNumber)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasBulletNumber\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasBulletNumber call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasBulletNumber())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasBulletNumber());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasBulletNumber\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasBulletStyle()
   Returns true if the attribute object specifies a bullet style. */
PHP_METHOD(php_wxTextAttr, HasBulletStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasBulletStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasBulletStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasBulletStyle())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasBulletStyle());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasBulletStyle\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasBulletText()
   Returns true if the attribute object specifies bullet text (usually specifying a symbol). */
PHP_METHOD(php_wxTextAttr, HasBulletText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasBulletText\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasBulletText call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasBulletText())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasBulletText());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasBulletText\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasCharacterStyleName()
   Returns true if the attribute object specifies a character style name. */
PHP_METHOD(php_wxTextAttr, HasCharacterStyleName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasCharacterStyleName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasCharacterStyleName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasCharacterStyleName())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasCharacterStyleName());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasCharacterStyleName\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasFlag(int flag)
   Returns true if the flag is present in the attribute object's flag bitlist. */
PHP_METHOD(php_wxTextAttr, HasFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasFlag\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasFlag call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flag0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasFlag((long) flag0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasFlag((long) flag0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasFlag\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasFont()
   Returns true if the attribute object specifies any font attributes. */
PHP_METHOD(php_wxTextAttr, HasFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasFont())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasFont());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasFont\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasFontEncoding()
   Returns true if the attribute object specifies an encoding. */
PHP_METHOD(php_wxTextAttr, HasFontEncoding)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasFontEncoding\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasFontEncoding call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasFontEncoding())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasFontEncoding());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasFontEncoding\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasFontFaceName()
   Returns true if the attribute object specifies a font face name. */
PHP_METHOD(php_wxTextAttr, HasFontFaceName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasFontFaceName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasFontFaceName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasFontFaceName())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasFontFaceName());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasFontFaceName\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasFontFamily()
   Returns true if the attribute object specifies a font family. */
PHP_METHOD(php_wxTextAttr, HasFontFamily)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasFontFamily\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasFontFamily call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasFontFamily())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasFontFamily());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasFontFamily\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasFontItalic()
   Returns true if the attribute object specifies italic style. */
PHP_METHOD(php_wxTextAttr, HasFontItalic)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasFontItalic\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasFontItalic call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasFontItalic())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasFontItalic());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasFontItalic\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasFontSize()
   Returns true if the attribute object specifies a font point size. */
PHP_METHOD(php_wxTextAttr, HasFontSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasFontSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasFontSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasFontSize())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasFontSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasFontSize\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasFontUnderlined()
   Returns true if the attribute object specifies either underlining or no underlining. */
PHP_METHOD(php_wxTextAttr, HasFontUnderlined)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasFontUnderlined\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasFontUnderlined call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasFontUnderlined())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasFontUnderlined());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasFontUnderlined\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasFontWeight()
   Returns true if the attribute object specifies font weight (bold, light or normal). */
PHP_METHOD(php_wxTextAttr, HasFontWeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasFontWeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasFontWeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasFontWeight())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasFontWeight());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasFontWeight\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasLeftIndent()
   Returns true if the attribute object specifies a left indent. */
PHP_METHOD(php_wxTextAttr, HasLeftIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasLeftIndent\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasLeftIndent call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasLeftIndent())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasLeftIndent());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasLeftIndent\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasLineSpacing()
   Returns true if the attribute object specifies line spacing. */
PHP_METHOD(php_wxTextAttr, HasLineSpacing)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasLineSpacing\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasLineSpacing call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasLineSpacing())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasLineSpacing());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasLineSpacing\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasListStyleName()
   Returns true if the attribute object specifies a list style name. */
PHP_METHOD(php_wxTextAttr, HasListStyleName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasListStyleName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasListStyleName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasListStyleName())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasListStyleName());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasListStyleName\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasOutlineLevel()
   Returns true if the attribute object specifies an outline level. */
PHP_METHOD(php_wxTextAttr, HasOutlineLevel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasOutlineLevel\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasOutlineLevel call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasOutlineLevel())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasOutlineLevel());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasOutlineLevel\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasPageBreak()
   Returns true if the attribute object specifies a page break before this paragraph. */
PHP_METHOD(php_wxTextAttr, HasPageBreak)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasPageBreak\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasPageBreak call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasPageBreak())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasPageBreak());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasPageBreak\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasParagraphSpacingAfter()
   Returns true if the attribute object specifies spacing after a paragraph. */
PHP_METHOD(php_wxTextAttr, HasParagraphSpacingAfter)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasParagraphSpacingAfter\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasParagraphSpacingAfter call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasParagraphSpacingAfter())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasParagraphSpacingAfter());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasParagraphSpacingAfter\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasParagraphSpacingBefore()
   Returns true if the attribute object specifies spacing before a paragraph. */
PHP_METHOD(php_wxTextAttr, HasParagraphSpacingBefore)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasParagraphSpacingBefore\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasParagraphSpacingBefore call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasParagraphSpacingBefore())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasParagraphSpacingBefore());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasParagraphSpacingBefore\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasParagraphStyleName()
   Returns true if the attribute object specifies a paragraph style name. */
PHP_METHOD(php_wxTextAttr, HasParagraphStyleName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasParagraphStyleName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasParagraphStyleName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasParagraphStyleName())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasParagraphStyleName());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasParagraphStyleName\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasRightIndent()
   Returns true if the attribute object specifies a right indent. */
PHP_METHOD(php_wxTextAttr, HasRightIndent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasRightIndent\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasRightIndent call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasRightIndent())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasRightIndent());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasRightIndent\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasTabs()
   Returns true if the attribute object specifies tab stops. */
PHP_METHOD(php_wxTextAttr, HasTabs)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasTabs\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasTabs call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasTabs())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasTabs());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasTabs\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasTextColour()
   Returns true if the attribute object specifies a text foreground colour. */
PHP_METHOD(php_wxTextAttr, HasTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasTextColour())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasTextColour());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasTextColour\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasTextEffects()
   Returns true if the attribute object specifies text effects. */
PHP_METHOD(php_wxTextAttr, HasTextEffects)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasTextEffects\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasTextEffects call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasTextEffects())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasTextEffects());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasTextEffects\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::HasURL()
   Returns true if the attribute object specifies a URL. */
PHP_METHOD(php_wxTextAttr, HasURL)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::HasURL\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::HasURL call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::HasURL())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->HasURL());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::HasURL\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::IsCharacterStyle()
   Returns true if the object represents a character style, that is, the flags specify a font or a text background or foreground colour. */
PHP_METHOD(php_wxTextAttr, IsCharacterStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::IsCharacterStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::IsCharacterStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::IsCharacterStyle())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->IsCharacterStyle());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::IsCharacterStyle\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::IsDefault()
   Returns false if we have any attributes set, true otherwise. */
PHP_METHOD(php_wxTextAttr, IsDefault)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::IsDefault\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::IsDefault call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::IsDefault())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->IsDefault());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::IsDefault\n");
	}
}
/* }}} */

/* {{{ proto bool wxTextAttr::IsParagraphStyle()
   Returns true if the object represents a paragraph style, that is, the flags specify alignment, indentation, tabs, paragraph spacing, or bullet style. */
PHP_METHOD(php_wxTextAttr, IsParagraphStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::IsParagraphStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::IsParagraphStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxTextAttr::IsParagraphStyle())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxTextAttr_php*)native_object)->IsParagraphStyle());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::IsParagraphStyle\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::Merge(wxTextAttr overlay)
   Copies all defined/valid properties from overlay to current object. */
PHP_METHOD(php_wxTextAttr, Merge)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::Merge\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::Merge call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* overlay0 = 0;
	wxTextAttr* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* base1 = 0;
	wxTextAttr* object_pointer1_0 = 0;
	zval* overlay1 = 0;
	wxTextAttr* object_pointer1_1 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&overlay0, php_wxTextAttr_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &overlay0, php_wxTextAttr_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(overlay0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxTextAttr*) zend_object_store_get_object(overlay0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxTextAttr*) zend_object_store_get_object(overlay0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxTextAttr*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(overlay0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&base1, php_wxTextAttr_entry, &overlay1, php_wxTextAttr_entry)\n");
		#endif

		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &base1, php_wxTextAttr_entry, &overlay1, php_wxTextAttr_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(base1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxTextAttr*) zend_object_store_get_object(base1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxTextAttr*) zend_object_store_get_object(base1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxTextAttr*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'base' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(base1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'base' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(overlay1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxTextAttr*) zend_object_store_get_object(overlay1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxTextAttr*) zend_object_store_get_object(overlay1 TSRMLS_CC))->native_object;
					object_pointer1_1 = (wxTextAttr*) argument_native_object;
					if (!object_pointer1_1 )
					{
						zend_error(E_ERROR, "Parameter 'overlay' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(overlay1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'overlay' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::Merge(*(wxTextAttr*) object_pointer0_0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->Merge(*(wxTextAttr*) object_pointer0_0);

				references->AddReference(overlay0, "wxTextAttr::Merge at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxTextAttr::Merge(*(wxTextAttr*) object_pointer1_0, *(wxTextAttr*) object_pointer1_1) to return new object\n\n");
				#endif

				wxTextAttr value_to_return2;
				value_to_return2 = wxTextAttr::Merge(*(wxTextAttr*) object_pointer1_0, *(wxTextAttr*) object_pointer1_1);
				void* ptr = safe_emalloc(1, sizeof(wxTextAttr_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxTextAttr));
				object_init_ex(return_value, php_wxTextAttr_entry);
				((zo_wxTextAttr*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxTextAttr_php*) ptr;
				((wxTextAttr_php*)ptr)->phpObj = return_value;
				((wxTextAttr_php*)ptr)->InitProperties();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::Merge\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetAlignment(wxTextAttrAlignment alignment)
   Sets the paragraph alignment. */
PHP_METHOD(php_wxTextAttr, SetAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long alignment0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&alignment0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &alignment0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetAlignment((wxTextAttrAlignment) alignment0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetAlignment((wxTextAttrAlignment) alignment0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetAlignment\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetBackgroundColour(wxColour colBack)
   Sets the background colour. */
PHP_METHOD(php_wxTextAttr, SetBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colBack0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colBack0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colBack0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colBack0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colBack0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colBack0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colBack' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colBack0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colBack' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetBackgroundColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetBackgroundColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colBack0, "wxTextAttr::SetBackgroundColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetBulletFont(string font)
   Sets the name of the font associated with the bullet symbol. */
PHP_METHOD(php_wxTextAttr, SetBulletFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetBulletFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetBulletFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* font0;
	long font_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&font0, &font_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, &font_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetBulletFont(wxString(font0, wxConvUTF8))\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetBulletFont(wxString(font0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetBulletFont\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetBulletName(string name)
   Sets the standard bullet name, applicable if the bullet style is wxTEXT_ATTR_BULLET_STYLE_STANDARD. */
PHP_METHOD(php_wxTextAttr, SetBulletName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetBulletName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetBulletName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetBulletName(wxString(name0, wxConvUTF8))\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetBulletName(wxString(name0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetBulletName\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetBulletNumber(int n)
   Sets the bullet number. */
PHP_METHOD(php_wxTextAttr, SetBulletNumber)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetBulletNumber\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetBulletNumber call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetBulletNumber((int) n0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetBulletNumber((int) n0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetBulletNumber\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetBulletStyle(int style)
   Sets the bullet style. */
PHP_METHOD(php_wxTextAttr, SetBulletStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetBulletStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetBulletStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&style0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetBulletStyle((int) style0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetBulletStyle((int) style0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetBulletStyle\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetBulletText(string text)
   Sets the bullet text, which could be a symbol, or (for example) cached outline text. */
PHP_METHOD(php_wxTextAttr, SetBulletText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetBulletText\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetBulletText call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&text0, &text_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetBulletText(wxString(text0, wxConvUTF8))\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetBulletText(wxString(text0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetBulletText\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetCharacterStyleName(string name)
   Sets the character style name. */
PHP_METHOD(php_wxTextAttr, SetCharacterStyleName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetCharacterStyleName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetCharacterStyleName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetCharacterStyleName(wxString(name0, wxConvUTF8))\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetCharacterStyleName(wxString(name0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetCharacterStyleName\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetFlags(int flags)
   Sets the flags determining which styles are being specified. */
PHP_METHOD(php_wxTextAttr, SetFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetFlags call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flags0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetFlags((long) flags0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetFlags((long) flags0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetFlags\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetFont(wxFont font, int flags)
   Sets the attributes for the given font. */
PHP_METHOD(php_wxTextAttr, SetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* font0 = 0;
	wxFont* object_pointer0_0 = 0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&font0, php_wxFont_entry, &flags0)\n");
		#endif

		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry, &flags0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxFont*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetFont(*(wxFont*) object_pointer0_0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetFont(*(wxFont*) object_pointer0_0);

				references->AddReference(font0, "wxTextAttr::SetFont at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetFont(*(wxFont*) object_pointer0_0, (int) flags0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetFont(*(wxFont*) object_pointer0_0, (int) flags0);

				references->AddReference(font0, "wxTextAttr::SetFont at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetFont\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetFontEncoding(wxFontEncoding encoding)
   Sets the font encoding. */
PHP_METHOD(php_wxTextAttr, SetFontEncoding)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetFontEncoding\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetFontEncoding call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long encoding0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&encoding0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &encoding0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetFontEncoding((wxFontEncoding) encoding0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetFontEncoding((wxFontEncoding) encoding0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetFontEncoding\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetFontFaceName(string faceName)
   Sets the font face name. */
PHP_METHOD(php_wxTextAttr, SetFontFaceName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetFontFaceName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetFontFaceName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* faceName0;
	long faceName_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&faceName0, &faceName_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &faceName0, &faceName_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetFontFaceName(wxString(faceName0, wxConvUTF8))\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetFontFaceName(wxString(faceName0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetFontFaceName\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetFontFamily(wxFontFamily family)
   Sets the font family. */
PHP_METHOD(php_wxTextAttr, SetFontFamily)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetFontFamily\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetFontFamily call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long family0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&family0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &family0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetFontFamily((wxFontFamily) family0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetFontFamily((wxFontFamily) family0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetFontFamily\n");
	}
}
/* }}} */

/* {{{ proto  wxTextAttr::SetPageBreak(bool pageBreak)
   Specifies a page break before this paragraph. */
PHP_METHOD(php_wxTextAttr, SetPageBreak)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTextAttr::SetPageBreak\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTextAttr* current_object;
	wxphp_object_type current_object_type;
	wxTextAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTextAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTextAttr::SetPageBreak call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTEXTATTR_TYPE){
				references = &((wxTextAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool pageBreak0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&pageBreak0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pageBreak0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetPageBreak()\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetPageBreak();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTextAttr::SetPageBreak(pageBreak0)\n\n");
				#endif

				((wxTextAttr_php*)native_object)->SetPageBreak(pageBreak0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTextAttr::SetPageBreak\n");
	}
}
/* }}} */

