/*
 * @author Mário Soares
 * @contributors Jefferson González
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "aui.h"
#include "bookctrl.h"
#include "cfg.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "dnd.h"
#include "docview.h"
#include "dvc.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "help.h"
#include "html.h"
#include "logging.h"
#include "managedwnd.h"
#include "media.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "net.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "webview.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "others.h"


BEGIN_EXTERN_C()
void php_wxAuiToolBarEvent_free(void *object TSRMLS_DC) 
{
    zo_wxAuiToolBarEvent* custom_object = (zo_wxAuiToolBarEvent*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiToolBarEvent_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAuiToolBarEvent done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxAuiToolBarEvent_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiToolBarEvent_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxAuiToolBarEvent* custom_object;
    custom_object = (zo_wxAuiToolBarEvent*) emalloc(sizeof(zo_wxAuiToolBarEvent));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxAuiToolBarEvent_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXAUITOOLBAREVENT_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto wxPoint wxAuiToolBarEvent::GetClickPoint()
   Returns the point where the user clicked with the mouse. */
PHP_METHOD(php_wxAuiToolBarEvent, GetClickPoint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarEvent::GetClickPoint\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarEvent* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarEvent::GetClickPoint call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAREVENT_TYPE){
				references = &((wxAuiToolBarEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarEvent::GetClickPoint() to return new object\n\n");
				#endif

				wxPoint value_to_return0;
				if(current_object_type == PHP_WXAUITOOLBAREVENT_TYPE)
				{
					value_to_return0 = ((wxAuiToolBarEvent_php*)native_object)->GetClickPoint();
					void* ptr = safe_emalloc(1, sizeof(wxPoint_php), 0);
					memcpy(ptr, &value_to_return0, sizeof(wxPoint));
					object_init_ex(return_value, php_wxPoint_entry);
					((wxPoint_php*)ptr)->phpObj = return_value;
					((wxPoint_php*)ptr)->InitProperties();
					zo_wxPoint* zo0 = (zo_wxPoint*) zend_object_store_get_object(return_value TSRMLS_CC);
					zo0->native_object = (wxPoint_php*) ptr;
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarEvent::GetClickPoint\n");
	}
}
/* }}} */

/* {{{ proto wxRect wxAuiToolBarEvent::GetItemRect()
   Returns the wxAuiToolBarItem rectangle bounding the mouse click point. */
PHP_METHOD(php_wxAuiToolBarEvent, GetItemRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarEvent::GetItemRect\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarEvent* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarEvent::GetItemRect call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAREVENT_TYPE){
				references = &((wxAuiToolBarEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarEvent::GetItemRect() to return new object\n\n");
				#endif

				wxRect value_to_return0;
				if(current_object_type == PHP_WXAUITOOLBAREVENT_TYPE)
				{
					value_to_return0 = ((wxAuiToolBarEvent_php*)native_object)->GetItemRect();
					void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
					memcpy(ptr, &value_to_return0, sizeof(wxRect));
					object_init_ex(return_value, php_wxRect_entry);
					((wxRect_php*)ptr)->phpObj = return_value;
					((wxRect_php*)ptr)->InitProperties();
					zo_wxRect* zo0 = (zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC);
					zo0->native_object = (wxRect_php*) ptr;
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarEvent::GetItemRect\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBarEvent::GetToolId()
   Returns the wxAuiToolBarItem identifier. */
PHP_METHOD(php_wxAuiToolBarEvent, GetToolId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarEvent::GetToolId\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarEvent* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarEvent::GetToolId call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAREVENT_TYPE){
				references = &((wxAuiToolBarEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBarEvent::GetToolId())\n\n");
				#endif

				if(current_object_type == PHP_WXAUITOOLBAREVENT_TYPE)
				{
					ZVAL_LONG(return_value, ((wxAuiToolBarEvent_php*)native_object)->GetToolId());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarEvent::GetToolId\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBarEvent::IsDropDownClicked()
   Returns whether the drop down menu has been clicked. */
PHP_METHOD(php_wxAuiToolBarEvent, IsDropDownClicked)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarEvent::IsDropDownClicked\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarEvent* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarEvent::IsDropDownClicked call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAREVENT_TYPE){
				references = &((wxAuiToolBarEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBarEvent::IsDropDownClicked())\n\n");
				#endif

				if(current_object_type == PHP_WXAUITOOLBAREVENT_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxAuiToolBarEvent_php*)native_object)->IsDropDownClicked());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarEvent::IsDropDownClicked\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxAuiToolBarItem_free(void *object TSRMLS_DC) 
{
    zo_wxAuiToolBarItem* custom_object = (zo_wxAuiToolBarItem*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiToolBarItem_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAuiToolBarItem done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxAuiToolBarItem_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiToolBarItem_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxAuiToolBarItem* custom_object;
    custom_object = (zo_wxAuiToolBarItem*) emalloc(sizeof(zo_wxAuiToolBarItem));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxAuiToolBarItem_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXAUITOOLBARITEM_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxAuiToolBarItem::wxAuiToolBarItem(wxAuiToolBarItem c)
   Assigns the properties of the wxAuiToolBarItem "c" to this. */
PHP_METHOD(php_wxAuiToolBarItem, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* c0 = 0;
	wxAuiToolBarItem* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&c0, php_wxAuiToolBarItem_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &c0, php_wxAuiToolBarItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(c0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiToolBarItem*) zend_object_store_get_object(c0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiToolBarItem*) zend_object_store_get_object(c0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxAuiToolBarItem*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(c0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxAuiToolBarItem*) object_pointer0_0)\n");
				#endif

				native_object = new wxAuiToolBarItem_php(*(wxAuiToolBarItem*) object_pointer0_0);

				native_object->references.Initialize();
				((wxAuiToolBarItem_php*) native_object)->references.AddReference(c0, "wxAuiToolBarItem::wxAuiToolBarItem at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxAuiToolBarItem_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxAuiToolBarItem::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetWindow(wxWindow &w)
   Assigns a window to the toolbar item. */
PHP_METHOD(php_wxAuiToolBarItem, SetWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetWindow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetWindow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* w0 = 0;
	wxWindow* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&w0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &w0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(w0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(w0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(w0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxWindow*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'w' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(w0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'w' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetWindow((wxWindow*) object_pointer0_0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetWindow((wxWindow*) object_pointer0_0);

				references->AddReference(w0, "wxAuiToolBarItem::SetWindow at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetWindow\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetUserData(int l) */
PHP_METHOD(php_wxAuiToolBarItem, SetUserData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetUserData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetUserData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long l0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&l0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &l0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetUserData((long) l0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetUserData((long) l0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetUserData\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetSticky(bool b) */
PHP_METHOD(php_wxAuiToolBarItem, SetSticky)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetSticky\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetSticky call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&b0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetSticky(b0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetSticky(b0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetSticky\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetState(int new_state) */
PHP_METHOD(php_wxAuiToolBarItem, SetState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetState\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetState call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long new_state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&new_state0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &new_state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetState((int) new_state0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetState((int) new_state0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetState\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetSpacerPixels(int s) */
PHP_METHOD(php_wxAuiToolBarItem, SetSpacerPixels)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetSpacerPixels\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetSpacerPixels call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long s0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&s0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetSpacerPixels((int) s0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetSpacerPixels((int) s0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetSpacerPixels\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetSizerItem(wxSizerItem &s) */
PHP_METHOD(php_wxAuiToolBarItem, SetSizerItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetSizerItem\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetSizerItem call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* s0 = 0;
	wxSizerItem* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&s0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(s0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSizerItem*) zend_object_store_get_object(s0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSizerItem*) zend_object_store_get_object(s0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxSizerItem*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXSIZERITEM_TYPE && argument_type != PHP_WXGBSIZERITEM_TYPE))
					{
						zend_error(E_ERROR, "Parameter 's' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(s0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 's' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetSizerItem((wxSizerItem*) object_pointer0_0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetSizerItem((wxSizerItem*) object_pointer0_0);

				references->AddReference(s0, "wxAuiToolBarItem::SetSizerItem at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetSizerItem\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetShortHelp(string s) */
PHP_METHOD(php_wxAuiToolBarItem, SetShortHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetShortHelp\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetShortHelp call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* s0;
	long s_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&s0, &s_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s0, &s_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetShortHelp(wxString(s0, wxConvUTF8))\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetShortHelp(wxString(s0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetShortHelp\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetProportion(int p) */
PHP_METHOD(php_wxAuiToolBarItem, SetProportion)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetProportion\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetProportion call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long p0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&p0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &p0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetProportion((int) p0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetProportion((int) p0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetProportion\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetMinSize(wxSize s) */
PHP_METHOD(php_wxAuiToolBarItem, SetMinSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetMinSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetMinSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* s0 = 0;
	wxSize* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&s0, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s0, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(s0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(s0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(s0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxSize*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 's' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(s0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 's' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetMinSize(*(wxSize*) object_pointer0_0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetMinSize(*(wxSize*) object_pointer0_0);

				references->AddReference(s0, "wxAuiToolBarItem::SetMinSize at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetMinSize\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetLongHelp(string s) */
PHP_METHOD(php_wxAuiToolBarItem, SetLongHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetLongHelp\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetLongHelp call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* s0;
	long s_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&s0, &s_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s0, &s_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetLongHelp(wxString(s0, wxConvUTF8))\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetLongHelp(wxString(s0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetLongHelp\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetLabel(string s) */
PHP_METHOD(php_wxAuiToolBarItem, SetLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetLabel\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetLabel call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* s0;
	long s_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&s0, &s_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s0, &s_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetLabel(wxString(s0, wxConvUTF8))\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetLabel(wxString(s0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetLabel\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetKind(int new_kind)
   Sets the wxAuiToolBarItem kind. */
PHP_METHOD(php_wxAuiToolBarItem, SetKind)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetKind\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetKind call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long new_kind0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&new_kind0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &new_kind0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetKind((int) new_kind0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetKind((int) new_kind0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetKind\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetId(int new_id)
   Sets the toolbar item identifier. */
PHP_METHOD(php_wxAuiToolBarItem, SetId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetId\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetId call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long new_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&new_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &new_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetId((int) new_id0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetId((int) new_id0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetId\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetHoverBitmap(wxBitmap bmp) */
PHP_METHOD(php_wxAuiToolBarItem, SetHoverBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetHoverBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetHoverBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bmp0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bmp0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmp0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmp0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bmp0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bmp0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'bmp' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmp0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bmp' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetHoverBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetHoverBitmap(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bmp0, "wxAuiToolBarItem::SetHoverBitmap at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetHoverBitmap\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetHasDropDown(bool b)
   Set whether this tool has a drop down button. */
PHP_METHOD(php_wxAuiToolBarItem, SetHasDropDown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetHasDropDown\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetHasDropDown call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&b0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetHasDropDown(b0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetHasDropDown(b0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetHasDropDown\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetDisabledBitmap(wxBitmap bmp) */
PHP_METHOD(php_wxAuiToolBarItem, SetDisabledBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetDisabledBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetDisabledBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bmp0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bmp0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmp0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmp0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bmp0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bmp0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'bmp' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmp0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bmp' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetDisabledBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetDisabledBitmap(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bmp0, "wxAuiToolBarItem::SetDisabledBitmap at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetDisabledBitmap\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetBitmap(wxBitmap bmp) */
PHP_METHOD(php_wxAuiToolBarItem, SetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bmp0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bmp0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmp0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmp0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bmp0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bmp0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'bmp' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmp0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bmp' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetBitmap(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bmp0, "wxAuiToolBarItem::SetBitmap at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetBitmap\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetAlignment(int l) */
PHP_METHOD(php_wxAuiToolBarItem, SetAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long l0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&l0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &l0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetAlignment((int) l0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetAlignment((int) l0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetAlignment\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::SetActive(bool b) */
PHP_METHOD(php_wxAuiToolBarItem, SetActive)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::SetActive\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::SetActive call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&b0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::SetActive(b0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->SetActive(b0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::SetActive\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBarItem::IsSticky() */
PHP_METHOD(php_wxAuiToolBarItem, IsSticky)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::IsSticky\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::IsSticky call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBarItem::IsSticky())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBarItem_php*)native_object)->IsSticky());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::IsSticky\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBarItem::IsActive() */
PHP_METHOD(php_wxAuiToolBarItem, IsActive)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::IsActive\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::IsActive call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBarItem::IsActive())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBarItem_php*)native_object)->IsActive());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::IsActive\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBarItem::HasDropDown()
   Returns whether the toolbar item has an associated drop down button. */
PHP_METHOD(php_wxAuiToolBarItem, HasDropDown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::HasDropDown\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::HasDropDown call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBarItem::HasDropDown())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBarItem_php*)native_object)->HasDropDown());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::HasDropDown\n");
	}
}
/* }}} */

/* {{{ proto wxWindow wxAuiToolBarItem::GetWindow()
   Returns the wxWindow* associated to the toolbar item. */
PHP_METHOD(php_wxAuiToolBarItem, GetWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetWindow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::GetWindow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::GetWindow() to return object pointer\n\n");
				#endif

				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxAuiToolBarItem_php*)native_object)->GetWindow();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxWindow_entry);
					((zo_wxWindow*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxWindow_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBarItem::GetWindow at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::GetWindow\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBarItem::GetUserData() */
PHP_METHOD(php_wxAuiToolBarItem, GetUserData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetUserData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::GetUserData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBarItem::GetUserData())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiToolBarItem_php*)native_object)->GetUserData());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::GetUserData\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBarItem::GetState() */
PHP_METHOD(php_wxAuiToolBarItem, GetState)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetState\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::GetState call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBarItem::GetState())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiToolBarItem_php*)native_object)->GetState());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::GetState\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBarItem::GetSpacerPixels() */
PHP_METHOD(php_wxAuiToolBarItem, GetSpacerPixels)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetSpacerPixels\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::GetSpacerPixels call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBarItem::GetSpacerPixels())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiToolBarItem_php*)native_object)->GetSpacerPixels());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::GetSpacerPixels\n");
	}
}
/* }}} */

/* {{{ proto wxSizerItem wxAuiToolBarItem::GetSizerItem() */
PHP_METHOD(php_wxAuiToolBarItem, GetSizerItem)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetSizerItem\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::GetSizerItem call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::GetSizerItem() to return object pointer\n\n");
				#endif

				wxSizerItem_php* value_to_return0;
				value_to_return0 = (wxSizerItem_php*) ((wxAuiToolBarItem_php*)native_object)->GetSizerItem();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxSizerItem_entry);
					((zo_wxSizerItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxSizerItem_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBarItem::GetSizerItem at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::GetSizerItem\n");
	}
}
/* }}} */

/* {{{ proto string wxAuiToolBarItem::GetShortHelp() */
PHP_METHOD(php_wxAuiToolBarItem, GetShortHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetShortHelp\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::GetShortHelp call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiToolBarItem::GetShortHelp().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxAuiToolBarItem_php*)native_object)->GetShortHelp();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::GetShortHelp\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBarItem::GetProportion() */
PHP_METHOD(php_wxAuiToolBarItem, GetProportion)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetProportion\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::GetProportion call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBarItem::GetProportion())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiToolBarItem_php*)native_object)->GetProportion());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::GetProportion\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxAuiToolBarItem::GetMinSize() */
PHP_METHOD(php_wxAuiToolBarItem, GetMinSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetMinSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::GetMinSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::GetMinSize() to return object reference\n\n");
				#endif

				wxSize_php* value_to_return0;
				value_to_return0 = (wxSize_php*) &((wxAuiToolBarItem_php*)native_object)->GetMinSize();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxSize_entry);
					((zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxSize_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiToolBarItem::GetMinSize at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::GetMinSize\n");
	}
}
/* }}} */

/* {{{ proto string wxAuiToolBarItem::GetLongHelp() */
PHP_METHOD(php_wxAuiToolBarItem, GetLongHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetLongHelp\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::GetLongHelp call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiToolBarItem::GetLongHelp().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxAuiToolBarItem_php*)native_object)->GetLongHelp();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::GetLongHelp\n");
	}
}
/* }}} */

/* {{{ proto string wxAuiToolBarItem::GetLabel() */
PHP_METHOD(php_wxAuiToolBarItem, GetLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetLabel\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::GetLabel call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiToolBarItem::GetLabel().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxAuiToolBarItem_php*)native_object)->GetLabel();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::GetLabel\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBarItem::GetKind()
   Returns the toolbar item kind. */
PHP_METHOD(php_wxAuiToolBarItem, GetKind)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetKind\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::GetKind call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBarItem::GetKind())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiToolBarItem_php*)native_object)->GetKind());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::GetKind\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBarItem::GetId()
   Returns the toolbar item identifier. */
PHP_METHOD(php_wxAuiToolBarItem, GetId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetId\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::GetId call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBarItem::GetId())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiToolBarItem_php*)native_object)->GetId());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::GetId\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxAuiToolBarItem::GetHoverBitmap() */
PHP_METHOD(php_wxAuiToolBarItem, GetHoverBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetHoverBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::GetHoverBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::GetHoverBitmap() to return object reference\n\n");
				#endif

				wxBitmap_php* value_to_return0;
				value_to_return0 = (wxBitmap_php*) &((wxAuiToolBarItem_php*)native_object)->GetHoverBitmap();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					((zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmap_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiToolBarItem::GetHoverBitmap at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::GetHoverBitmap\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxAuiToolBarItem::GetDisabledBitmap() */
PHP_METHOD(php_wxAuiToolBarItem, GetDisabledBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetDisabledBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::GetDisabledBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::GetDisabledBitmap() to return object reference\n\n");
				#endif

				wxBitmap_php* value_to_return0;
				value_to_return0 = (wxBitmap_php*) &((wxAuiToolBarItem_php*)native_object)->GetDisabledBitmap();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					((zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmap_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiToolBarItem::GetDisabledBitmap at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::GetDisabledBitmap\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxAuiToolBarItem::GetBitmap() */
PHP_METHOD(php_wxAuiToolBarItem, GetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::GetBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::GetBitmap() to return object reference\n\n");
				#endif

				wxBitmap_php* value_to_return0;
				value_to_return0 = (wxBitmap_php*) &((wxAuiToolBarItem_php*)native_object)->GetBitmap();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					((zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmap_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiToolBarItem::GetBitmap at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::GetBitmap\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBarItem::GetAlignment() */
PHP_METHOD(php_wxAuiToolBarItem, GetAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::GetAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::GetAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBarItem::GetAlignment())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiToolBarItem_php*)native_object)->GetAlignment());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::GetAlignment\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBarItem::Assign(wxAuiToolBarItem c)
   Assigns the properties of the wxAuiToolBarItem "c" to this. */
PHP_METHOD(php_wxAuiToolBarItem, Assign)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBarItem::Assign\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBarItem* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBarItem_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBarItem*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBarItem::Assign call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBARITEM_TYPE){
				references = &((wxAuiToolBarItem_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* c0 = 0;
	wxAuiToolBarItem* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&c0, php_wxAuiToolBarItem_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &c0, php_wxAuiToolBarItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(c0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiToolBarItem*) zend_object_store_get_object(c0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiToolBarItem*) zend_object_store_get_object(c0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxAuiToolBarItem*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'c' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(c0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'c' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBarItem::Assign(*(wxAuiToolBarItem*) object_pointer0_0)\n\n");
				#endif

				((wxAuiToolBarItem_php*)native_object)->Assign(*(wxAuiToolBarItem*) object_pointer0_0);

				references->AddReference(c0, "wxAuiToolBarItem::Assign at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBarItem::Assign\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxAuiToolBarArt_free(void *object TSRMLS_DC) 
{
    zo_wxAuiToolBarArt* custom_object = (zo_wxAuiToolBarArt*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiToolBarArt_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAuiToolBarArt done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxAuiToolBarArt_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiToolBarArt_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxAuiToolBarArt* custom_object;
    custom_object = (zo_wxAuiToolBarArt*) emalloc(sizeof(zo_wxAuiToolBarArt));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxAuiToolBarArt_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXAUITOOLBARART_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto wxAuiToolBarArt wxAuiToolBarArt::Clone() */
wxAuiToolBarArt* wxAuiToolBarArt_php::Clone()
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::Clone\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "Clone", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "Clone", 5, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::Clone'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	if(Z_TYPE_P(return_value) == IS_OBJECT)
	{
		return_object = (void*) ((zo_wxAuiToolBarArt*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object;
	}

	//Threat it as a normal object on the calling function and not a php user space intiialized one
	((zo_wxAuiToolBarArt*) zend_object_store_get_object(return_value TSRMLS_CC))->is_user_initialized = 0;
	wxAuiToolBarArt_php* var = (wxAuiToolBarArt_php*) return_object;
	var->references.UnInitialize();

	return (wxAuiToolBarArt*) return_object;
	
}
/* }}} */

/* {{{ proto  wxAuiToolBarArt::DrawBackground(wxDC &dc, wxWindow &wnd, wxRect rect) */
void wxAuiToolBarArt_php::DrawBackground(wxDC& dc, wxWindow* wnd, const wxRect& rect)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::DrawBackground\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawBackground", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) wnd;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawBackground", 14, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::DrawBackground'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiToolBarArt::DrawButton(wxDC &dc, wxWindow &wnd, wxAuiToolBarItem item, wxRect rect) */
void wxAuiToolBarArt_php::DrawButton(wxDC& dc, wxWindow* wnd, const wxAuiToolBarItem& item, const wxRect& rect)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::DrawButton\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawButton", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) wnd;
	object_init_ex(arguments[2], php_wxAuiToolBarItem_entry);
	((zo_wxAuiToolBarItem*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) &item;
	object_init_ex(arguments[3], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[3] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawButton", 10, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::DrawButton'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiToolBarArt::DrawControlLabel(wxDC &dc, wxWindow &wnd, wxAuiToolBarItem item, wxRect rect) */
void wxAuiToolBarArt_php::DrawControlLabel(wxDC& dc, wxWindow* wnd, const wxAuiToolBarItem& item, const wxRect& rect)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::DrawControlLabel\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawControlLabel", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) wnd;
	object_init_ex(arguments[2], php_wxAuiToolBarItem_entry);
	((zo_wxAuiToolBarItem*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) &item;
	object_init_ex(arguments[3], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[3] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawControlLabel", 16, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::DrawControlLabel'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiToolBarArt::DrawDropDownButton(wxDC &dc, wxWindow &wnd, wxAuiToolBarItem item, wxRect rect) */
void wxAuiToolBarArt_php::DrawDropDownButton(wxDC& dc, wxWindow* wnd, const wxAuiToolBarItem& item, const wxRect& rect)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::DrawDropDownButton\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawDropDownButton", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) wnd;
	object_init_ex(arguments[2], php_wxAuiToolBarItem_entry);
	((zo_wxAuiToolBarItem*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) &item;
	object_init_ex(arguments[3], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[3] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawDropDownButton", 18, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::DrawDropDownButton'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiToolBarArt::DrawGripper(wxDC &dc, wxWindow &wnd, wxRect rect) */
void wxAuiToolBarArt_php::DrawGripper(wxDC& dc, wxWindow* wnd, const wxRect& rect)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::DrawGripper\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawGripper", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) wnd;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawGripper", 11, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::DrawGripper'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiToolBarArt::DrawLabel(wxDC &dc, wxWindow &wnd, wxAuiToolBarItem item, wxRect rect) */
void wxAuiToolBarArt_php::DrawLabel(wxDC& dc, wxWindow* wnd, const wxAuiToolBarItem& item, const wxRect& rect)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::DrawLabel\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawLabel", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) wnd;
	object_init_ex(arguments[2], php_wxAuiToolBarItem_entry);
	((zo_wxAuiToolBarItem*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) &item;
	object_init_ex(arguments[3], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[3] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawLabel", 9, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::DrawLabel'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiToolBarArt::DrawOverflowButton(wxDC &dc, wxWindow &wnd, wxRect rect, int state) */
void wxAuiToolBarArt_php::DrawOverflowButton(wxDC& dc, wxWindow* wnd, const wxRect& rect, int state)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::DrawOverflowButton\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawOverflowButton", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) wnd;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	ZVAL_LONG(arguments[3], state);
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawOverflowButton", 18, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::DrawOverflowButton'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiToolBarArt::DrawSeparator(wxDC &dc, wxWindow &wnd, wxRect rect) */
void wxAuiToolBarArt_php::DrawSeparator(wxDC& dc, wxWindow* wnd, const wxRect& rect)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::DrawSeparator\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawSeparator", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) wnd;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawSeparator", 13, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::DrawSeparator'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto int wxAuiToolBarArt::GetElementSize(int element_id) */
int wxAuiToolBarArt_php::GetElementSize(int element_id)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::GetElementSize\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetElementSize", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], element_id);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetElementSize", 14, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::GetElementSize'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (int) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto int wxAuiToolBarArt::GetFlags() */
unsigned int wxAuiToolBarArt_php::GetFlags()
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::GetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetFlags", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetFlags", 8, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::GetFlags'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (unsigned int) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto wxFont wxAuiToolBarArt::GetFont() */
wxFont wxAuiToolBarArt_php::GetFont()
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::GetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetFont", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetFont", 7, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::GetFont'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	if(Z_TYPE_P(return_value) == IS_OBJECT)
	{
		return_object = (void*) ((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object;
	}

	//Threat it as a normal object on the calling function and not a php user space intiialized one
	((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->is_user_initialized = 0;
	wxFont_php* var = (wxFont_php*) return_object;
	var->references.UnInitialize();

	return *(wxFont*) return_object;
	
}
/* }}} */

/* {{{ proto wxSize wxAuiToolBarArt::GetLabelSize(wxDC &dc, wxWindow &wnd, wxAuiToolBarItem item) */
wxSize wxAuiToolBarArt_php::GetLabelSize(wxDC& dc, wxWindow* wnd, const wxAuiToolBarItem& item)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::GetLabelSize\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetLabelSize", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) wnd;
	object_init_ex(arguments[2], php_wxAuiToolBarItem_entry);
	((zo_wxAuiToolBarItem*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) &item;
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetLabelSize", 12, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::GetLabelSize'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	if(Z_TYPE_P(return_value) == IS_OBJECT)
	{
		return_object = (void*) ((zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object;
	}

	//Threat it as a normal object on the calling function and not a php user space intiialized one
	((zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC))->is_user_initialized = 0;
	wxSize_php* var = (wxSize_php*) return_object;
	var->references.UnInitialize();

	return *(wxSize*) return_object;
	
}
/* }}} */

/* {{{ proto int wxAuiToolBarArt::GetTextOrientation() */
int wxAuiToolBarArt_php::GetTextOrientation()
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::GetTextOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetTextOrientation", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetTextOrientation", 18, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::GetTextOrientation'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (int) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto wxSize wxAuiToolBarArt::GetToolSize(wxDC &dc, wxWindow &wnd, wxAuiToolBarItem item) */
wxSize wxAuiToolBarArt_php::GetToolSize(wxDC& dc, wxWindow* wnd, const wxAuiToolBarItem& item)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::GetToolSize\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetToolSize", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) wnd;
	object_init_ex(arguments[2], php_wxAuiToolBarItem_entry);
	((zo_wxAuiToolBarItem*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) &item;
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetToolSize", 11, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::GetToolSize'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	if(Z_TYPE_P(return_value) == IS_OBJECT)
	{
		return_object = (void*) ((zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object;
	}

	//Threat it as a normal object on the calling function and not a php user space intiialized one
	((zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC))->is_user_initialized = 0;
	wxSize_php* var = (wxSize_php*) return_object;
	var->references.UnInitialize();

	return *(wxSize*) return_object;
	
}
/* }}} */

/* {{{ proto  wxAuiToolBarArt::SetElementSize(int element_id, int size) */
void wxAuiToolBarArt_php::SetElementSize(int element_id, int size)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::SetElementSize\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetElementSize", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], element_id);
	ZVAL_LONG(arguments[1], size);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetElementSize", 14, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::SetElementSize'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiToolBarArt::SetFlags(int flags) */
void wxAuiToolBarArt_php::SetFlags(unsigned int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::SetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetFlags", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], flags);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetFlags", 8, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::SetFlags'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiToolBarArt::SetFont(wxFont font) */
void wxAuiToolBarArt_php::SetFont(const wxFont& font)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::SetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetFont", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxFont_entry);
	((zo_wxFont*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxFont_php*) &font;
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetFont", 7, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::SetFont'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiToolBarArt::SetTextOrientation(int orientation) */
void wxAuiToolBarArt_php::SetTextOrientation(int orientation)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiToolBarArt::SetTextOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetTextOrientation", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], orientation);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetTextOrientation", 18, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiToolBarArt::SetTextOrientation'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxAuiDefaultToolBarArt_free(void *object TSRMLS_DC) 
{
    zo_wxAuiDefaultToolBarArt* custom_object = (zo_wxAuiDefaultToolBarArt*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiDefaultToolBarArt_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAuiDefaultToolBarArt done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxAuiDefaultToolBarArt_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiDefaultToolBarArt_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxAuiDefaultToolBarArt* custom_object;
    custom_object = (zo_wxAuiDefaultToolBarArt*) emalloc(sizeof(zo_wxAuiDefaultToolBarArt));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxAuiDefaultToolBarArt_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXAUIDEFAULTTOOLBARART_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto wxAuiToolBarArt wxAuiDefaultToolBarArt::Clone() */
PHP_METHOD(php_wxAuiDefaultToolBarArt, CloneMethod)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::Clone\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::Clone call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::Clone() to return object pointer\n\n");
				#endif

				wxAuiToolBarArt_php* value_to_return0;
				value_to_return0 = (wxAuiToolBarArt_php*) ((wxAuiDefaultToolBarArt_php*)native_object)->Clone();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarArt_entry);
					((zo_wxAuiToolBarArt*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarArt_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiDefaultToolBarArt::Clone at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::Clone\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiDefaultToolBarArt::DrawBackground(wxDC &dc, wxWindow &wnd, wxRect rect) */
PHP_METHOD(php_wxAuiDefaultToolBarArt, DrawBackground)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::DrawBackground\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::DrawBackground call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* dc0 = 0;
	wxDC* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	wxWindow* object_pointer0_1 = 0;
	zval* rect0 = 0;
	wxRect* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ozO' (&dc0, &wnd0, &rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "ozO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, &wnd0, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDC*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxWindow*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'wnd' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'wnd' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxRect*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::DrawBackground(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxRect*) object_pointer0_2)\n\n");
				#endif

				((wxAuiDefaultToolBarArt_php*)native_object)->DrawBackground(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxRect*) object_pointer0_2);

				references->AddReference(dc0, "wxAuiDefaultToolBarArt::DrawBackground at call with 3 argument(s)");
				references->AddReference(wnd0, "wxAuiDefaultToolBarArt::DrawBackground at call with 3 argument(s)");
				references->AddReference(rect0, "wxAuiDefaultToolBarArt::DrawBackground at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::DrawBackground\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiDefaultToolBarArt::DrawButton(wxDC &dc, wxWindow &wnd, wxAuiToolBarItem item, wxRect rect) */
PHP_METHOD(php_wxAuiDefaultToolBarArt, DrawButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::DrawButton\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::DrawButton call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* dc0 = 0;
	wxDC* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	wxWindow* object_pointer0_1 = 0;
	zval* item0 = 0;
	wxAuiToolBarItem* object_pointer0_2 = 0;
	zval* rect0 = 0;
	wxRect* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ozOO' (&dc0, &wnd0, &item0, php_wxAuiToolBarItem_entry, &rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "ozOO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, &wnd0, &item0, php_wxAuiToolBarItem_entry, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDC*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxWindow*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'wnd' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'wnd' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(item0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiToolBarItem*) zend_object_store_get_object(item0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiToolBarItem*) zend_object_store_get_object(item0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxAuiToolBarItem*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'item' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'item' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_3 = (wxRect*) argument_native_object;
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::DrawButton(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2, *(wxRect*) object_pointer0_3)\n\n");
				#endif

				((wxAuiDefaultToolBarArt_php*)native_object)->DrawButton(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2, *(wxRect*) object_pointer0_3);

				references->AddReference(dc0, "wxAuiDefaultToolBarArt::DrawButton at call with 4 argument(s)");
				references->AddReference(wnd0, "wxAuiDefaultToolBarArt::DrawButton at call with 4 argument(s)");
				references->AddReference(item0, "wxAuiDefaultToolBarArt::DrawButton at call with 4 argument(s)");
				references->AddReference(rect0, "wxAuiDefaultToolBarArt::DrawButton at call with 4 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::DrawButton\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiDefaultToolBarArt::DrawControlLabel(wxDC &dc, wxWindow &wnd, wxAuiToolBarItem item, wxRect rect) */
PHP_METHOD(php_wxAuiDefaultToolBarArt, DrawControlLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::DrawControlLabel\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::DrawControlLabel call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* dc0 = 0;
	wxDC* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	wxWindow* object_pointer0_1 = 0;
	zval* item0 = 0;
	wxAuiToolBarItem* object_pointer0_2 = 0;
	zval* rect0 = 0;
	wxRect* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ozOO' (&dc0, &wnd0, &item0, php_wxAuiToolBarItem_entry, &rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "ozOO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, &wnd0, &item0, php_wxAuiToolBarItem_entry, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDC*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxWindow*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'wnd' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'wnd' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(item0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiToolBarItem*) zend_object_store_get_object(item0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiToolBarItem*) zend_object_store_get_object(item0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxAuiToolBarItem*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'item' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'item' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_3 = (wxRect*) argument_native_object;
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::DrawControlLabel(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2, *(wxRect*) object_pointer0_3)\n\n");
				#endif

				((wxAuiDefaultToolBarArt_php*)native_object)->DrawControlLabel(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2, *(wxRect*) object_pointer0_3);

				references->AddReference(dc0, "wxAuiDefaultToolBarArt::DrawControlLabel at call with 4 argument(s)");
				references->AddReference(wnd0, "wxAuiDefaultToolBarArt::DrawControlLabel at call with 4 argument(s)");
				references->AddReference(item0, "wxAuiDefaultToolBarArt::DrawControlLabel at call with 4 argument(s)");
				references->AddReference(rect0, "wxAuiDefaultToolBarArt::DrawControlLabel at call with 4 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::DrawControlLabel\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiDefaultToolBarArt::DrawDropDownButton(wxDC &dc, wxWindow &wnd, wxAuiToolBarItem item, wxRect rect) */
PHP_METHOD(php_wxAuiDefaultToolBarArt, DrawDropDownButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::DrawDropDownButton\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::DrawDropDownButton call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* dc0 = 0;
	wxDC* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	wxWindow* object_pointer0_1 = 0;
	zval* item0 = 0;
	wxAuiToolBarItem* object_pointer0_2 = 0;
	zval* rect0 = 0;
	wxRect* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ozOO' (&dc0, &wnd0, &item0, php_wxAuiToolBarItem_entry, &rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "ozOO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, &wnd0, &item0, php_wxAuiToolBarItem_entry, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDC*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxWindow*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'wnd' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'wnd' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(item0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiToolBarItem*) zend_object_store_get_object(item0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiToolBarItem*) zend_object_store_get_object(item0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxAuiToolBarItem*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'item' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'item' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_3 = (wxRect*) argument_native_object;
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::DrawDropDownButton(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2, *(wxRect*) object_pointer0_3)\n\n");
				#endif

				((wxAuiDefaultToolBarArt_php*)native_object)->DrawDropDownButton(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2, *(wxRect*) object_pointer0_3);

				references->AddReference(dc0, "wxAuiDefaultToolBarArt::DrawDropDownButton at call with 4 argument(s)");
				references->AddReference(wnd0, "wxAuiDefaultToolBarArt::DrawDropDownButton at call with 4 argument(s)");
				references->AddReference(item0, "wxAuiDefaultToolBarArt::DrawDropDownButton at call with 4 argument(s)");
				references->AddReference(rect0, "wxAuiDefaultToolBarArt::DrawDropDownButton at call with 4 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::DrawDropDownButton\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiDefaultToolBarArt::DrawGripper(wxDC &dc, wxWindow &wnd, wxRect rect) */
PHP_METHOD(php_wxAuiDefaultToolBarArt, DrawGripper)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::DrawGripper\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::DrawGripper call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* dc0 = 0;
	wxDC* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	wxWindow* object_pointer0_1 = 0;
	zval* rect0 = 0;
	wxRect* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ozO' (&dc0, &wnd0, &rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "ozO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, &wnd0, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDC*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxWindow*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'wnd' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'wnd' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxRect*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::DrawGripper(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxRect*) object_pointer0_2)\n\n");
				#endif

				((wxAuiDefaultToolBarArt_php*)native_object)->DrawGripper(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxRect*) object_pointer0_2);

				references->AddReference(dc0, "wxAuiDefaultToolBarArt::DrawGripper at call with 3 argument(s)");
				references->AddReference(wnd0, "wxAuiDefaultToolBarArt::DrawGripper at call with 3 argument(s)");
				references->AddReference(rect0, "wxAuiDefaultToolBarArt::DrawGripper at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::DrawGripper\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiDefaultToolBarArt::DrawLabel(wxDC &dc, wxWindow &wnd, wxAuiToolBarItem item, wxRect rect) */
PHP_METHOD(php_wxAuiDefaultToolBarArt, DrawLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::DrawLabel\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::DrawLabel call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* dc0 = 0;
	wxDC* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	wxWindow* object_pointer0_1 = 0;
	zval* item0 = 0;
	wxAuiToolBarItem* object_pointer0_2 = 0;
	zval* rect0 = 0;
	wxRect* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ozOO' (&dc0, &wnd0, &item0, php_wxAuiToolBarItem_entry, &rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "ozOO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, &wnd0, &item0, php_wxAuiToolBarItem_entry, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDC*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxWindow*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'wnd' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'wnd' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(item0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiToolBarItem*) zend_object_store_get_object(item0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiToolBarItem*) zend_object_store_get_object(item0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxAuiToolBarItem*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'item' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'item' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_3 = (wxRect*) argument_native_object;
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::DrawLabel(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2, *(wxRect*) object_pointer0_3)\n\n");
				#endif

				((wxAuiDefaultToolBarArt_php*)native_object)->DrawLabel(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2, *(wxRect*) object_pointer0_3);

				references->AddReference(dc0, "wxAuiDefaultToolBarArt::DrawLabel at call with 4 argument(s)");
				references->AddReference(wnd0, "wxAuiDefaultToolBarArt::DrawLabel at call with 4 argument(s)");
				references->AddReference(item0, "wxAuiDefaultToolBarArt::DrawLabel at call with 4 argument(s)");
				references->AddReference(rect0, "wxAuiDefaultToolBarArt::DrawLabel at call with 4 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::DrawLabel\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiDefaultToolBarArt::DrawOverflowButton(wxDC &dc, wxWindow &wnd, wxRect rect, int state) */
PHP_METHOD(php_wxAuiDefaultToolBarArt, DrawOverflowButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::DrawOverflowButton\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::DrawOverflowButton call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* dc0 = 0;
	wxDC* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	wxWindow* object_pointer0_1 = 0;
	zval* rect0 = 0;
	wxRect* object_pointer0_2 = 0;
	long state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ozOl' (&dc0, &wnd0, &rect0, php_wxRect_entry, &state0)\n");
		#endif

		char parse_parameters_string[] = "ozOl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, &wnd0, &rect0, php_wxRect_entry, &state0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDC*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxWindow*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'wnd' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'wnd' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxRect*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::DrawOverflowButton(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxRect*) object_pointer0_2, (int) state0)\n\n");
				#endif

				((wxAuiDefaultToolBarArt_php*)native_object)->DrawOverflowButton(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxRect*) object_pointer0_2, (int) state0);

				references->AddReference(dc0, "wxAuiDefaultToolBarArt::DrawOverflowButton at call with 4 argument(s)");
				references->AddReference(wnd0, "wxAuiDefaultToolBarArt::DrawOverflowButton at call with 4 argument(s)");
				references->AddReference(rect0, "wxAuiDefaultToolBarArt::DrawOverflowButton at call with 4 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::DrawOverflowButton\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiDefaultToolBarArt::DrawSeparator(wxDC &dc, wxWindow &wnd, wxRect rect) */
PHP_METHOD(php_wxAuiDefaultToolBarArt, DrawSeparator)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::DrawSeparator\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::DrawSeparator call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* dc0 = 0;
	wxDC* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	wxWindow* object_pointer0_1 = 0;
	zval* rect0 = 0;
	wxRect* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ozO' (&dc0, &wnd0, &rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "ozO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, &wnd0, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDC*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxWindow*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'wnd' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'wnd' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxRect*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::DrawSeparator(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxRect*) object_pointer0_2)\n\n");
				#endif

				((wxAuiDefaultToolBarArt_php*)native_object)->DrawSeparator(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxRect*) object_pointer0_2);

				references->AddReference(dc0, "wxAuiDefaultToolBarArt::DrawSeparator at call with 3 argument(s)");
				references->AddReference(wnd0, "wxAuiDefaultToolBarArt::DrawSeparator at call with 3 argument(s)");
				references->AddReference(rect0, "wxAuiDefaultToolBarArt::DrawSeparator at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::DrawSeparator\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiDefaultToolBarArt::GetElementSize(int element) */
PHP_METHOD(php_wxAuiDefaultToolBarArt, GetElementSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::GetElementSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::GetElementSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long element0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&element0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &element0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiDefaultToolBarArt::GetElementSize((int) element0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiDefaultToolBarArt_php*)native_object)->GetElementSize((int) element0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::GetElementSize\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiDefaultToolBarArt::GetFlags() */
PHP_METHOD(php_wxAuiDefaultToolBarArt, GetFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::GetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::GetFlags call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiDefaultToolBarArt::GetFlags())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiDefaultToolBarArt_php*)native_object)->GetFlags());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::GetFlags\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxAuiDefaultToolBarArt::GetFont() */
PHP_METHOD(php_wxAuiDefaultToolBarArt, GetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::GetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::GetFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::GetFont() to return new object\n\n");
				#endif

				wxFont value_to_return0;
				value_to_return0 = ((wxAuiDefaultToolBarArt_php*)native_object)->GetFont();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxFont));
				object_init_ex(return_value, php_wxFont_entry);
				((wxFont_php*)ptr)->phpObj = return_value;
				zo_wxFont* zo0 = (zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxFont_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::GetFont\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxAuiDefaultToolBarArt::GetLabelSize(wxDC &dc, wxWindow &wnd, wxAuiToolBarItem item) */
PHP_METHOD(php_wxAuiDefaultToolBarArt, GetLabelSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::GetLabelSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::GetLabelSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* dc0 = 0;
	wxDC* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	wxWindow* object_pointer0_1 = 0;
	zval* item0 = 0;
	wxAuiToolBarItem* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ozO' (&dc0, &wnd0, &item0, php_wxAuiToolBarItem_entry)\n");
		#endif

		char parse_parameters_string[] = "ozO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, &wnd0, &item0, php_wxAuiToolBarItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDC*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxWindow*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'wnd' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'wnd' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(item0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiToolBarItem*) zend_object_store_get_object(item0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiToolBarItem*) zend_object_store_get_object(item0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxAuiToolBarItem*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'item' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'item' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::GetLabelSize(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2) to return new object\n\n");
				#endif

				wxSize value_to_return3;
				value_to_return3 = ((wxAuiDefaultToolBarArt_php*)native_object)->GetLabelSize(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2);
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				((wxSize_php*)ptr)->phpObj = return_value;
				zo_wxSize* zo3 = (zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo3->native_object = (wxSize_php*) ptr;

				references->AddReference(dc0, "wxAuiDefaultToolBarArt::GetLabelSize at call with 3 argument(s)");
				references->AddReference(wnd0, "wxAuiDefaultToolBarArt::GetLabelSize at call with 3 argument(s)");
				references->AddReference(item0, "wxAuiDefaultToolBarArt::GetLabelSize at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::GetLabelSize\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiDefaultToolBarArt::GetTextOrientation() */
PHP_METHOD(php_wxAuiDefaultToolBarArt, GetTextOrientation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::GetTextOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::GetTextOrientation call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiDefaultToolBarArt::GetTextOrientation())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiDefaultToolBarArt_php*)native_object)->GetTextOrientation());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::GetTextOrientation\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxAuiDefaultToolBarArt::GetToolSize(wxDC &dc, wxWindow &wnd, wxAuiToolBarItem item) */
PHP_METHOD(php_wxAuiDefaultToolBarArt, GetToolSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::GetToolSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::GetToolSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* dc0 = 0;
	wxDC* object_pointer0_0 = 0;
	zval* wnd0 = 0;
	wxWindow* object_pointer0_1 = 0;
	zval* item0 = 0;
	wxAuiToolBarItem* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ozO' (&dc0, &wnd0, &item0, php_wxAuiToolBarItem_entry)\n");
		#endif

		char parse_parameters_string[] = "ozO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, &wnd0, &item0, php_wxAuiToolBarItem_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDC*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(wnd0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(wnd0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxWindow*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'wnd' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(wnd0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'wnd' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(item0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiToolBarItem*) zend_object_store_get_object(item0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiToolBarItem*) zend_object_store_get_object(item0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxAuiToolBarItem*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'item' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(item0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'item' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::GetToolSize(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2) to return new object\n\n");
				#endif

				wxSize value_to_return3;
				value_to_return3 = ((wxAuiDefaultToolBarArt_php*)native_object)->GetToolSize(*(wxDC*) object_pointer0_0, (wxWindow*) object_pointer0_1, *(wxAuiToolBarItem*) object_pointer0_2);
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				((wxSize_php*)ptr)->phpObj = return_value;
				zo_wxSize* zo3 = (zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo3->native_object = (wxSize_php*) ptr;

				references->AddReference(dc0, "wxAuiDefaultToolBarArt::GetToolSize at call with 3 argument(s)");
				references->AddReference(wnd0, "wxAuiDefaultToolBarArt::GetToolSize at call with 3 argument(s)");
				references->AddReference(item0, "wxAuiDefaultToolBarArt::GetToolSize at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::GetToolSize\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiDefaultToolBarArt::SetElementSize(int element_id, int size) */
PHP_METHOD(php_wxAuiDefaultToolBarArt, SetElementSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::SetElementSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::SetElementSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long element_id0;
	long size0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&element_id0, &size0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &element_id0, &size0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::SetElementSize((int) element_id0, (int) size0)\n\n");
				#endif

				((wxAuiDefaultToolBarArt_php*)native_object)->SetElementSize((int) element_id0, (int) size0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::SetElementSize\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiDefaultToolBarArt::SetFlags(int flags) */
PHP_METHOD(php_wxAuiDefaultToolBarArt, SetFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::SetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::SetFlags call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flags0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::SetFlags((unsigned int) flags0)\n\n");
				#endif

				((wxAuiDefaultToolBarArt_php*)native_object)->SetFlags((unsigned int) flags0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::SetFlags\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiDefaultToolBarArt::SetFont(wxFont font) */
PHP_METHOD(php_wxAuiDefaultToolBarArt, SetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::SetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::SetFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* font0 = 0;
	wxFont* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxFont*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::SetFont(*(wxFont*) object_pointer0_0)\n\n");
				#endif

				((wxAuiDefaultToolBarArt_php*)native_object)->SetFont(*(wxFont*) object_pointer0_0);

				references->AddReference(font0, "wxAuiDefaultToolBarArt::SetFont at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::SetFont\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiDefaultToolBarArt::SetTextOrientation(int orientation) */
PHP_METHOD(php_wxAuiDefaultToolBarArt, SetTextOrientation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::SetTextOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxphp_object_type current_object_type;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiDefaultToolBarArt::SetTextOrientation call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIDEFAULTTOOLBARART_TYPE){
				references = &((wxAuiDefaultToolBarArt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long orientation0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&orientation0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &orientation0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiDefaultToolBarArt::SetTextOrientation((int) orientation0)\n\n");
				#endif

				((wxAuiDefaultToolBarArt_php*)native_object)->SetTextOrientation((int) orientation0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiDefaultToolBarArt::SetTextOrientation\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiDefaultToolBarArt::wxAuiDefaultToolBarArt() */
PHP_METHOD(php_wxAuiDefaultToolBarArt, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDefaultToolBarArt::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDefaultToolBarArt* current_object;
	wxAuiDefaultToolBarArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxAuiDefaultToolBarArt_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxAuiDefaultToolBarArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxAuiDefaultToolBarArt::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxAuiToolBar_free(void *object TSRMLS_DC) 
{
    zo_wxAuiToolBar* custom_object = (zo_wxAuiToolBar*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate delete call for wxAuiToolBar on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxAuiToolBar_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiToolBar_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxAuiToolBar* custom_object;
    custom_object = (zo_wxAuiToolBar*) emalloc(sizeof(zo_wxAuiToolBar));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxAuiToolBar_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXAUITOOLBAR_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxAuiToolBar::wxAuiToolBar()
   Default constructor, use Create() later. */
PHP_METHOD(php_wxAuiToolBar, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	wxWindow* object_pointer1_0 = 0;
	long id1;
	zval* position1 = 0;
	wxPoint* object_pointer1_2 = 0;
	zval* size1 = 0;
	wxSize* object_pointer1_3 = 0;
	long style1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOl' (&parent1, &id1, &position1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1)\n");
		#endif

		char parse_parameters_string[] = "z|lOOl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &position1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(parent1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(parent1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxWindow*) argument_native_object;
					if (!object_pointer1_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'parent' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'parent' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(position1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(position1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(position1 TSRMLS_CC))->native_object;
					object_pointer1_2 = (wxPoint*) argument_native_object;
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter 'position' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(position1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'position' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size1 TSRMLS_CC))->native_object;
					object_pointer1_3 = (wxSize*) argument_native_object;
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxAuiToolBar_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0)\n");
				#endif

				native_object = new wxAuiToolBar_php((wxWindow*) object_pointer1_0);

				native_object->references.Initialize();
				((wxAuiToolBar_php*) native_object)->references.AddReference(parent1, "wxAuiToolBar::wxAuiToolBar at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif

				native_object = new wxAuiToolBar_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				native_object->references.Initialize();
				((wxAuiToolBar_php*) native_object)->references.AddReference(parent1, "wxAuiToolBar::wxAuiToolBar at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif

				native_object = new wxAuiToolBar_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				native_object->references.Initialize();
				((wxAuiToolBar_php*) native_object)->references.AddReference(parent1, "wxAuiToolBar::wxAuiToolBar at call with 3 argument(s)");
				((wxAuiToolBar_php*) native_object)->references.AddReference(position1, "wxAuiToolBar::wxAuiToolBar at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif

				native_object = new wxAuiToolBar_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				native_object->references.Initialize();
				((wxAuiToolBar_php*) native_object)->references.AddReference(parent1, "wxAuiToolBar::wxAuiToolBar at call with 4 argument(s)");
				((wxAuiToolBar_php*) native_object)->references.AddReference(position1, "wxAuiToolBar::wxAuiToolBar at call with 4 argument(s)");
				((wxAuiToolBar_php*) native_object)->references.AddReference(size1, "wxAuiToolBar::wxAuiToolBar at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif

				native_object = new wxAuiToolBar_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				native_object->references.Initialize();
				((wxAuiToolBar_php*) native_object)->references.AddReference(parent1, "wxAuiToolBar::wxAuiToolBar at call with 5 argument(s)");
				((wxAuiToolBar_php*) native_object)->references.AddReference(position1, "wxAuiToolBar::wxAuiToolBar at call with 5 argument(s)");
				((wxAuiToolBar_php*) native_object)->references.AddReference(size1, "wxAuiToolBar::wxAuiToolBar at call with 5 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxAuiToolBar::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto wxAuiToolBarItem wxAuiToolBar::AddControl(wxControl &control, string label) */
PHP_METHOD(php_wxAuiToolBar, AddControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::AddControl\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::AddControl call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* control0 = 0;
	wxControl* object_pointer0_0 = 0;
	char* label0;
	long label_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|s' (&control0, &label0, &label_len0)\n");
		#endif

		char parse_parameters_string[] = "z|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &control0, &label0, &label_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(control0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxControl*) zend_object_store_get_object(control0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxControl*) zend_object_store_get_object(control0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxControl*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'control' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(control0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'control' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddControl((wxControl*) object_pointer0_0) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return1;
				value_to_return1 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddControl((wxControl*) object_pointer0_0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return1;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return1 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddControl at call with 1 argument(s)");
				}

				references->AddReference(control0, "wxAuiToolBar::AddControl at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddControl((wxControl*) object_pointer0_0, wxString(label0, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return2;
				value_to_return2 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddControl((wxControl*) object_pointer0_0, wxString(label0, wxConvUTF8));

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return2;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return2 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddControl at call with 2 argument(s)");
				}

				references->AddReference(control0, "wxAuiToolBar::AddControl at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::AddControl\n");
	}
}
/* }}} */

/* {{{ proto wxAuiToolBarItem wxAuiToolBar::AddLabel(int tool_id, string label, int width) */
PHP_METHOD(php_wxAuiToolBar, AddLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::AddLabel\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::AddLabel call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	char* label0;
	long label_len0;
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|sl' (&tool_id0, &label0, &label_len0, &width0)\n");
		#endif

		char parse_parameters_string[] = "l|sl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &label0, &label_len0, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddLabel((int) tool_id0) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return1;
				value_to_return1 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddLabel((int) tool_id0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return1;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return1 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddLabel at call with 1 argument(s)");
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddLabel((int) tool_id0, wxString(label0, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return2;
				value_to_return2 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddLabel((int) tool_id0, wxString(label0, wxConvUTF8));

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return2;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return2 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddLabel at call with 2 argument(s)");
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddLabel((int) tool_id0, wxString(label0, wxConvUTF8), (const int) width0) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return3;
				value_to_return3 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddLabel((int) tool_id0, wxString(label0, wxConvUTF8), (const int) width0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return3;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return3 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddLabel at call with 3 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::AddLabel\n");
	}
}
/* }}} */

/* {{{ proto wxAuiToolBarItem wxAuiToolBar::AddSeparator() */
PHP_METHOD(php_wxAuiToolBar, AddSeparator)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::AddSeparator\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::AddSeparator call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddSeparator() to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return0;
				value_to_return0 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddSeparator();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddSeparator at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::AddSeparator\n");
	}
}
/* }}} */

/* {{{ proto wxAuiToolBarItem wxAuiToolBar::AddSpacer(int pixels) */
PHP_METHOD(php_wxAuiToolBar, AddSpacer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::AddSpacer\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::AddSpacer call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pixels0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pixels0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pixels0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddSpacer((int) pixels0) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return1;
				value_to_return1 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddSpacer((int) pixels0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return1;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return1 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddSpacer at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::AddSpacer\n");
	}
}
/* }}} */

/* {{{ proto wxAuiToolBarItem wxAuiToolBar::AddStretchSpacer(int proportion) */
PHP_METHOD(php_wxAuiToolBar, AddStretchSpacer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::AddStretchSpacer\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::AddStretchSpacer call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long proportion0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&proportion0)\n");
		#endif

		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &proportion0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddStretchSpacer() to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return0;
				value_to_return0 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddStretchSpacer();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddStretchSpacer at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddStretchSpacer((int) proportion0) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return1;
				value_to_return1 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddStretchSpacer((int) proportion0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return1;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return1 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddStretchSpacer at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::AddStretchSpacer\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::Clear() */
PHP_METHOD(php_wxAuiToolBar, Clear)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::Clear\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::Clear call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::Clear()\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->Clear();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::Clear\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::ClearTools() */
PHP_METHOD(php_wxAuiToolBar, ClearTools)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::ClearTools\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::ClearTools call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::ClearTools()\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->ClearTools();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::ClearTools\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBar::DeleteByIndex(int tool_id) */
PHP_METHOD(php_wxAuiToolBar, DeleteByIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::DeleteByIndex\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::DeleteByIndex call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::DeleteByIndex((int) tool_id0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)native_object)->DeleteByIndex((int) tool_id0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::DeleteByIndex\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBar::DeleteTool(int tool_id) */
PHP_METHOD(php_wxAuiToolBar, DeleteTool)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::DeleteTool\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::DeleteTool call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::DeleteTool((int) tool_id0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)native_object)->DeleteTool((int) tool_id0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::DeleteTool\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::EnableTool(int tool_id, bool state) */
PHP_METHOD(php_wxAuiToolBar, EnableTool)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::EnableTool\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::EnableTool call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lb' (&tool_id0, &state0)\n");
		#endif

		char parse_parameters_string[] = "lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::EnableTool((int) tool_id0, state0)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->EnableTool((int) tool_id0, state0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::EnableTool\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::ToggleTool(int tool_id, bool state) */
PHP_METHOD(php_wxAuiToolBar, ToggleTool)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::ToggleTool\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::ToggleTool call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lb' (&tool_id0, &state0)\n");
		#endif

		char parse_parameters_string[] = "lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::ToggleTool((int) tool_id0, state0)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->ToggleTool((int) tool_id0, state0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::ToggleTool\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::SetWindowStyleFlag(int style)
   Sets the style of the window. */
PHP_METHOD(php_wxAuiToolBar, SetWindowStyleFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetWindowStyleFlag\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetWindowStyleFlag call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&style0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetWindowStyleFlag((long) style0)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetWindowStyleFlag((long) style0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetWindowStyleFlag\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::SetToolTextOrientation(int orientation) */
PHP_METHOD(php_wxAuiToolBar, SetToolTextOrientation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolTextOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetToolTextOrientation call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long orientation0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&orientation0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &orientation0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolTextOrientation((int) orientation0)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetToolTextOrientation((int) orientation0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetToolTextOrientation\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::SetToolSticky(int tool_id, bool sticky) */
PHP_METHOD(php_wxAuiToolBar, SetToolSticky)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolSticky\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetToolSticky call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool sticky0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lb' (&tool_id0, &sticky0)\n");
		#endif

		char parse_parameters_string[] = "lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &sticky0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolSticky((int) tool_id0, sticky0)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetToolSticky((int) tool_id0, sticky0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetToolSticky\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::SetToolShortHelp(int tool_id, string help_string) */
PHP_METHOD(php_wxAuiToolBar, SetToolShortHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolShortHelp\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetToolShortHelp call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	char* help_string0;
	long help_string_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&tool_id0, &help_string0, &help_string_len0)\n");
		#endif

		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &help_string0, &help_string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolShortHelp((int) tool_id0, wxString(help_string0, wxConvUTF8))\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetToolShortHelp((int) tool_id0, wxString(help_string0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetToolShortHelp\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::SetToolSeparation(int separation) */
PHP_METHOD(php_wxAuiToolBar, SetToolSeparation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolSeparation\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetToolSeparation call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long separation0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&separation0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &separation0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolSeparation((int) separation0)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetToolSeparation((int) separation0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetToolSeparation\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::SetToolProportion(int tool_id, int proportion) */
PHP_METHOD(php_wxAuiToolBar, SetToolProportion)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolProportion\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetToolProportion call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	long proportion0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&tool_id0, &proportion0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &proportion0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolProportion((int) tool_id0, (int) proportion0)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetToolProportion((int) tool_id0, (int) proportion0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetToolProportion\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::SetToolPacking(int packing) */
PHP_METHOD(php_wxAuiToolBar, SetToolPacking)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolPacking\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetToolPacking call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long packing0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&packing0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &packing0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolPacking((int) packing0)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetToolPacking((int) packing0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetToolPacking\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::SetToolLongHelp(int tool_id, string help_string) */
PHP_METHOD(php_wxAuiToolBar, SetToolLongHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolLongHelp\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetToolLongHelp call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	char* help_string0;
	long help_string_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&tool_id0, &help_string0, &help_string_len0)\n");
		#endif

		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &help_string0, &help_string_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolLongHelp((int) tool_id0, wxString(help_string0, wxConvUTF8))\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetToolLongHelp((int) tool_id0, wxString(help_string0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetToolLongHelp\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::SetToolLabel(int tool_id, string label) */
PHP_METHOD(php_wxAuiToolBar, SetToolLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolLabel\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetToolLabel call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	char* label0;
	long label_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&tool_id0, &label0, &label_len0)\n");
		#endif

		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &label0, &label_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolLabel((int) tool_id0, wxString(label0, wxConvUTF8))\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetToolLabel((int) tool_id0, wxString(label0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetToolLabel\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::SetToolDropDown(int tool_id, bool dropdown)
   Set whether the specified toolbar item has a drop down button. */
PHP_METHOD(php_wxAuiToolBar, SetToolDropDown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolDropDown\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetToolDropDown call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool dropdown0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lb' (&tool_id0, &dropdown0)\n");
		#endif

		char parse_parameters_string[] = "lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &dropdown0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolDropDown((int) tool_id0, dropdown0)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetToolDropDown((int) tool_id0, dropdown0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetToolDropDown\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::SetToolBorderPadding(int padding) */
PHP_METHOD(php_wxAuiToolBar, SetToolBorderPadding)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolBorderPadding\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetToolBorderPadding call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long padding0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&padding0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &padding0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolBorderPadding((int) padding0)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetToolBorderPadding((int) padding0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetToolBorderPadding\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::SetToolBitmapSize(wxSize size) */
PHP_METHOD(php_wxAuiToolBar, SetToolBitmapSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolBitmapSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetToolBitmapSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* size0 = 0;
	wxSize* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size0, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size0, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxSize*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolBitmapSize(*(wxSize*) object_pointer0_0)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetToolBitmapSize(*(wxSize*) object_pointer0_0);

				references->AddReference(size0, "wxAuiToolBar::SetToolBitmapSize at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetToolBitmapSize\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::SetToolBitmap(int tool_id, wxBitmap bitmap) */
PHP_METHOD(php_wxAuiToolBar, SetToolBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetToolBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetToolBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&tool_id0, &bitmap0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetToolBitmap((int) tool_id0, *(wxBitmap*) object_pointer0_1)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetToolBitmap((int) tool_id0, *(wxBitmap*) object_pointer0_1);

				references->AddReference(bitmap0, "wxAuiToolBar::SetToolBitmap at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetToolBitmap\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::SetOverflowVisible(bool visible) */
PHP_METHOD(php_wxAuiToolBar, SetOverflowVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetOverflowVisible\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetOverflowVisible call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&visible0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetOverflowVisible(visible0)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetOverflowVisible(visible0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetOverflowVisible\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::SetMargins(int left, int right, int top, int bottom) */
PHP_METHOD(php_wxAuiToolBar, SetMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetMargins\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetMargins call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long left0;
	long right0;
	long top0;
	long bottom0;
	bool overload0_called = false;
	//Parameters for overload 1
	long x1;
	long y1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* size2 = 0;
	wxSize* object_pointer2_0 = 0;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll' (&left0, &right0, &top0, &bottom0)\n");
		#endif

		char parse_parameters_string[] = "llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &left0, &right0, &top0, &bottom0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x1, &y1)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x1, &y1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size2, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size2, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxSize*) argument_native_object;
					if (!object_pointer2_0 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetMargins((int) left0, (int) right0, (int) top0, (int) bottom0)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetMargins((int) left0, (int) right0, (int) top0, (int) bottom0);


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetMargins((int) x1, (int) y1)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetMargins((int) x1, (int) y1);


				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetMargins(*(wxSize*) object_pointer2_0)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetMargins(*(wxSize*) object_pointer2_0);

				references->AddReference(size2, "wxAuiToolBar::SetMargins at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetMargins\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiToolBar::SetGripperVisible(bool visible) */
PHP_METHOD(php_wxAuiToolBar, SetGripperVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetGripperVisible\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetGripperVisible call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&visible0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::SetGripperVisible(visible0)\n\n");
				#endif

				((wxAuiToolBar_php*)native_object)->SetGripperVisible(visible0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetGripperVisible\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBar::SetFont(wxFont font)
   Sets the font for this window. */
PHP_METHOD(php_wxAuiToolBar, SetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::SetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::SetFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* font0 = 0;
	wxFont* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxFont*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::SetFont(*(wxFont*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)native_object)->SetFont(*(wxFont*) object_pointer0_0));

				references->AddReference(font0, "wxAuiToolBar::SetFont at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::SetFont\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBar::Realize() */
PHP_METHOD(php_wxAuiToolBar, Realize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::Realize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::Realize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::Realize())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)native_object)->Realize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::Realize\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBar::IsPaneValid(wxAuiPaneInfo pane) */
PHP_METHOD(php_wxAuiToolBar, IsPaneValid)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::IsPaneValid\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::IsPaneValid call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* pane0 = 0;
	wxAuiPaneInfo* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pane0, php_wxAuiPaneInfo_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pane0, php_wxAuiPaneInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pane0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiPaneInfo*) zend_object_store_get_object(pane0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiPaneInfo*) zend_object_store_get_object(pane0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxAuiPaneInfo*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'pane' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pane0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pane' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::IsPaneValid(*(wxAuiPaneInfo*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)native_object)->IsPaneValid(*(wxAuiPaneInfo*) object_pointer0_0));

				references->AddReference(pane0, "wxAuiToolBar::IsPaneValid at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::IsPaneValid\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBar::GetWindowStyleFlag()
   Gets the window style that was passed to the constructor or Create() method. */
PHP_METHOD(php_wxAuiToolBar, GetWindowStyleFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetWindowStyleFlag\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetWindowStyleFlag call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetWindowStyleFlag())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)native_object)->GetWindowStyleFlag());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetWindowStyleFlag\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBar::GetToolToggled(int tool_id) */
PHP_METHOD(php_wxAuiToolBar, GetToolToggled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolToggled\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolToggled call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetToolToggled((int) tool_id0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)native_object)->GetToolToggled((int) tool_id0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolToggled\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBar::GetToolTextOrientation() */
PHP_METHOD(php_wxAuiToolBar, GetToolTextOrientation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolTextOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolTextOrientation call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetToolTextOrientation())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)native_object)->GetToolTextOrientation());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolTextOrientation\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBar::GetToolSticky(int tool_id) */
PHP_METHOD(php_wxAuiToolBar, GetToolSticky)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolSticky\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolSticky call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetToolSticky((int) tool_id0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)native_object)->GetToolSticky((int) tool_id0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolSticky\n");
	}
}
/* }}} */

/* {{{ proto string wxAuiToolBar::GetToolShortHelp(int tool_id) */
PHP_METHOD(php_wxAuiToolBar, GetToolShortHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolShortHelp\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolShortHelp call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiToolBar::GetToolShortHelp((int) tool_id0).fn_str(), 1)\n\n");
				#endif

				wxString value_to_return1;
				value_to_return1 = ((wxAuiToolBar_php*)native_object)->GetToolShortHelp((int) tool_id0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolShortHelp\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBar::GetToolSeparation() */
PHP_METHOD(php_wxAuiToolBar, GetToolSeparation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolSeparation\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolSeparation call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetToolSeparation())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)native_object)->GetToolSeparation());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolSeparation\n");
	}
}
/* }}} */

/* {{{ proto wxControl wxAuiToolBar::FindControl(int window_id) */
PHP_METHOD(php_wxAuiToolBar, FindControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::FindControl\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::FindControl call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long window_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&window_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &window_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::FindControl((int) window_id0) to return object pointer\n\n");
				#endif

				wxControl_php* value_to_return1;
				value_to_return1 = (wxControl_php*) ((wxAuiToolBar_php*)native_object)->FindControl((int) window_id0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxControl_entry);
					((zo_wxControl*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxControl_php*) value_to_return1;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return1 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::FindControl at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::FindControl\n");
	}
}
/* }}} */

/* {{{ proto wxAuiToolBarItem wxAuiToolBar::FindTool(int tool_id) */
PHP_METHOD(php_wxAuiToolBar, FindTool)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::FindTool\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::FindTool call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::FindTool((int) tool_id0) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return1;
				value_to_return1 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->FindTool((int) tool_id0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return1;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return1 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::FindTool at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::FindTool\n");
	}
}
/* }}} */

/* {{{ proto wxAuiToolBarItem wxAuiToolBar::FindToolByIndex(int idx) */
PHP_METHOD(php_wxAuiToolBar, FindToolByIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::FindToolByIndex\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::FindToolByIndex call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long idx0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&idx0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &idx0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::FindToolByIndex((int) idx0) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return1;
				value_to_return1 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->FindToolByIndex((int) idx0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return1;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return1 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::FindToolByIndex at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::FindToolByIndex\n");
	}
}
/* }}} */

/* {{{ proto wxAuiToolBarItem wxAuiToolBar::FindToolByPosition(int x, int y) */
PHP_METHOD(php_wxAuiToolBar, FindToolByPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::FindToolByPosition\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::FindToolByPosition call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::FindToolByPosition((wxCoord) x0, (wxCoord) y0) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return2;
				value_to_return2 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->FindToolByPosition((wxCoord) x0, (wxCoord) y0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return2;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return2 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::FindToolByPosition at call with 2 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::FindToolByPosition\n");
	}
}
/* }}} */

/* {{{ proto wxAuiToolBarArt wxAuiToolBar::GetArtProvider() */
PHP_METHOD(php_wxAuiToolBar, GetArtProvider)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetArtProvider\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetArtProvider call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::GetArtProvider() to return object pointer\n\n");
				#endif

				wxAuiToolBarArt_php* value_to_return0;
				value_to_return0 = (wxAuiToolBarArt_php*) ((wxAuiToolBar_php*)native_object)->GetArtProvider();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarArt_entry);
					((zo_wxAuiToolBarArt*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarArt_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::GetArtProvider at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetArtProvider\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBar::GetGripperVisible() */
PHP_METHOD(php_wxAuiToolBar, GetGripperVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetGripperVisible\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetGripperVisible call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetGripperVisible())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)native_object)->GetGripperVisible());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetGripperVisible\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxAuiToolBar::GetHintSize(int dock_direction)
   get size of hint rectangle for a particular dock location */
PHP_METHOD(php_wxAuiToolBar, GetHintSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetHintSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetHintSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long dock_direction0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&dock_direction0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dock_direction0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::GetHintSize((int) dock_direction0) to return new object\n\n");
				#endif

				wxSize value_to_return1;
				value_to_return1 = ((wxAuiToolBar_php*)native_object)->GetHintSize((int) dock_direction0);
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				((wxSize_php*)ptr)->phpObj = return_value;
				zo_wxSize* zo1 = (zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxSize_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetHintSize\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBar::GetOverflowVisible() */
PHP_METHOD(php_wxAuiToolBar, GetOverflowVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetOverflowVisible\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetOverflowVisible call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetOverflowVisible())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)native_object)->GetOverflowVisible());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetOverflowVisible\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBar::GetToolBarFits() */
PHP_METHOD(php_wxAuiToolBar, GetToolBarFits)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolBarFits\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolBarFits call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetToolBarFits())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)native_object)->GetToolBarFits());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolBarFits\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxAuiToolBar::GetToolBitmap(int tool_id) */
PHP_METHOD(php_wxAuiToolBar, GetToolBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::GetToolBitmap((int) tool_id0) to return new object\n\n");
				#endif

				wxBitmap value_to_return1;
				value_to_return1 = ((wxAuiToolBar_php*)native_object)->GetToolBitmap((int) tool_id0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				((wxBitmap_php*)ptr)->phpObj = return_value;
				zo_wxBitmap* zo1 = (zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxBitmap_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolBitmap\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxAuiToolBar::GetToolBitmapSize() */
PHP_METHOD(php_wxAuiToolBar, GetToolBitmapSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolBitmapSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolBitmapSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::GetToolBitmapSize() to return new object\n\n");
				#endif

				wxSize value_to_return0;
				value_to_return0 = ((wxAuiToolBar_php*)native_object)->GetToolBitmapSize();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				((wxSize_php*)ptr)->phpObj = return_value;
				zo_wxSize* zo0 = (zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxSize_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolBitmapSize\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBar::GetToolBorderPadding() */
PHP_METHOD(php_wxAuiToolBar, GetToolBorderPadding)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolBorderPadding\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolBorderPadding call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetToolBorderPadding())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)native_object)->GetToolBorderPadding());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolBorderPadding\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBar::GetToolCount() */
PHP_METHOD(php_wxAuiToolBar, GetToolCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolCount\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolCount call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetToolCount())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)native_object)->GetToolCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolCount\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBar::GetToolDropDown(int tool_id)
   Returns whether the specified toolbar item has an associated drop down button. */
PHP_METHOD(php_wxAuiToolBar, GetToolDropDown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolDropDown\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolDropDown call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetToolDropDown((int) tool_id0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)native_object)->GetToolDropDown((int) tool_id0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolDropDown\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBar::GetToolEnabled(int tool_id) */
PHP_METHOD(php_wxAuiToolBar, GetToolEnabled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolEnabled\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolEnabled call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetToolEnabled((int) tool_id0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)native_object)->GetToolEnabled((int) tool_id0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolEnabled\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBar::GetToolFits(int tool_id) */
PHP_METHOD(php_wxAuiToolBar, GetToolFits)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolFits\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolFits call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetToolFits((int) tool_id0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)native_object)->GetToolFits((int) tool_id0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolFits\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiToolBar::GetToolFitsByIndex(int tool_id) */
PHP_METHOD(php_wxAuiToolBar, GetToolFitsByIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolFitsByIndex\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolFitsByIndex call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiToolBar::GetToolFitsByIndex((int) tool_id0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiToolBar_php*)native_object)->GetToolFitsByIndex((int) tool_id0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolFitsByIndex\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBar::GetToolIndex(int tool_id) */
PHP_METHOD(php_wxAuiToolBar, GetToolIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolIndex\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolIndex call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetToolIndex((int) tool_id0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)native_object)->GetToolIndex((int) tool_id0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolIndex\n");
	}
}
/* }}} */

/* {{{ proto string wxAuiToolBar::GetToolLabel(int tool_id) */
PHP_METHOD(php_wxAuiToolBar, GetToolLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolLabel\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolLabel call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiToolBar::GetToolLabel((int) tool_id0).fn_str(), 1)\n\n");
				#endif

				wxString value_to_return1;
				value_to_return1 = ((wxAuiToolBar_php*)native_object)->GetToolLabel((int) tool_id0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolLabel\n");
	}
}
/* }}} */

/* {{{ proto string wxAuiToolBar::GetToolLongHelp(int tool_id) */
PHP_METHOD(php_wxAuiToolBar, GetToolLongHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolLongHelp\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolLongHelp call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiToolBar::GetToolLongHelp((int) tool_id0).fn_str(), 1)\n\n");
				#endif

				wxString value_to_return1;
				value_to_return1 = ((wxAuiToolBar_php*)native_object)->GetToolLongHelp((int) tool_id0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolLongHelp\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBar::GetToolPacking() */
PHP_METHOD(php_wxAuiToolBar, GetToolPacking)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolPacking\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolPacking call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetToolPacking())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)native_object)->GetToolPacking());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolPacking\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBar::GetToolPos(int tool_id) */
PHP_METHOD(php_wxAuiToolBar, GetToolPos)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolPos\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolPos call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetToolPos((int) tool_id0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)native_object)->GetToolPos((int) tool_id0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolPos\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiToolBar::GetToolProportion(int tool_id) */
PHP_METHOD(php_wxAuiToolBar, GetToolProportion)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolProportion\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolProportion call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiToolBar::GetToolProportion((int) tool_id0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiToolBar_php*)native_object)->GetToolProportion((int) tool_id0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolProportion\n");
	}
}
/* }}} */

/* {{{ proto wxRect wxAuiToolBar::GetToolRect(int tool_id) */
PHP_METHOD(php_wxAuiToolBar, GetToolRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::GetToolRect\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::GetToolRect call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&tool_id0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::GetToolRect((int) tool_id0) to return new object\n\n");
				#endif

				wxRect value_to_return1;
				value_to_return1 = ((wxAuiToolBar_php*)native_object)->GetToolRect((int) tool_id0);
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				((wxRect_php*)ptr)->phpObj = return_value;
				((wxRect_php*)ptr)->InitProperties();
				zo_wxRect* zo1 = (zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxRect_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::GetToolRect\n");
	}
}
/* }}} */

/* {{{ proto wxAuiToolBarItem wxAuiToolBar::AddTool(int tool_id, string label, wxBitmap bitmap, string short_help_string, wxItemKind kind) */
PHP_METHOD(php_wxAuiToolBar, AddTool)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiToolBar::AddTool\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiToolBar* current_object;
	wxphp_object_type current_object_type;
	wxAuiToolBar_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiToolBar*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiToolBar::AddTool call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUITOOLBAR_TYPE){
				references = &((wxAuiToolBar_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long tool_id0;
	char* label0;
	long label_len0;
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_2 = 0;
	char* short_help_string0;
	long short_help_string_len0;
	long kind0;
	bool overload0_called = false;
	//Parameters for overload 1
	long tool_id1;
	char* label1;
	long label_len1;
	zval* bitmap1 = 0;
	wxBitmap* object_pointer1_2 = 0;
	zval* disabled_bitmap1 = 0;
	wxBitmap* object_pointer1_3 = 0;
	long kind1;
	char* short_help_string1;
	long short_help_string_len1;
	char* long_help_string1;
	long long_help_string_len1;
	zval* client_data1 = 0;
	wxObject* object_pointer1_7 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	long tool_id2;
	zval* bitmap2 = 0;
	wxBitmap* object_pointer2_1 = 0;
	zval* disabled_bitmap2 = 0;
	wxBitmap* object_pointer2_2 = 0;
	bool toggle2;
	zval* client_data2 = 0;
	wxObject* object_pointer2_4 = 0;
	char* short_help_string2;
	long short_help_string_len2;
	char* long_help_string2;
	long long_help_string_len2;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lsO|sl' (&tool_id0, &label0, &label_len0, &bitmap0, php_wxBitmap_entry, &short_help_string0, &short_help_string_len0, &kind0)\n");
		#endif

		char parse_parameters_string[] = "lsO|sl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id0, &label0, &label_len0, &bitmap0, php_wxBitmap_entry, &short_help_string0, &short_help_string_len0, &kind0 ) == SUCCESS)
		{
			if(arguments_received >= 3){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 8)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lsOOlssz' (&tool_id1, &label1, &label_len1, &bitmap1, php_wxBitmap_entry, &disabled_bitmap1, php_wxBitmap_entry, &kind1, &short_help_string1, &short_help_string_len1, &long_help_string1, &long_help_string_len1, &client_data1)\n");
		#endif

		char parse_parameters_string[] = "lsOOlssz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id1, &label1, &label_len1, &bitmap1, php_wxBitmap_entry, &disabled_bitmap1, php_wxBitmap_entry, &kind1, &short_help_string1, &short_help_string_len1, &long_help_string1, &long_help_string_len1, &client_data1 ) == SUCCESS)
		{
			if(arguments_received >= 3){
				if(Z_TYPE_P(bitmap1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap1 TSRMLS_CC))->native_object;
					object_pointer1_2 = (wxBitmap*) argument_native_object;
					if (!object_pointer1_2 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(bitmap1) != IS_NULL)
				{
					goto overload2;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(disabled_bitmap1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(disabled_bitmap1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(disabled_bitmap1 TSRMLS_CC))->native_object;
					object_pointer1_3 = (wxBitmap*) argument_native_object;
					if (!object_pointer1_3 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(disabled_bitmap1) != IS_NULL)
				{
					goto overload2;
				}
			}

			if(arguments_received >= 8){
				if(Z_TYPE_P(client_data1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxObject*) zend_object_store_get_object(client_data1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxObject*) zend_object_store_get_object(client_data1 TSRMLS_CC))->native_object;
					object_pointer1_7 = (wxObject*) argument_native_object;
					if (!object_pointer1_7 || (argument_type != PHP_WXOBJECT_TYPE && argument_type != PHP_WXEVTHANDLER_TYPE && argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE && argument_type != PHP_WXVALIDATOR_TYPE && argument_type != PHP_WXTEXTVALIDATOR_TYPE && argument_type != PHP_WXGENERICVALIDATOR_TYPE && argument_type != PHP_WXMENU_TYPE && argument_type != PHP_WXAUIMANAGER_TYPE && argument_type != PHP_WXMOUSEEVENTSMANAGER_TYPE && argument_type != PHP_WXTIMER_TYPE && argument_type != PHP_WXEVENTBLOCKER_TYPE && argument_type != PHP_WXPROCESS_TYPE && argument_type != PHP_WXFILESYSTEMWATCHER_TYPE && argument_type != PHP_WXTASKBARICON_TYPE && argument_type != PHP_WXNOTIFICATIONMESSAGE_TYPE && argument_type != PHP_WXBITMAPHANDLER_TYPE && argument_type != PHP_WXIMAGE_TYPE && argument_type != PHP_WXSIZER_TYPE && argument_type != PHP_WXBOXSIZER_TYPE && argument_type != PHP_WXSTATICBOXSIZER_TYPE && argument_type != PHP_WXWRAPSIZER_TYPE && argument_type != PHP_WXSTDDIALOGBUTTONSIZER_TYPE && argument_type != PHP_WXGRIDSIZER_TYPE && argument_type != PHP_WXFLEXGRIDSIZER_TYPE && argument_type != PHP_WXGRIDBAGSIZER_TYPE && argument_type != PHP_WXSIZERITEM_TYPE && argument_type != PHP_WXGBSIZERITEM_TYPE && argument_type != PHP_WXIMAGELIST_TYPE && argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE && argument_type != PHP_WXCOLOUR_TYPE && argument_type != PHP_WXMENUITEM_TYPE && argument_type != PHP_WXEVENT_TYPE && argument_type != PHP_WXMENUEVENT_TYPE && argument_type != PHP_WXKEYEVENT_TYPE && argument_type != PHP_WXCOMMANDEVENT_TYPE && argument_type != PHP_WXNOTIFYEVENT_TYPE && argument_type != PHP_WXTREEEVENT_TYPE && argument_type != PHP_WXBOOKCTRLEVENT_TYPE && argument_type != PHP_WXAUINOTEBOOKEVENT_TYPE && argument_type != PHP_WXAUITOOLBAREVENT_TYPE && argument_type != PHP_WXLISTEVENT_TYPE && argument_type != PHP_WXSPINEVENT_TYPE && argument_type != PHP_WXSPLITTEREVENT_TYPE && argument_type != PHP_WXSPINDOUBLEEVENT_TYPE && argument_type != PHP_WXGRIDSIZEEVENT_TYPE && argument_type != PHP_WXWIZARDEVENT_TYPE && argument_type != PHP_WXGRIDEVENT_TYPE && argument_type != PHP_WXGRIDRANGESELECTEVENT_TYPE && argument_type != PHP_WXDATAVIEWEVENT_TYPE && argument_type != PHP_WXHEADERCTRLEVENT_TYPE && argument_type != PHP_WXRIBBONBAREVENT_TYPE && argument_type != PHP_WXWEBVIEWEVENT_TYPE && argument_type != PHP_WXMEDIAEVENT_TYPE && argument_type != PHP_WXSTYLEDTEXTEVENT_TYPE && argument_type != PHP_WXCHILDFOCUSEVENT_TYPE && argument_type != PHP_WXHTMLCELLEVENT_TYPE && argument_type != PHP_WXHTMLLINKEVENT_TYPE && argument_type != PHP_WXHYPERLINKEVENT_TYPE && argument_type != PHP_WXCOLOURPICKEREVENT_TYPE && argument_type != PHP_WXFONTPICKEREVENT_TYPE && argument_type != PHP_WXSCROLLEVENT_TYPE && argument_type != PHP_WXWINDOWMODALDIALOGEVENT_TYPE && argument_type != PHP_WXDATEEVENT_TYPE && argument_type != PHP_WXCALENDAREVENT_TYPE && argument_type != PHP_WXWINDOWCREATEEVENT_TYPE && argument_type != PHP_WXWINDOWDESTROYEVENT_TYPE && argument_type != PHP_WXUPDATEUIEVENT_TYPE && argument_type != PHP_WXHELPEVENT_TYPE && argument_type != PHP_WXGRIDEDITORCREATEDEVENT_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANEEVENT_TYPE && argument_type != PHP_WXCLIPBOARDTEXTEVENT_TYPE && argument_type != PHP_WXFILECTRLEVENT_TYPE && argument_type != PHP_WXSASHEVENT_TYPE && argument_type != PHP_WXFILEDIRPICKEREVENT_TYPE && argument_type != PHP_WXCONTEXTMENUEVENT_TYPE && argument_type != PHP_WXRIBBONBUTTONBAREVENT_TYPE && argument_type != PHP_WXRIBBONGALLERYEVENT_TYPE && argument_type != PHP_WXCLOSEEVENT_TYPE && argument_type != PHP_WXACTIVATEEVENT_TYPE && argument_type != PHP_WXAUIMANAGEREVENT_TYPE && argument_type != PHP_WXSIZEEVENT_TYPE && argument_type != PHP_WXMOUSEEVENT_TYPE && argument_type != PHP_WXMOVEEVENT_TYPE && argument_type != PHP_WXTIMEREVENT_TYPE && argument_type != PHP_WXTHREADEVENT_TYPE && argument_type != PHP_WXSCROLLWINEVENT_TYPE && argument_type != PHP_WXSYSCOLOURCHANGEDEVENT_TYPE && argument_type != PHP_WXPROCESSEVENT_TYPE && argument_type != PHP_WXERASEEVENT_TYPE && argument_type != PHP_WXSETCURSOREVENT_TYPE && argument_type != PHP_WXIDLEEVENT_TYPE && argument_type != PHP_WXPAINTEVENT_TYPE && argument_type != PHP_WXPALETTECHANGEDEVENT_TYPE && argument_type != PHP_WXINITDIALOGEVENT_TYPE && argument_type != PHP_WXMAXIMIZEEVENT_TYPE && argument_type != PHP_WXNAVIGATIONKEYEVENT_TYPE && argument_type != PHP_WXFOCUSEVENT_TYPE && argument_type != PHP_WXFILESYSTEMWATCHEREVENT_TYPE && argument_type != PHP_WXDISPLAYCHANGEDEVENT_TYPE && argument_type != PHP_WXCALCULATELAYOUTEVENT_TYPE && argument_type != PHP_WXQUERYLAYOUTINFOEVENT_TYPE && argument_type != PHP_WXTASKBARICONEVENT_TYPE && argument_type != PHP_WXACCELERATORTABLE_TYPE && argument_type != PHP_WXGDIOBJECT_TYPE && argument_type != PHP_WXBITMAP_TYPE && argument_type != PHP_WXPALETTE_TYPE && argument_type != PHP_WXICON_TYPE && argument_type != PHP_WXFONT_TYPE && argument_type != PHP_WXANIMATION_TYPE && argument_type != PHP_WXICONBUNDLE_TYPE && argument_type != PHP_WXCURSOR_TYPE && argument_type != PHP_WXREGION_TYPE && argument_type != PHP_WXPEN_TYPE && argument_type != PHP_WXBRUSH_TYPE && argument_type != PHP_WXARTPROVIDER_TYPE && argument_type != PHP_WXHTMLCELL_TYPE && argument_type != PHP_WXHTMLCONTAINERCELL_TYPE && argument_type != PHP_WXHTMLCOLOURCELL_TYPE && argument_type != PHP_WXHTMLWIDGETCELL_TYPE && argument_type != PHP_WXHTMLEASYPRINTING_TYPE && argument_type != PHP_WXHTMLLINKINFO_TYPE && argument_type != PHP_WXFINDREPLACEDATA_TYPE && argument_type != PHP_WXSOUND_TYPE && argument_type != PHP_WXFILESYSTEM_TYPE && argument_type != PHP_WXFILESYSTEMHANDLER_TYPE && argument_type != PHP_WXMASK_TYPE && argument_type != PHP_WXTOOLTIP_TYPE && argument_type != PHP_WXGRAPHICSRENDERER_TYPE && argument_type != PHP_WXLAYOUTCONSTRAINTS_TYPE && argument_type != PHP_WXFSFILE_TYPE && argument_type != PHP_WXCOLOURDATA_TYPE && argument_type != PHP_WXFONTDATA_TYPE && argument_type != PHP_WXGRIDTABLEBASE_TYPE && argument_type != PHP_WXDATAVIEWRENDERER_TYPE && argument_type != PHP_WXDATAVIEWBITMAPRENDERER_TYPE && argument_type != PHP_WXDATAVIEWCHOICERENDERER_TYPE && argument_type != PHP_WXDATAVIEWCUSTOMRENDERER_TYPE && argument_type != PHP_WXDATAVIEWSPINRENDERER_TYPE && argument_type != PHP_WXDATAVIEWDATERENDERER_TYPE && argument_type != PHP_WXDATAVIEWICONTEXTRENDERER_TYPE && argument_type != PHP_WXDATAVIEWPROGRESSRENDERER_TYPE && argument_type != PHP_WXDATAVIEWTEXTRENDERER_TYPE && argument_type != PHP_WXDATAVIEWTOGGLERENDERER_TYPE && argument_type != PHP_WXDATAVIEWICONTEXT_TYPE && argument_type != PHP_WXVARIANT_TYPE && argument_type != PHP_WXCLIPBOARD_TYPE && argument_type != PHP_WXCONFIGBASE_TYPE && argument_type != PHP_WXFILECONFIG_TYPE && argument_type != PHP_WXXMLRESOURCE_TYPE && argument_type != PHP_WXPAGESETUPDIALOG_TYPE && argument_type != PHP_WXPAGESETUPDIALOGDATA_TYPE && argument_type != PHP_WXPRINTDIALOG_TYPE && argument_type != PHP_WXPRINTDIALOGDATA_TYPE && argument_type != PHP_WXPRINTDATA_TYPE && argument_type != PHP_WXPRINTPREVIEW_TYPE && argument_type != PHP_WXPRINTER_TYPE && argument_type != PHP_WXPRINTOUT_TYPE && argument_type != PHP_WXHTMLPRINTOUT_TYPE && argument_type != PHP_WXHTMLDCRENDERER_TYPE && argument_type != PHP_WXHTMLFILTER_TYPE && argument_type != PHP_WXHTMLHELPDATA_TYPE && argument_type != PHP_WXHTMLTAGHANDLER_TYPE && argument_type != PHP_WXHTMLWINTAGHANDLER_TYPE && argument_type != PHP_WXMODULE_TYPE && argument_type != PHP_WXHTMLTAGSMODULE_TYPE && argument_type != PHP_WXIMAGEHANDLER_TYPE && argument_type != PHP_WXXMLRESOURCEHANDLER_TYPE && argument_type != PHP_WXXMLDOCUMENT_TYPE && argument_type != PHP_WXLAYOUTALGORITHM_TYPE && argument_type != PHP_WXFILEHISTORY_TYPE && argument_type != PHP_WXTOOLBARTOOLBASE_TYPE))
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(client_data1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received >= 3  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lOO|bzss' (&tool_id2, &bitmap2, php_wxBitmap_entry, &disabled_bitmap2, php_wxBitmap_entry, &toggle2, &client_data2, &short_help_string2, &short_help_string_len2, &long_help_string2, &long_help_string_len2)\n");
		#endif

		char parse_parameters_string[] = "lOO|bzss";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &tool_id2, &bitmap2, php_wxBitmap_entry, &disabled_bitmap2, php_wxBitmap_entry, &toggle2, &client_data2, &short_help_string2, &short_help_string_len2, &long_help_string2, &long_help_string_len2 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(bitmap2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap2 TSRMLS_CC))->native_object;
					object_pointer2_1 = (wxBitmap*) argument_native_object;
					if (!object_pointer2_1 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(disabled_bitmap2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(disabled_bitmap2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(disabled_bitmap2 TSRMLS_CC))->native_object;
					object_pointer2_2 = (wxBitmap*) argument_native_object;
					if (!object_pointer2_2 )
					{
						zend_error(E_ERROR, "Parameter 'disabled_bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(disabled_bitmap2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'disabled_bitmap' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 5){
				if(Z_TYPE_P(client_data2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxObject*) zend_object_store_get_object(client_data2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxObject*) zend_object_store_get_object(client_data2 TSRMLS_CC))->native_object;
					object_pointer2_4 = (wxObject*) argument_native_object;
					if (!object_pointer2_4 || (argument_type != PHP_WXOBJECT_TYPE && argument_type != PHP_WXEVTHANDLER_TYPE && argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE && argument_type != PHP_WXVALIDATOR_TYPE && argument_type != PHP_WXTEXTVALIDATOR_TYPE && argument_type != PHP_WXGENERICVALIDATOR_TYPE && argument_type != PHP_WXMENU_TYPE && argument_type != PHP_WXAUIMANAGER_TYPE && argument_type != PHP_WXMOUSEEVENTSMANAGER_TYPE && argument_type != PHP_WXTIMER_TYPE && argument_type != PHP_WXEVENTBLOCKER_TYPE && argument_type != PHP_WXPROCESS_TYPE && argument_type != PHP_WXFILESYSTEMWATCHER_TYPE && argument_type != PHP_WXTASKBARICON_TYPE && argument_type != PHP_WXNOTIFICATIONMESSAGE_TYPE && argument_type != PHP_WXBITMAPHANDLER_TYPE && argument_type != PHP_WXIMAGE_TYPE && argument_type != PHP_WXSIZER_TYPE && argument_type != PHP_WXBOXSIZER_TYPE && argument_type != PHP_WXSTATICBOXSIZER_TYPE && argument_type != PHP_WXWRAPSIZER_TYPE && argument_type != PHP_WXSTDDIALOGBUTTONSIZER_TYPE && argument_type != PHP_WXGRIDSIZER_TYPE && argument_type != PHP_WXFLEXGRIDSIZER_TYPE && argument_type != PHP_WXGRIDBAGSIZER_TYPE && argument_type != PHP_WXSIZERITEM_TYPE && argument_type != PHP_WXGBSIZERITEM_TYPE && argument_type != PHP_WXIMAGELIST_TYPE && argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE && argument_type != PHP_WXCOLOUR_TYPE && argument_type != PHP_WXMENUITEM_TYPE && argument_type != PHP_WXEVENT_TYPE && argument_type != PHP_WXMENUEVENT_TYPE && argument_type != PHP_WXKEYEVENT_TYPE && argument_type != PHP_WXCOMMANDEVENT_TYPE && argument_type != PHP_WXNOTIFYEVENT_TYPE && argument_type != PHP_WXTREEEVENT_TYPE && argument_type != PHP_WXBOOKCTRLEVENT_TYPE && argument_type != PHP_WXAUINOTEBOOKEVENT_TYPE && argument_type != PHP_WXAUITOOLBAREVENT_TYPE && argument_type != PHP_WXLISTEVENT_TYPE && argument_type != PHP_WXSPINEVENT_TYPE && argument_type != PHP_WXSPLITTEREVENT_TYPE && argument_type != PHP_WXSPINDOUBLEEVENT_TYPE && argument_type != PHP_WXGRIDSIZEEVENT_TYPE && argument_type != PHP_WXWIZARDEVENT_TYPE && argument_type != PHP_WXGRIDEVENT_TYPE && argument_type != PHP_WXGRIDRANGESELECTEVENT_TYPE && argument_type != PHP_WXDATAVIEWEVENT_TYPE && argument_type != PHP_WXHEADERCTRLEVENT_TYPE && argument_type != PHP_WXRIBBONBAREVENT_TYPE && argument_type != PHP_WXWEBVIEWEVENT_TYPE && argument_type != PHP_WXMEDIAEVENT_TYPE && argument_type != PHP_WXSTYLEDTEXTEVENT_TYPE && argument_type != PHP_WXCHILDFOCUSEVENT_TYPE && argument_type != PHP_WXHTMLCELLEVENT_TYPE && argument_type != PHP_WXHTMLLINKEVENT_TYPE && argument_type != PHP_WXHYPERLINKEVENT_TYPE && argument_type != PHP_WXCOLOURPICKEREVENT_TYPE && argument_type != PHP_WXFONTPICKEREVENT_TYPE && argument_type != PHP_WXSCROLLEVENT_TYPE && argument_type != PHP_WXWINDOWMODALDIALOGEVENT_TYPE && argument_type != PHP_WXDATEEVENT_TYPE && argument_type != PHP_WXCALENDAREVENT_TYPE && argument_type != PHP_WXWINDOWCREATEEVENT_TYPE && argument_type != PHP_WXWINDOWDESTROYEVENT_TYPE && argument_type != PHP_WXUPDATEUIEVENT_TYPE && argument_type != PHP_WXHELPEVENT_TYPE && argument_type != PHP_WXGRIDEDITORCREATEDEVENT_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANEEVENT_TYPE && argument_type != PHP_WXCLIPBOARDTEXTEVENT_TYPE && argument_type != PHP_WXFILECTRLEVENT_TYPE && argument_type != PHP_WXSASHEVENT_TYPE && argument_type != PHP_WXFILEDIRPICKEREVENT_TYPE && argument_type != PHP_WXCONTEXTMENUEVENT_TYPE && argument_type != PHP_WXRIBBONBUTTONBAREVENT_TYPE && argument_type != PHP_WXRIBBONGALLERYEVENT_TYPE && argument_type != PHP_WXCLOSEEVENT_TYPE && argument_type != PHP_WXACTIVATEEVENT_TYPE && argument_type != PHP_WXAUIMANAGEREVENT_TYPE && argument_type != PHP_WXSIZEEVENT_TYPE && argument_type != PHP_WXMOUSEEVENT_TYPE && argument_type != PHP_WXMOVEEVENT_TYPE && argument_type != PHP_WXTIMEREVENT_TYPE && argument_type != PHP_WXTHREADEVENT_TYPE && argument_type != PHP_WXSCROLLWINEVENT_TYPE && argument_type != PHP_WXSYSCOLOURCHANGEDEVENT_TYPE && argument_type != PHP_WXPROCESSEVENT_TYPE && argument_type != PHP_WXERASEEVENT_TYPE && argument_type != PHP_WXSETCURSOREVENT_TYPE && argument_type != PHP_WXIDLEEVENT_TYPE && argument_type != PHP_WXPAINTEVENT_TYPE && argument_type != PHP_WXPALETTECHANGEDEVENT_TYPE && argument_type != PHP_WXINITDIALOGEVENT_TYPE && argument_type != PHP_WXMAXIMIZEEVENT_TYPE && argument_type != PHP_WXNAVIGATIONKEYEVENT_TYPE && argument_type != PHP_WXFOCUSEVENT_TYPE && argument_type != PHP_WXFILESYSTEMWATCHEREVENT_TYPE && argument_type != PHP_WXDISPLAYCHANGEDEVENT_TYPE && argument_type != PHP_WXCALCULATELAYOUTEVENT_TYPE && argument_type != PHP_WXQUERYLAYOUTINFOEVENT_TYPE && argument_type != PHP_WXTASKBARICONEVENT_TYPE && argument_type != PHP_WXACCELERATORTABLE_TYPE && argument_type != PHP_WXGDIOBJECT_TYPE && argument_type != PHP_WXBITMAP_TYPE && argument_type != PHP_WXPALETTE_TYPE && argument_type != PHP_WXICON_TYPE && argument_type != PHP_WXFONT_TYPE && argument_type != PHP_WXANIMATION_TYPE && argument_type != PHP_WXICONBUNDLE_TYPE && argument_type != PHP_WXCURSOR_TYPE && argument_type != PHP_WXREGION_TYPE && argument_type != PHP_WXPEN_TYPE && argument_type != PHP_WXBRUSH_TYPE && argument_type != PHP_WXARTPROVIDER_TYPE && argument_type != PHP_WXHTMLCELL_TYPE && argument_type != PHP_WXHTMLCONTAINERCELL_TYPE && argument_type != PHP_WXHTMLCOLOURCELL_TYPE && argument_type != PHP_WXHTMLWIDGETCELL_TYPE && argument_type != PHP_WXHTMLEASYPRINTING_TYPE && argument_type != PHP_WXHTMLLINKINFO_TYPE && argument_type != PHP_WXFINDREPLACEDATA_TYPE && argument_type != PHP_WXSOUND_TYPE && argument_type != PHP_WXFILESYSTEM_TYPE && argument_type != PHP_WXFILESYSTEMHANDLER_TYPE && argument_type != PHP_WXMASK_TYPE && argument_type != PHP_WXTOOLTIP_TYPE && argument_type != PHP_WXGRAPHICSRENDERER_TYPE && argument_type != PHP_WXLAYOUTCONSTRAINTS_TYPE && argument_type != PHP_WXFSFILE_TYPE && argument_type != PHP_WXCOLOURDATA_TYPE && argument_type != PHP_WXFONTDATA_TYPE && argument_type != PHP_WXGRIDTABLEBASE_TYPE && argument_type != PHP_WXDATAVIEWRENDERER_TYPE && argument_type != PHP_WXDATAVIEWBITMAPRENDERER_TYPE && argument_type != PHP_WXDATAVIEWCHOICERENDERER_TYPE && argument_type != PHP_WXDATAVIEWCUSTOMRENDERER_TYPE && argument_type != PHP_WXDATAVIEWSPINRENDERER_TYPE && argument_type != PHP_WXDATAVIEWDATERENDERER_TYPE && argument_type != PHP_WXDATAVIEWICONTEXTRENDERER_TYPE && argument_type != PHP_WXDATAVIEWPROGRESSRENDERER_TYPE && argument_type != PHP_WXDATAVIEWTEXTRENDERER_TYPE && argument_type != PHP_WXDATAVIEWTOGGLERENDERER_TYPE && argument_type != PHP_WXDATAVIEWICONTEXT_TYPE && argument_type != PHP_WXVARIANT_TYPE && argument_type != PHP_WXCLIPBOARD_TYPE && argument_type != PHP_WXCONFIGBASE_TYPE && argument_type != PHP_WXFILECONFIG_TYPE && argument_type != PHP_WXXMLRESOURCE_TYPE && argument_type != PHP_WXPAGESETUPDIALOG_TYPE && argument_type != PHP_WXPAGESETUPDIALOGDATA_TYPE && argument_type != PHP_WXPRINTDIALOG_TYPE && argument_type != PHP_WXPRINTDIALOGDATA_TYPE && argument_type != PHP_WXPRINTDATA_TYPE && argument_type != PHP_WXPRINTPREVIEW_TYPE && argument_type != PHP_WXPRINTER_TYPE && argument_type != PHP_WXPRINTOUT_TYPE && argument_type != PHP_WXHTMLPRINTOUT_TYPE && argument_type != PHP_WXHTMLDCRENDERER_TYPE && argument_type != PHP_WXHTMLFILTER_TYPE && argument_type != PHP_WXHTMLHELPDATA_TYPE && argument_type != PHP_WXHTMLTAGHANDLER_TYPE && argument_type != PHP_WXHTMLWINTAGHANDLER_TYPE && argument_type != PHP_WXMODULE_TYPE && argument_type != PHP_WXHTMLTAGSMODULE_TYPE && argument_type != PHP_WXIMAGEHANDLER_TYPE && argument_type != PHP_WXXMLRESOURCEHANDLER_TYPE && argument_type != PHP_WXXMLDOCUMENT_TYPE && argument_type != PHP_WXLAYOUTALGORITHM_TYPE && argument_type != PHP_WXFILEHISTORY_TYPE && argument_type != PHP_WXTOOLBARTOOLBASE_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'client_data' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(client_data2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'client_data' not null, could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id0, wxString(label0, wxConvUTF8), *(wxBitmap*) object_pointer0_2) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return3;
				value_to_return3 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddTool((int) tool_id0, wxString(label0, wxConvUTF8), *(wxBitmap*) object_pointer0_2);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return3;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return3 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddTool at call with 3 argument(s)");
				}

				references->AddReference(bitmap0, "wxAuiToolBar::AddTool at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id0, wxString(label0, wxConvUTF8), *(wxBitmap*) object_pointer0_2, wxString(short_help_string0, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return4;
				value_to_return4 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddTool((int) tool_id0, wxString(label0, wxConvUTF8), *(wxBitmap*) object_pointer0_2, wxString(short_help_string0, wxConvUTF8));

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return4;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return4 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddTool at call with 4 argument(s)");
				}

				references->AddReference(bitmap0, "wxAuiToolBar::AddTool at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id0, wxString(label0, wxConvUTF8), *(wxBitmap*) object_pointer0_2, wxString(short_help_string0, wxConvUTF8), (wxItemKind) kind0) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return5;
				value_to_return5 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddTool((int) tool_id0, wxString(label0, wxConvUTF8), *(wxBitmap*) object_pointer0_2, wxString(short_help_string0, wxConvUTF8), (wxItemKind) kind0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return5;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return5 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddTool at call with 5 argument(s)");
				}

				references->AddReference(bitmap0, "wxAuiToolBar::AddTool at call with 5 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 8:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id1, wxString(label1, wxConvUTF8), *(wxBitmap*) object_pointer1_2, *(wxBitmap*) object_pointer1_3, (wxItemKind) kind1, wxString(short_help_string1, wxConvUTF8), wxString(long_help_string1, wxConvUTF8), (wxObject*) object_pointer1_7) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return8;
				value_to_return8 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddTool((int) tool_id1, wxString(label1, wxConvUTF8), *(wxBitmap*) object_pointer1_2, *(wxBitmap*) object_pointer1_3, (wxItemKind) kind1, wxString(short_help_string1, wxConvUTF8), wxString(long_help_string1, wxConvUTF8), (wxObject*) object_pointer1_7);

				if(value_to_return8 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return8->references.IsUserInitialized()){
					if(value_to_return8->phpObj != NULL){
						*return_value = *value_to_return8->phpObj;
						zval_add_ref(&value_to_return8->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return8;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return8 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddTool at call with 8 argument(s)");
				}

				references->AddReference(bitmap1, "wxAuiToolBar::AddTool at call with 8 argument(s)");
				references->AddReference(disabled_bitmap1, "wxAuiToolBar::AddTool at call with 8 argument(s)");
				references->AddReference(client_data1, "wxAuiToolBar::AddTool at call with 8 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return3;
				value_to_return3 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return3;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return3 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddTool at call with 3 argument(s)");
				}

				references->AddReference(bitmap2, "wxAuiToolBar::AddTool at call with 3 argument(s)");
				references->AddReference(disabled_bitmap2, "wxAuiToolBar::AddTool at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2, toggle2) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return4;
				value_to_return4 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2, toggle2);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return4;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return4 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddTool at call with 4 argument(s)");
				}

				references->AddReference(bitmap2, "wxAuiToolBar::AddTool at call with 4 argument(s)");
				references->AddReference(disabled_bitmap2, "wxAuiToolBar::AddTool at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2, toggle2, (wxObject*) object_pointer2_4) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return5;
				value_to_return5 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2, toggle2, (wxObject*) object_pointer2_4);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return5;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return5 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddTool at call with 5 argument(s)");
				}

				references->AddReference(bitmap2, "wxAuiToolBar::AddTool at call with 5 argument(s)");
				references->AddReference(disabled_bitmap2, "wxAuiToolBar::AddTool at call with 5 argument(s)");
				references->AddReference(client_data2, "wxAuiToolBar::AddTool at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2, toggle2, (wxObject*) object_pointer2_4, wxString(short_help_string2, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return6;
				value_to_return6 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2, toggle2, (wxObject*) object_pointer2_4, wxString(short_help_string2, wxConvUTF8));

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return6;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return6 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddTool at call with 6 argument(s)");
				}

				references->AddReference(bitmap2, "wxAuiToolBar::AddTool at call with 6 argument(s)");
				references->AddReference(disabled_bitmap2, "wxAuiToolBar::AddTool at call with 6 argument(s)");
				references->AddReference(client_data2, "wxAuiToolBar::AddTool at call with 6 argument(s)");

				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiToolBar::AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2, toggle2, (wxObject*) object_pointer2_4, wxString(short_help_string2, wxConvUTF8), wxString(long_help_string2, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxAuiToolBarItem_php* value_to_return7;
				value_to_return7 = (wxAuiToolBarItem_php*) ((wxAuiToolBar_php*)native_object)->AddTool((int) tool_id2, *(wxBitmap*) object_pointer2_1, *(wxBitmap*) object_pointer2_2, toggle2, (wxObject*) object_pointer2_4, wxString(short_help_string2, wxConvUTF8), wxString(long_help_string2, wxConvUTF8));

				if(value_to_return7 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return7->references.IsUserInitialized()){
					if(value_to_return7->phpObj != NULL){
						*return_value = *value_to_return7->phpObj;
						zval_add_ref(&value_to_return7->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiToolBarItem_entry);
					((zo_wxAuiToolBarItem*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiToolBarItem_php*) value_to_return7;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return7 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiToolBar::AddTool at call with 7 argument(s)");
				}

				references->AddReference(bitmap2, "wxAuiToolBar::AddTool at call with 7 argument(s)");
				references->AddReference(disabled_bitmap2, "wxAuiToolBar::AddTool at call with 7 argument(s)");
				references->AddReference(client_data2, "wxAuiToolBar::AddTool at call with 7 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiToolBar::AddTool\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxAuiNotebook_free(void *object TSRMLS_DC) 
{
    zo_wxAuiNotebook* custom_object = (zo_wxAuiNotebook*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate delete call for wxAuiNotebook on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxAuiNotebook_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiNotebook_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxAuiNotebook* custom_object;
    custom_object = (zo_wxAuiNotebook*) emalloc(sizeof(zo_wxAuiNotebook));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxAuiNotebook_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXAUINOTEBOOK_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxAuiNotebook::wxAuiNotebook(wxWindow &parent, int id, wxPoint pos, wxSize size, int style)
   Constructor. */
PHP_METHOD(php_wxAuiNotebook, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* parent0 = 0;
	wxWindow* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	wxPoint* object_pointer0_2 = 0;
	zval* size0 = 0;
	wxSize* object_pointer0_3 = 0;
	long style0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOl' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0)\n");
		#endif

		char parse_parameters_string[] = "z|lOOl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(parent0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(parent0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxWindow*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
					goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pos0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pos0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxPoint*) argument_native_object;
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
					goto overload1;
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->native_object;
					object_pointer0_3 = (wxSize*) argument_native_object;
					if (!object_pointer0_3 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0)\n");
				#endif

				native_object = new wxAuiNotebook_php((wxWindow*) object_pointer0_0);

				native_object->references.Initialize();
				((wxAuiNotebook_php*) native_object)->references.AddReference(parent0, "wxAuiNotebook::wxAuiNotebook at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0)\n");
				#endif

				native_object = new wxAuiNotebook_php((wxWindow*) object_pointer0_0, (wxWindowID) id0);

				native_object->references.Initialize();
				((wxAuiNotebook_php*) native_object)->references.AddReference(parent0, "wxAuiNotebook::wxAuiNotebook at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2)\n");
				#endif

				native_object = new wxAuiNotebook_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2);

				native_object->references.Initialize();
				((wxAuiNotebook_php*) native_object)->references.AddReference(parent0, "wxAuiNotebook::wxAuiNotebook at call with 3 argument(s)");
				((wxAuiNotebook_php*) native_object)->references.AddReference(pos0, "wxAuiNotebook::wxAuiNotebook at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3)\n");
				#endif

				native_object = new wxAuiNotebook_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3);

				native_object->references.Initialize();
				((wxAuiNotebook_php*) native_object)->references.AddReference(parent0, "wxAuiNotebook::wxAuiNotebook at call with 4 argument(s)");
				((wxAuiNotebook_php*) native_object)->references.AddReference(pos0, "wxAuiNotebook::wxAuiNotebook at call with 4 argument(s)");
				((wxAuiNotebook_php*) native_object)->references.AddReference(size0, "wxAuiNotebook::wxAuiNotebook at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0)\n");
				#endif

				native_object = new wxAuiNotebook_php((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0);

				native_object->references.Initialize();
				((wxAuiNotebook_php*) native_object)->references.AddReference(parent0, "wxAuiNotebook::wxAuiNotebook at call with 5 argument(s)");
				((wxAuiNotebook_php*) native_object)->references.AddReference(pos0, "wxAuiNotebook::wxAuiNotebook at call with 5 argument(s)");
				((wxAuiNotebook_php*) native_object)->references.AddReference(size0, "wxAuiNotebook::wxAuiNotebook at call with 5 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxAuiNotebook_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxAuiNotebook::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxAuiNotebook::Split(int page, int direction)
   Split performs a split operation programmatically. */
PHP_METHOD(php_wxAuiNotebook, Split)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::Split\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::Split call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long page0;
	long direction0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&page0, &direction0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page0, &direction0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::Split((size_t) page0, (int) direction0)\n\n");
				#endif

				((wxAuiNotebook_php*)native_object)->Split((size_t) page0, (int) direction0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::Split\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiNotebook::ShowWindowMenu()
   Shows the window menu for the active tab control associated with this notebook, and returns true if a selection was made. */
PHP_METHOD(php_wxAuiNotebook, ShowWindowMenu)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::ShowWindowMenu\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::ShowWindowMenu call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::ShowWindowMenu())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)native_object)->ShowWindowMenu());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::ShowWindowMenu\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiNotebook::SetUniformBitmapSize(wxSize size)
   Split performs a split operation programmatically. */
PHP_METHOD(php_wxAuiNotebook, SetUniformBitmapSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetUniformBitmapSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::SetUniformBitmapSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* size0 = 0;
	wxSize* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size0, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size0, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxSize*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::SetUniformBitmapSize(*(wxSize*) object_pointer0_0)\n\n");
				#endif

				((wxAuiNotebook_php*)native_object)->SetUniformBitmapSize(*(wxSize*) object_pointer0_0);

				references->AddReference(size0, "wxAuiNotebook::SetUniformBitmapSize at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::SetUniformBitmapSize\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiNotebook::SetTabCtrlHeight(int height)
   Sets the tab height. */
PHP_METHOD(php_wxAuiNotebook, SetTabCtrlHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetTabCtrlHeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::SetTabCtrlHeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long height0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&height0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::SetTabCtrlHeight((int) height0)\n\n");
				#endif

				((wxAuiNotebook_php*)native_object)->SetTabCtrlHeight((int) height0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::SetTabCtrlHeight\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiNotebook::SetSelectedFont(wxFont font)
   Sets the font for drawing selected tab labels. */
PHP_METHOD(php_wxAuiNotebook, SetSelectedFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetSelectedFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::SetSelectedFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* font0 = 0;
	wxFont* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxFont*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::SetSelectedFont(*(wxFont*) object_pointer0_0)\n\n");
				#endif

				((wxAuiNotebook_php*)native_object)->SetSelectedFont(*(wxFont*) object_pointer0_0);

				references->AddReference(font0, "wxAuiNotebook::SetSelectedFont at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::SetSelectedFont\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiNotebook::SetPageText(int page, string text)
   Sets the tab label for the page. */
PHP_METHOD(php_wxAuiNotebook, SetPageText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetPageText\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::SetPageText call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long page0;
	char* text0;
	long text_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&page0, &text0, &text_len0)\n");
		#endif

		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page0, &text0, &text_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::SetPageText((size_t) page0, wxString(text0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)native_object)->SetPageText((size_t) page0, wxString(text0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::SetPageText\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiNotebook::SetPageImage(int n, int imageId)
   Sets the image index for the given page. */
PHP_METHOD(php_wxAuiNotebook, SetPageImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetPageImage\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::SetPageImage call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	long imageId0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&n0, &imageId0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &imageId0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::SetPageImage((size_t) n0, (int) imageId0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)native_object)->SetPageImage((size_t) n0, (int) imageId0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::SetPageImage\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiNotebook::SetPageBitmap(int page, wxBitmap bitmap)
   Sets the bitmap for the page. */
PHP_METHOD(php_wxAuiNotebook, SetPageBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetPageBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::SetPageBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long page0;
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO' (&page0, &bitmap0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "lO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page0, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::SetPageBitmap((size_t) page0, *(wxBitmap*) object_pointer0_1))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)native_object)->SetPageBitmap((size_t) page0, *(wxBitmap*) object_pointer0_1));

				references->AddReference(bitmap0, "wxAuiNotebook::SetPageBitmap at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::SetPageBitmap\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiNotebook::SetNormalFont(wxFont font)
   Sets the font for drawing unselected tab labels. */
PHP_METHOD(php_wxAuiNotebook, SetNormalFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetNormalFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::SetNormalFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* font0 = 0;
	wxFont* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxFont*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::SetNormalFont(*(wxFont*) object_pointer0_0)\n\n");
				#endif

				((wxAuiNotebook_php*)native_object)->SetNormalFont(*(wxFont*) object_pointer0_0);

				references->AddReference(font0, "wxAuiNotebook::SetNormalFont at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::SetNormalFont\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiNotebook::SetMeasuringFont(wxFont font)
   Sets the font for measuring tab labels. */
PHP_METHOD(php_wxAuiNotebook, SetMeasuringFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetMeasuringFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::SetMeasuringFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* font0 = 0;
	wxFont* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxFont*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::SetMeasuringFont(*(wxFont*) object_pointer0_0)\n\n");
				#endif

				((wxAuiNotebook_php*)native_object)->SetMeasuringFont(*(wxFont*) object_pointer0_0);

				references->AddReference(font0, "wxAuiNotebook::SetMeasuringFont at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::SetMeasuringFont\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiNotebook::SetFont(wxFont font)
   Sets the font for drawing the tab labels, using a bold version of the font for selected tab labels. */
PHP_METHOD(php_wxAuiNotebook, SetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::SetFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* font0 = 0;
	wxFont* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxFont*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::SetFont(*(wxFont*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)native_object)->SetFont(*(wxFont*) object_pointer0_0));

				references->AddReference(font0, "wxAuiNotebook::SetFont at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::SetFont\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiNotebook::SetArtProvider(wxAuiTabArt &art)
   Sets the art provider to be used by the notebook. */
PHP_METHOD(php_wxAuiNotebook, SetArtProvider)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetArtProvider\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::SetArtProvider call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* art0 = 0;
	wxAuiTabArt* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&art0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &art0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(art0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiTabArt*) zend_object_store_get_object(art0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiTabArt*) zend_object_store_get_object(art0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxAuiTabArt*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXAUITABART_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'art' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(art0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'art' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::SetArtProvider((wxAuiTabArt*) object_pointer0_0)\n\n");
				#endif

				((wxAuiNotebook_php*)native_object)->SetArtProvider((wxAuiTabArt*) object_pointer0_0);

				references->AddReference(art0, "wxAuiNotebook::SetArtProvider at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::SetArtProvider\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiNotebook::RemovePage(int page)
   Removes a page, without deleting the window pointer. */
PHP_METHOD(php_wxAuiNotebook, RemovePage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::RemovePage\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::RemovePage call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long page0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&page0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::RemovePage((size_t) page0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)native_object)->RemovePage((size_t) page0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::RemovePage\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiNotebook::GetTabCtrlHeight()
   Returns the height of the tab control. */
PHP_METHOD(php_wxAuiNotebook, GetTabCtrlHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetTabCtrlHeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::GetTabCtrlHeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiNotebook::GetTabCtrlHeight())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiNotebook_php*)native_object)->GetTabCtrlHeight());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::GetTabCtrlHeight\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiNotebook::GetSelection()
   Returns the currently selected page. */
PHP_METHOD(php_wxAuiNotebook, GetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::GetSelection call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiNotebook::GetSelection())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiNotebook_php*)native_object)->GetSelection());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::GetSelection\n");
	}
}
/* }}} */

/* {{{ proto string wxAuiNotebook::GetPageText(int page)
   Returns the tab label for the page. */
PHP_METHOD(php_wxAuiNotebook, GetPageText)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetPageText\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::GetPageText call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long page0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&page0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiNotebook::GetPageText((size_t) page0).fn_str(), 1)\n\n");
				#endif

				wxString value_to_return1;
				value_to_return1 = ((wxAuiNotebook_php*)native_object)->GetPageText((size_t) page0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::GetPageText\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiNotebook::GetPageIndex(wxWindow &page_wnd)
   Returns the page index for the specified window. */
PHP_METHOD(php_wxAuiNotebook, GetPageIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetPageIndex\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::GetPageIndex call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* page_wnd0 = 0;
	wxWindow* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&page_wnd0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page_wnd0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(page_wnd0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(page_wnd0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(page_wnd0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxWindow*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'page_wnd' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(page_wnd0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'page_wnd' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiNotebook::GetPageIndex((wxWindow*) object_pointer0_0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiNotebook_php*)native_object)->GetPageIndex((wxWindow*) object_pointer0_0));

				references->AddReference(page_wnd0, "wxAuiNotebook::GetPageIndex at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::GetPageIndex\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiNotebook::GetPageCount()
   Returns the number of pages in the notebook. */
PHP_METHOD(php_wxAuiNotebook, GetPageCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetPageCount\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::GetPageCount call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiNotebook::GetPageCount())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiNotebook_php*)native_object)->GetPageCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::GetPageCount\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxAuiNotebook::GetPageBitmap(int page)
   Returns the tab bitmap for the page. */
PHP_METHOD(php_wxAuiNotebook, GetPageBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetPageBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::GetPageBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long page0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&page0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::GetPageBitmap((size_t) page0) to return new object\n\n");
				#endif

				wxBitmap value_to_return1;
				value_to_return1 = ((wxAuiNotebook_php*)native_object)->GetPageBitmap((size_t) page0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				((wxBitmap_php*)ptr)->phpObj = return_value;
				zo_wxBitmap* zo1 = (zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxBitmap_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::GetPageBitmap\n");
	}
}
/* }}} */

/* {{{ proto wxWindow wxAuiNotebook::GetPage(int page_idx)
   Returns the page specified by the given index. */
PHP_METHOD(php_wxAuiNotebook, GetPage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetPage\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::GetPage call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long page_idx0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&page_idx0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page_idx0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::GetPage((size_t) page_idx0) to return object pointer\n\n");
				#endif

				wxWindow_php* value_to_return1;
				value_to_return1 = (wxWindow_php*) ((wxAuiNotebook_php*)native_object)->GetPage((size_t) page_idx0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxWindow_entry);
					((zo_wxWindow*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxWindow_php*) value_to_return1;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return1 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiNotebook::GetPage at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::GetPage\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiNotebook::GetHeightForPageHeight(int pageHeight)
   Returns the desired height of the notebook for the given page height. */
PHP_METHOD(php_wxAuiNotebook, GetHeightForPageHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetHeightForPageHeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::GetHeightForPageHeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pageHeight0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pageHeight0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pageHeight0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiNotebook::GetHeightForPageHeight((int) pageHeight0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiNotebook_php*)native_object)->GetHeightForPageHeight((int) pageHeight0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::GetHeightForPageHeight\n");
	}
}
/* }}} */

/* {{{ proto wxWindow wxAuiNotebook::GetCurrentPage()
   Returns the currently selected page or NULL. */
PHP_METHOD(php_wxAuiNotebook, GetCurrentPage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetCurrentPage\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::GetCurrentPage call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::GetCurrentPage() to return object pointer\n\n");
				#endif

				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxAuiNotebook_php*)native_object)->GetCurrentPage();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxWindow_entry);
					((zo_wxWindow*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxWindow_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiNotebook::GetCurrentPage at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::GetCurrentPage\n");
	}
}
/* }}} */

/* {{{ proto wxAuiTabArt wxAuiNotebook::GetArtProvider()
   Returns the associated art provider. */
PHP_METHOD(php_wxAuiNotebook, GetArtProvider)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::GetArtProvider\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::GetArtProvider call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::GetArtProvider() to return object pointer\n\n");
				#endif

				wxAuiTabArt_php* value_to_return0;
				value_to_return0 = (wxAuiTabArt_php*) ((wxAuiNotebook_php*)native_object)->GetArtProvider();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiTabArt_entry);
					((zo_wxAuiTabArt*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiTabArt_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiNotebook::GetArtProvider at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::GetArtProvider\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiNotebook::DeletePage(int page)
   Deletes a page at the given index. */
PHP_METHOD(php_wxAuiNotebook, DeletePage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::DeletePage\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::DeletePage call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long page0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&page0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::DeletePage((size_t) page0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)native_object)->DeletePage((size_t) page0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::DeletePage\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiNotebook::DeleteAllPages()
   Deletes all pages. */
PHP_METHOD(php_wxAuiNotebook, DeleteAllPages)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::DeleteAllPages\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::DeleteAllPages call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::DeleteAllPages())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)native_object)->DeleteAllPages());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::DeleteAllPages\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiNotebook::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, int style)
   Creates the notebook window. */
PHP_METHOD(php_wxAuiNotebook, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::Create\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::Create call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	wxWindow* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	wxPoint* object_pointer0_2 = 0;
	zval* size0 = 0;
	wxSize* object_pointer0_3 = 0;
	long style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|lOOl' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0)\n");
		#endif

		char parse_parameters_string[] = "z|lOOl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(parent0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(parent0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxWindow*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'parent' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'parent' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pos0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pos0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxPoint*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'pos' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pos' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->native_object;
					object_pointer0_3 = (wxSize*) argument_native_object;
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::Create((wxWindow*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)native_object)->Create((wxWindow*) object_pointer0_0));

				references->AddReference(parent0, "wxAuiNotebook::Create at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)native_object)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxAuiNotebook::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)native_object)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxAuiNotebook::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxAuiNotebook::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)native_object)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxAuiNotebook::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxAuiNotebook::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxAuiNotebook::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)native_object)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0, "wxAuiNotebook::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxAuiNotebook::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxAuiNotebook::Create at call with 5 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::Create\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiNotebook::ChangeSelection(int n)
   Changes the selection for the given page, returning the previous selection. */
PHP_METHOD(php_wxAuiNotebook, ChangeSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::ChangeSelection\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::ChangeSelection call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiNotebook::ChangeSelection((size_t) n0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiNotebook_php*)native_object)->ChangeSelection((size_t) n0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::ChangeSelection\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiNotebook::AdvanceSelection(bool forward)
   Sets the selection to the next or previous page. */
PHP_METHOD(php_wxAuiNotebook, AdvanceSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::AdvanceSelection\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::AdvanceSelection call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool forward0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&forward0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &forward0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::AdvanceSelection()\n\n");
				#endif

				((wxAuiNotebook_php*)native_object)->AdvanceSelection();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiNotebook::AdvanceSelection(forward0)\n\n");
				#endif

				((wxAuiNotebook_php*)native_object)->AdvanceSelection(forward0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::AdvanceSelection\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiNotebook::AddPage(wxWindow &page, string caption, bool select, wxBitmap bitmap)
   Adds a page. */
PHP_METHOD(php_wxAuiNotebook, AddPage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::AddPage\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::AddPage call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* page0 = 0;
	wxWindow* object_pointer0_0 = 0;
	char* caption0;
	long caption_len0;
	bool select0;
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zs|bO' (&page0, &caption0, &caption_len0, &select0, &bitmap0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "zs|bO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &page0, &caption0, &caption_len0, &select0, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(page0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(page0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(page0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxWindow*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'page' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(page0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'page' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_3 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::AddPage((wxWindow*) object_pointer0_0, wxString(caption0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)native_object)->AddPage((wxWindow*) object_pointer0_0, wxString(caption0, wxConvUTF8)));

				references->AddReference(page0, "wxAuiNotebook::AddPage at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::AddPage((wxWindow*) object_pointer0_0, wxString(caption0, wxConvUTF8), select0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)native_object)->AddPage((wxWindow*) object_pointer0_0, wxString(caption0, wxConvUTF8), select0));

				references->AddReference(page0, "wxAuiNotebook::AddPage at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiNotebook::AddPage((wxWindow*) object_pointer0_0, wxString(caption0, wxConvUTF8), select0, *(wxBitmap*) object_pointer0_3))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiNotebook_php*)native_object)->AddPage((wxWindow*) object_pointer0_0, wxString(caption0, wxConvUTF8), select0, *(wxBitmap*) object_pointer0_3));

				references->AddReference(page0, "wxAuiNotebook::AddPage at call with 4 argument(s)");
				references->AddReference(bitmap0, "wxAuiNotebook::AddPage at call with 4 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::AddPage\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiNotebook::SetSelection(int new_page)
   Sets the page selection. */
PHP_METHOD(php_wxAuiNotebook, SetSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiNotebook::SetSelection\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiNotebook* current_object;
	wxphp_object_type current_object_type;
	wxAuiNotebook_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiNotebook*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiNotebook::SetSelection call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUINOTEBOOK_TYPE){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long new_page0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&new_page0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &new_page0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiNotebook::SetSelection((size_t) new_page0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiNotebook_php*)native_object)->SetSelection((size_t) new_page0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiNotebook::SetSelection\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxAuiTabArt_free(void *object TSRMLS_DC) 
{
    zo_wxAuiTabArt* custom_object = (zo_wxAuiTabArt*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiTabArt_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAuiTabArt done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxAuiTabArt_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiTabArt_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxAuiTabArt* custom_object;
    custom_object = (zo_wxAuiTabArt*) emalloc(sizeof(zo_wxAuiTabArt));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxAuiTabArt_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXAUITABART_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxAuiTabArt::SetSizingInfo(wxSize tab_ctrl_size, int tab_count)
   Sets sizing information. */
void wxAuiTabArt_php::SetSizingInfo(const wxSize& tab_ctrl_size, size_t tab_count)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::SetSizingInfo\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetSizingInfo", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxSize_entry);
	((zo_wxSize*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxSize_php*) &tab_ctrl_size;
	ZVAL_LONG(arguments[1], tab_count);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetSizingInfo", 13, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiTabArt::SetSizingInfo'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiTabArt::SetSelectedFont(wxFont font)
   Sets the font for drawing text for selected UI elements. */
void wxAuiTabArt_php::SetSelectedFont(const wxFont& font)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::SetSelectedFont\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetSelectedFont", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxFont_entry);
	((zo_wxFont*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxFont_php*) &font;
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetSelectedFont", 15, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiTabArt::SetSelectedFont'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiTabArt::SetNormalFont(wxFont font)
   Sets the normal font for drawing labels. */
void wxAuiTabArt_php::SetNormalFont(const wxFont& font)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::SetNormalFont\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetNormalFont", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxFont_entry);
	((zo_wxFont*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxFont_php*) &font;
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetNormalFont", 13, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiTabArt::SetNormalFont'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiTabArt::SetMeasuringFont(wxFont font)
   Sets the font used for calculating measurements. */
void wxAuiTabArt_php::SetMeasuringFont(const wxFont& font)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::SetMeasuringFont\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetMeasuringFont", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxFont_entry);
	((zo_wxFont*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxFont_php*) &font;
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetMeasuringFont", 16, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiTabArt::SetMeasuringFont'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiTabArt::SetFlags(int flags)
   Sets flags. */
void wxAuiTabArt_php::SetFlags(unsigned int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::SetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetFlags", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], flags);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetFlags", 8, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiTabArt::SetFlags'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiTabArt::SetColour(wxColour colour)
   Sets the colour of the inactive tabs. */
void wxAuiTabArt_php::SetColour(const wxColour& colour)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::SetColour\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetColour", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxColour_entry);
	((zo_wxColour*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxColour_php*) &colour;
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetColour", 9, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiTabArt::SetColour'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiTabArt::SetActiveColour(wxColour colour)
   Sets the colour of the selected tab. */
void wxAuiTabArt_php::SetActiveColour(const wxColour& colour)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::SetActiveColour\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetActiveColour", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxColour_entry);
	((zo_wxColour*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxColour_php*) &colour;
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetActiveColour", 15, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiTabArt::SetActiveColour'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto wxSize wxAuiTabArt::GetTabSize(wxDC &dc, wxWindow &wnd, string caption, wxBitmap bitmap, bool active, int close_button_state, int &x_extent)
   Returns the tab size for the given caption, bitmap and state. */
wxSize wxAuiTabArt_php::GetTabSize(wxDC& dc, wxWindow* wnd, const wxString& caption, const wxBitmap& bitmap, bool active, int close_button_state, int* x_extent)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::GetTabSize\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[7];
	zval *arguments[7];
	
	//Initilize arguments array
	for(int i=0; i<7; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetTabSize", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) wnd;
	temp_string = (char*)malloc(sizeof(wxChar)*(caption.size()+1));
	strcpy(temp_string, (const char *) caption.char_str());
	ZVAL_STRING(arguments[2], temp_string, 1);
	free(temp_string);
	object_init_ex(arguments[3], php_wxBitmap_entry);
	((zo_wxBitmap*) zend_object_store_get_object(arguments[3] TSRMLS_CC))->native_object = (wxBitmap_php*) &bitmap;
	ZVAL_BOOL(arguments[4], active);
	ZVAL_LONG(arguments[5], close_button_state);
	ZVAL_LONG(arguments[6], *x_extent);
		
	for(int i=0; i<7; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetTabSize", 10, &return_value, 7, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<7; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiTabArt::GetTabSize'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	if(Z_TYPE_P(return_value) == IS_OBJECT)
	{
		return_object = (void*) ((zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object;
	}

	//Threat it as a normal object on the calling function and not a php user space intiialized one
	((zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC))->is_user_initialized = 0;
	wxSize_php* var = (wxSize_php*) return_object;
	var->references.UnInitialize();

	return *(wxSize*) return_object;
	
}
/* }}} */

/* {{{ proto int wxAuiTabArt::GetIndentSize()
   Returns the indent size. */
int wxAuiTabArt_php::GetIndentSize()
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::GetIndentSize\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetIndentSize", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetIndentSize", 13, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiTabArt::GetIndentSize'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (int) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto  wxAuiTabArt::DrawButton(wxDC &dc, wxWindow &wnd, wxRect in_rect, int bitmap_id, int button_state, int orientation, wxRect &out_rect)
   Draws a button. */
void wxAuiTabArt_php::DrawButton(wxDC& dc, wxWindow* wnd, const wxRect& in_rect, int bitmap_id, int button_state, int orientation, wxRect* out_rect)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::DrawButton\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[7];
	zval *arguments[7];
	
	//Initilize arguments array
	for(int i=0; i<7; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawButton", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) wnd;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &in_rect;
	ZVAL_LONG(arguments[3], bitmap_id);
	ZVAL_LONG(arguments[4], button_state);
	ZVAL_LONG(arguments[5], orientation);
	object_init_ex(arguments[6], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[6] TSRMLS_CC))->native_object = (wxRect_php*) out_rect;
		
	for(int i=0; i<7; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawButton", 10, &return_value, 7, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<7; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiTabArt::DrawButton'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiTabArt::DrawBackground(wxDC &dc, wxWindow &wnd, wxRect rect)
   Draws a background on the given area. */
void wxAuiTabArt_php::DrawBackground(wxDC& dc, wxWindow* wnd, const wxRect& rect)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::DrawBackground\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawBackground", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) wnd;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawBackground", 14, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiTabArt::DrawBackground'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto wxAuiTabArt wxAuiTabArt::Clone()
   Clones the art object. */
wxAuiTabArt* wxAuiTabArt_php::Clone()
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiTabArt::Clone\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "Clone", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "Clone", 5, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiTabArt::Clone'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	if(Z_TYPE_P(return_value) == IS_OBJECT)
	{
		return_object = (void*) ((zo_wxAuiTabArt*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object;
	}

	//Threat it as a normal object on the calling function and not a php user space intiialized one
	((zo_wxAuiTabArt*) zend_object_store_get_object(return_value TSRMLS_CC))->is_user_initialized = 0;
	wxAuiTabArt_php* var = (wxAuiTabArt_php*) return_object;
	var->references.UnInitialize();

	return (wxAuiTabArt*) return_object;
	
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxAuiDockArt_free(void *object TSRMLS_DC) 
{
    zo_wxAuiDockArt* custom_object = (zo_wxAuiDockArt*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiDockArt_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAuiDockArt done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxAuiDockArt_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiDockArt_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxAuiDockArt* custom_object;
    custom_object = (zo_wxAuiDockArt*) emalloc(sizeof(zo_wxAuiDockArt));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxAuiDockArt_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXAUIDOCKART_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxAuiDockArt::wxAuiDockArt()
   Constructor. */
PHP_METHOD(php_wxAuiDockArt, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiDockArt::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiDockArt* current_object;
	wxAuiDockArt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxAuiDockArt_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxAuiDockArt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxAuiDockArt::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxAuiDockArt::SetMetric(int id, int new_val)
   Set a certain setting with the value new_val. */
void wxAuiDockArt_php::SetMetric(int id, int new_val)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::SetMetric\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetMetric", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], id);
	ZVAL_LONG(arguments[1], new_val);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetMetric", 9, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiDockArt::SetMetric'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiDockArt::SetFont(int id, wxFont font)
   Set a font setting. */
void wxAuiDockArt_php::SetFont(int id, const wxFont& font)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::SetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetFont", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], id);
	object_init_ex(arguments[1], php_wxFont_entry);
	((zo_wxFont*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxFont_php*) &font;
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetFont", 7, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiDockArt::SetFont'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto int wxAuiDockArt::GetMetric(int id)
   Get the value of a certain setting. */
int wxAuiDockArt_php::GetMetric(int id)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::GetMetric\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetMetric", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], id);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetMetric", 9, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiDockArt::GetMetric'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (int) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto  wxAuiDockArt::SetColour(int id, wxColour colour)
   Set a certain setting with the value colour. */
void wxAuiDockArt_php::SetColour(int id, const wxColour& colour)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::SetColour\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetColour", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], id);
	object_init_ex(arguments[1], php_wxColour_entry);
	((zo_wxColour*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxColour_php*) &colour;
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetColour", 9, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiDockArt::SetColour'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto wxFont wxAuiDockArt::GetFont(int id)
   Get a font setting. */
wxFont wxAuiDockArt_php::GetFont(int id)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::GetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetFont", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], id);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetFont", 7, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiDockArt::GetFont'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	if(Z_TYPE_P(return_value) == IS_OBJECT)
	{
		return_object = (void*) ((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object;
	}

	//Threat it as a normal object on the calling function and not a php user space intiialized one
	((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->is_user_initialized = 0;
	wxFont_php* var = (wxFont_php*) return_object;
	var->references.UnInitialize();

	return *(wxFont*) return_object;
	
}
/* }}} */

/* {{{ proto wxColour wxAuiDockArt::GetColour(int id)
   Get the colour of a certain setting. */
wxColour wxAuiDockArt_php::GetColour(int id)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::GetColour\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetColour", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], id);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetColour", 9, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiDockArt::GetColour'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	if(Z_TYPE_P(return_value) == IS_OBJECT)
	{
		return_object = (void*) ((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object;
	}

	//Threat it as a normal object on the calling function and not a php user space intiialized one
	((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->is_user_initialized = 0;
	wxColour_php* var = (wxColour_php*) return_object;
	var->references.UnInitialize();

	return *(wxColour*) return_object;
	
}
/* }}} */

/* {{{ proto  wxAuiDockArt::DrawSash(wxDC &dc, wxWindow &window, int orientation, wxRect rect)
   Draws a sash between two windows. */
void wxAuiDockArt_php::DrawSash(wxDC& dc, wxWindow* window, int orientation, const wxRect& rect)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::DrawSash\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawSash", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) window;
	ZVAL_LONG(arguments[2], orientation);
	object_init_ex(arguments[3], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[3] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawSash", 8, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiDockArt::DrawSash'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiDockArt::DrawPaneButton(wxDC &dc, wxWindow &window, int button, int button_state, wxRect rect, wxAuiPaneInfo &pane)
   Draws a button in the pane's title bar. */
void wxAuiDockArt_php::DrawPaneButton(wxDC& dc, wxWindow* window, int button, int button_state, const wxRect& rect, wxAuiPaneInfo& pane)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::DrawPaneButton\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[6];
	zval *arguments[6];
	
	//Initilize arguments array
	for(int i=0; i<6; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawPaneButton", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) window;
	ZVAL_LONG(arguments[2], button);
	ZVAL_LONG(arguments[3], button_state);
	object_init_ex(arguments[4], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[4] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	object_init_ex(arguments[5], php_wxAuiPaneInfo_entry);
	((zo_wxAuiPaneInfo*) zend_object_store_get_object(arguments[5] TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) &pane;
		
	for(int i=0; i<6; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawPaneButton", 14, &return_value, 6, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<6; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiDockArt::DrawPaneButton'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiDockArt::DrawGripper(wxDC &dc, wxWindow &window, wxRect rect, wxAuiPaneInfo &pane)
   Draws a gripper. */
void wxAuiDockArt_php::DrawGripper(wxDC& dc, wxWindow* window, const wxRect& rect, wxAuiPaneInfo& pane)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::DrawGripper\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawGripper", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) window;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	object_init_ex(arguments[3], php_wxAuiPaneInfo_entry);
	((zo_wxAuiPaneInfo*) zend_object_store_get_object(arguments[3] TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) &pane;
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawGripper", 11, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiDockArt::DrawGripper'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiDockArt::DrawCaption(wxDC &dc, wxWindow &window, string text, wxRect rect, wxAuiPaneInfo &pane)
   Draws a caption. */
void wxAuiDockArt_php::DrawCaption(wxDC& dc, wxWindow* window, const wxString& text, const wxRect& rect, wxAuiPaneInfo& pane)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::DrawCaption\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[5];
	zval *arguments[5];
	
	//Initilize arguments array
	for(int i=0; i<5; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawCaption", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) window;
	temp_string = (char*)malloc(sizeof(wxChar)*(text.size()+1));
	strcpy(temp_string, (const char *) text.char_str());
	ZVAL_STRING(arguments[2], temp_string, 1);
	free(temp_string);
	object_init_ex(arguments[3], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[3] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	object_init_ex(arguments[4], php_wxAuiPaneInfo_entry);
	((zo_wxAuiPaneInfo*) zend_object_store_get_object(arguments[4] TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) &pane;
		
	for(int i=0; i<5; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawCaption", 11, &return_value, 5, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<5; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiDockArt::DrawCaption'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiDockArt::DrawBorder(wxDC &dc, wxWindow &window, wxRect rect, wxAuiPaneInfo &pane)
   Draws a border. */
void wxAuiDockArt_php::DrawBorder(wxDC& dc, wxWindow* window, const wxRect& rect, wxAuiPaneInfo& pane)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::DrawBorder\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawBorder", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) window;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	object_init_ex(arguments[3], php_wxAuiPaneInfo_entry);
	((zo_wxAuiPaneInfo*) zend_object_store_get_object(arguments[3] TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) &pane;
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawBorder", 10, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiDockArt::DrawBorder'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxAuiDockArt::DrawBackground(wxDC &dc, wxWindow &window, int orientation, wxRect rect)
   Draws a background. */
void wxAuiDockArt_php::DrawBackground(wxDC& dc, wxWindow* window, int orientation, const wxRect& rect)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiDockArt::DrawBackground\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawBackground", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[1], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxWindow_php*) window;
	ZVAL_LONG(arguments[2], orientation);
	object_init_ex(arguments[3], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[3] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawBackground", 14, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxAuiDockArt::DrawBackground'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxAuiManager_free(void *object TSRMLS_DC) 
{
    zo_wxAuiManager* custom_object = (zo_wxAuiManager*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate delete call for wxAuiManager on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxAuiManager_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiManager_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxAuiManager* custom_object;
    custom_object = (zo_wxAuiManager*) emalloc(sizeof(zo_wxAuiManager));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxAuiManager_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXAUIMANAGER_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxAuiManager::wxAuiManager(wxWindow &managed_wnd, int flags)
   Constructor. */
PHP_METHOD(php_wxAuiManager, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* managed_wnd0 = 0;
	wxWindow* object_pointer0_0 = 0;
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|zl' (&managed_wnd0, &flags0)\n");
		#endif

		char parse_parameters_string[] = "|zl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &managed_wnd0, &flags0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(managed_wnd0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(managed_wnd0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(managed_wnd0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxWindow*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'managed_wnd' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(managed_wnd0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'managed_wnd' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxAuiManager_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0)\n");
				#endif

				native_object = new wxAuiManager_php((wxWindow*) object_pointer0_0);

				native_object->references.Initialize();
				((wxAuiManager_php*) native_object)->references.AddReference(managed_wnd0, "wxAuiManager::wxAuiManager at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer0_0, (unsigned int) flags0)\n");
				#endif

				native_object = new wxAuiManager_php((wxWindow*) object_pointer0_0, (unsigned int) flags0);

				native_object->references.Initialize();
				((wxAuiManager_php*) native_object)->references.AddReference(managed_wnd0, "wxAuiManager::wxAuiManager at call with 2 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxAuiManager::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxAuiManager::Update()
   This method is called after any number of changes are made to any of the managed panes. */
PHP_METHOD(php_wxAuiManager, Update)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::Update\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::Update call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::Update()\n\n");
				#endif

				((wxAuiManager_php*)native_object)->Update();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::Update\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiManager::UnInit()
   Uninitializes the framework and should be called before a managed frame or window is destroyed. */
PHP_METHOD(php_wxAuiManager, UnInit)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::UnInit\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::UnInit call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::UnInit()\n\n");
				#endif

				((wxAuiManager_php*)native_object)->UnInit();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::UnInit\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiManager::ShowHint(wxRect rect)
   This function is used by controls to explicitly show a hint window at the specified rectangle. */
PHP_METHOD(php_wxAuiManager, ShowHint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::ShowHint\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::ShowHint call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* rect0 = 0;
	wxRect* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxRect*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::ShowHint(*(wxRect*) object_pointer0_0)\n\n");
				#endif

				((wxAuiManager_php*)native_object)->ShowHint(*(wxRect*) object_pointer0_0);

				references->AddReference(rect0, "wxAuiManager::ShowHint at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::ShowHint\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiManager::SetManagedWindow(wxWindow &managed_wnd)
   Called to specify the frame or window which is to be managed by wxAuiManager. */
PHP_METHOD(php_wxAuiManager, SetManagedWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::SetManagedWindow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::SetManagedWindow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* managed_wnd0 = 0;
	wxWindow* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&managed_wnd0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &managed_wnd0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(managed_wnd0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(managed_wnd0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(managed_wnd0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxWindow*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'managed_wnd' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(managed_wnd0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'managed_wnd' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::SetManagedWindow((wxWindow*) object_pointer0_0)\n\n");
				#endif

				((wxAuiManager_php*)native_object)->SetManagedWindow((wxWindow*) object_pointer0_0);

				references->AddReference(managed_wnd0, "wxAuiManager::SetManagedWindow at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::SetManagedWindow\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiManager::SetDockSizeConstraint(float widthpct, float heightpct)
   When a user creates a new dock by dragging a window into a docked position, often times the large size of the window will create a dock that is unwieldly large. */
PHP_METHOD(php_wxAuiManager, SetDockSizeConstraint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::SetDockSizeConstraint\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::SetDockSizeConstraint call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	double widthpct0;
	double heightpct0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'dd' (&widthpct0, &heightpct0)\n");
		#endif

		char parse_parameters_string[] = "dd";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &widthpct0, &heightpct0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::SetDockSizeConstraint(widthpct0, heightpct0)\n\n");
				#endif

				((wxAuiManager_php*)native_object)->SetDockSizeConstraint(widthpct0, heightpct0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::SetDockSizeConstraint\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiManager::SetFlags(int flags)
   This method is used to specify wxAuiManagerOption's flags. */
PHP_METHOD(php_wxAuiManager, SetFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::SetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::SetFlags call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flags0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flags0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flags0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::SetFlags((unsigned int) flags0)\n\n");
				#endif

				((wxAuiManager_php*)native_object)->SetFlags((unsigned int) flags0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::SetFlags\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiManager::SetArtProvider(wxAuiDockArt &art_provider)
   Instructs wxAuiManager to use art provider specified by parameter art_provider for all drawing calls. */
PHP_METHOD(php_wxAuiManager, SetArtProvider)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::SetArtProvider\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::SetArtProvider call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* art_provider0 = 0;
	wxAuiDockArt* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&art_provider0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &art_provider0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(art_provider0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiDockArt*) zend_object_store_get_object(art_provider0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiDockArt*) zend_object_store_get_object(art_provider0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxAuiDockArt*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXAUIDOCKART_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'art_provider' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(art_provider0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'art_provider' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::SetArtProvider((wxAuiDockArt*) object_pointer0_0)\n\n");
				#endif

				((wxAuiManager_php*)native_object)->SetArtProvider((wxAuiDockArt*) object_pointer0_0);

				references->AddReference(art_provider0, "wxAuiManager::SetArtProvider at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::SetArtProvider\n");
	}
}
/* }}} */

/* {{{ proto string wxAuiManager::SavePerspective()
   Saves the entire user interface layout into an encoded wxString, which can then be stored by the application (probably using wxConfig). */
PHP_METHOD(php_wxAuiManager, SavePerspective)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::SavePerspective\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::SavePerspective call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiManager::SavePerspective().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxAuiManager_php*)native_object)->SavePerspective();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::SavePerspective\n");
	}
}
/* }}} */

/* {{{ proto string wxAuiManager::SavePaneInfo(wxAuiPaneInfo &pane)
   SavePaneInfo() is similar to SavePerspective, with the exception that it only saves information about a single pane. */
PHP_METHOD(php_wxAuiManager, SavePaneInfo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::SavePaneInfo\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::SavePaneInfo call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* pane0 = 0;
	wxAuiPaneInfo* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pane0, php_wxAuiPaneInfo_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pane0, php_wxAuiPaneInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pane0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiPaneInfo*) zend_object_store_get_object(pane0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiPaneInfo*) zend_object_store_get_object(pane0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxAuiPaneInfo*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'pane' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pane0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pane' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxAuiManager::SavePaneInfo(*(wxAuiPaneInfo*) object_pointer0_0).fn_str(), 1)\n\n");
				#endif

				wxString value_to_return1;
				value_to_return1 = ((wxAuiManager_php*)native_object)->SavePaneInfo(*(wxAuiPaneInfo*) object_pointer0_0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);

				references->AddReference(pane0, "wxAuiManager::SavePaneInfo at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::SavePaneInfo\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiManager::ProcessDockResult(wxAuiPaneInfo &target, wxAuiPaneInfo new_pos)
   ProcessDockResult() is a protected member of the wxAUI layout manager. */
bool wxAuiManager_php::ProcessDockResult(wxAuiPaneInfo& target, const wxAuiPaneInfo& new_pos)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxAuiManager::ProcessDockResult\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "ProcessDockResult", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxAuiPaneInfo_entry);
	((zo_wxAuiPaneInfo*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) &target;
	object_init_ex(arguments[1], php_wxAuiPaneInfo_entry);
	((zo_wxAuiPaneInfo*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) &new_pos;
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "ProcessDockResult", 17, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxAuiManager::ProcessDockResult(target, new_pos);
}
/* }}} */

/* {{{ proto bool wxAuiManager::LoadPerspective(string perspective, bool update)
   Loads a saved perspective. */
PHP_METHOD(php_wxAuiManager, LoadPerspective)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::LoadPerspective\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::LoadPerspective call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* perspective0;
	long perspective_len0;
	bool update0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|b' (&perspective0, &perspective_len0, &update0)\n");
		#endif

		char parse_parameters_string[] = "s|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &perspective0, &perspective_len0, &update0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::LoadPerspective(wxString(perspective0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiManager_php*)native_object)->LoadPerspective(wxString(perspective0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::LoadPerspective(wxString(perspective0, wxConvUTF8), update0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiManager_php*)native_object)->LoadPerspective(wxString(perspective0, wxConvUTF8), update0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::LoadPerspective\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiManager::LoadPaneInfo(string pane_part, wxAuiPaneInfo &pane)
   LoadPaneInfo() is similar to LoadPerspective, with the exception that it only loads information about a single pane. */
PHP_METHOD(php_wxAuiManager, LoadPaneInfo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::LoadPaneInfo\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::LoadPaneInfo call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* pane_part0;
	long pane_part_len0;
	zval* pane0 = 0;
	wxAuiPaneInfo* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sO' (&pane_part0, &pane_part_len0, &pane0, php_wxAuiPaneInfo_entry)\n");
		#endif

		char parse_parameters_string[] = "sO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pane_part0, &pane_part_len0, &pane0, php_wxAuiPaneInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(pane0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiPaneInfo*) zend_object_store_get_object(pane0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiPaneInfo*) zend_object_store_get_object(pane0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxAuiPaneInfo*) argument_native_object;
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter 'pane' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pane0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pane' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::LoadPaneInfo(wxString(pane_part0, wxConvUTF8), *(wxAuiPaneInfo*) object_pointer0_1)\n\n");
				#endif

				((wxAuiManager_php*)native_object)->LoadPaneInfo(wxString(pane_part0, wxConvUTF8), *(wxAuiPaneInfo*) object_pointer0_1);

				references->AddReference(pane0, "wxAuiManager::LoadPaneInfo at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::LoadPaneInfo\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiManager::InsertPane(wxWindow &window, wxAuiPaneInfo insert_location, int insert_level)
   This method is used to insert either a previously unmanaged pane window into the frame manager, or to insert a currently managed pane somewhere else. */
PHP_METHOD(php_wxAuiManager, InsertPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::InsertPane\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::InsertPane call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* window0 = 0;
	wxWindow* object_pointer0_0 = 0;
	zval* insert_location0 = 0;
	wxAuiPaneInfo* object_pointer0_1 = 0;
	long insert_level0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zO|l' (&window0, &insert_location0, php_wxAuiPaneInfo_entry, &insert_level0)\n");
		#endif

		char parse_parameters_string[] = "zO|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &window0, &insert_location0, php_wxAuiPaneInfo_entry, &insert_level0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(window0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(window0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(window0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxWindow*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'window' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(window0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'window' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(insert_location0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiPaneInfo*) zend_object_store_get_object(insert_location0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiPaneInfo*) zend_object_store_get_object(insert_location0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxAuiPaneInfo*) argument_native_object;
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter 'insert_location' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(insert_location0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'insert_location' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::InsertPane((wxWindow*) object_pointer0_0, *(wxAuiPaneInfo*) object_pointer0_1))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiManager_php*)native_object)->InsertPane((wxWindow*) object_pointer0_0, *(wxAuiPaneInfo*) object_pointer0_1));

				references->AddReference(window0, "wxAuiManager::InsertPane at call with 2 argument(s)");
				references->AddReference(insert_location0, "wxAuiManager::InsertPane at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::InsertPane((wxWindow*) object_pointer0_0, *(wxAuiPaneInfo*) object_pointer0_1, (int) insert_level0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiManager_php*)native_object)->InsertPane((wxWindow*) object_pointer0_0, *(wxAuiPaneInfo*) object_pointer0_1, (int) insert_level0));

				references->AddReference(window0, "wxAuiManager::InsertPane at call with 3 argument(s)");
				references->AddReference(insert_location0, "wxAuiManager::InsertPane at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::InsertPane\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiManager::HideHint()
   HideHint() hides any docking hint that may be visible. */
PHP_METHOD(php_wxAuiManager, HideHint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::HideHint\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::HideHint call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::HideHint()\n\n");
				#endif

				((wxAuiManager_php*)native_object)->HideHint();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::HideHint\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiManager::GetPane(string name)
   GetPane() is used to lookup a wxAuiPaneInfo object either by window pointer or by pane name, which acts as a unique id for a window pane. */
PHP_METHOD(php_wxAuiManager, GetPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::GetPane\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::GetPane call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* window1 = 0;
	wxWindow* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&window1)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &window1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(window1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(window1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(window1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxWindow*) argument_native_object;
					if (!object_pointer1_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'window' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(window1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'window' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::GetPane(wxString(name0, wxConvUTF8)) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiManager_php*)native_object)->GetPane(wxString(name0, wxConvUTF8));

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiManager::GetPane at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::GetPane((wxWindow*) object_pointer1_0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiManager_php*)native_object)->GetPane((wxWindow*) object_pointer1_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiManager::GetPane at call with 1 argument(s)");
				}

				references->AddReference(window1, "wxAuiManager::GetPane at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::GetPane\n");
	}
}
/* }}} */

/* {{{ proto wxAuiManager wxAuiManager::GetManager(wxWindow &window)
   Calling this method will return the wxAuiManager for a given window. */
PHP_METHOD(php_wxAuiManager, GetManager)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::GetManager\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::GetManager call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* window0 = 0;
	wxWindow* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&window0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &window0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(window0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(window0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(window0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxWindow*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'window' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(window0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'window' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxAuiManager::GetManager((wxWindow*) object_pointer0_0) to return object pointer\n\n");
				#endif

				wxAuiManager_php* value_to_return1;
				value_to_return1 = (wxAuiManager_php*) wxAuiManager::GetManager((wxWindow*) object_pointer0_0);
				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiManager_entry);
					((zo_wxAuiManager*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiManager_php*) value_to_return1;
				}



				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::GetManager\n");
	}
}
/* }}} */

/* {{{ proto wxWindow wxAuiManager::GetManagedWindow()
   Returns the frame currently being managed by wxAuiManager. */
PHP_METHOD(php_wxAuiManager, GetManagedWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::GetManagedWindow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::GetManagedWindow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::GetManagedWindow() to return object pointer\n\n");
				#endif

				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxAuiManager_php*)native_object)->GetManagedWindow();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxWindow_entry);
					((zo_wxWindow*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxWindow_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiManager::GetManagedWindow at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::GetManagedWindow\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiManager::GetFlags()
   Returns the current wxAuiManagerOption's flags. */
PHP_METHOD(php_wxAuiManager, GetFlags)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::GetFlags\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::GetFlags call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiManager::GetFlags())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiManager_php*)native_object)->GetFlags());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::GetFlags\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiManager::GetDockSizeConstraint(float &widthpct, float &heightpct)
   Returns the current dock constraint values. */
PHP_METHOD(php_wxAuiManager, GetDockSizeConstraint)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::GetDockSizeConstraint\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::GetDockSizeConstraint call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	double* widthpct0;
	zval* widthpct0_ref;
	double* heightpct0;
	zval* heightpct0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'dd' (widthpct0, heightpct0)\n");
		#endif

		char parse_parameters_string[] = "dd";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, widthpct0, heightpct0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &widthpct0_ref, &heightpct0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::GetDockSizeConstraint(widthpct0, heightpct0)\n\n");
				#endif

				((wxAuiManager_php*)native_object)->GetDockSizeConstraint(widthpct0, heightpct0);

				size_t elements_returned0_0 = sizeof(widthpct0)/sizeof(*widthpct0);
				array_init(widthpct0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(widthpct0_ref, widthpct0[i]);
				}
				size_t elements_returned0_1 = sizeof(heightpct0)/sizeof(*heightpct0);
				array_init(heightpct0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(heightpct0_ref, heightpct0[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::GetDockSizeConstraint\n");
	}
}
/* }}} */

/* {{{ proto wxAuiDockArt wxAuiManager::GetArtProvider()
   Returns the current art provider being used. */
PHP_METHOD(php_wxAuiManager, GetArtProvider)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::GetArtProvider\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::GetArtProvider call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManager::GetArtProvider() to return object pointer\n\n");
				#endif

				wxAuiDockArt_php* value_to_return0;
				value_to_return0 = (wxAuiDockArt_php*) ((wxAuiManager_php*)native_object)->GetArtProvider();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiDockArt_entry);
					((zo_wxAuiDockArt*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiDockArt_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiManager::GetArtProvider at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::GetArtProvider\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiManager::DetachPane(wxWindow &window)
   Tells the wxAuiManager to stop managing the pane specified by window. */
PHP_METHOD(php_wxAuiManager, DetachPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::DetachPane\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::DetachPane call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* window0 = 0;
	wxWindow* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&window0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &window0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(window0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(window0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(window0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxWindow*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'window' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(window0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'window' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::DetachPane((wxWindow*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiManager_php*)native_object)->DetachPane((wxWindow*) object_pointer0_0));

				references->AddReference(window0, "wxAuiManager::DetachPane at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::DetachPane\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiManager::AddPane(wxWindow &window, wxAuiPaneInfo pane_info, wxPoint drop_pos)
   AddPane() tells the frame manager to start managing a child window. */
PHP_METHOD(php_wxAuiManager, AddPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManager::AddPane\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManager* current_object;
	wxphp_object_type current_object_type;
	wxAuiManager_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManager*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManager::AddPane call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGER_TYPE){
				references = &((wxAuiManager_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* window0 = 0;
	wxWindow* object_pointer0_0 = 0;
	zval* pane_info0 = 0;
	wxAuiPaneInfo* object_pointer0_1 = 0;
	zval* drop_pos0 = 0;
	wxPoint* object_pointer0_2 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* window1 = 0;
	wxWindow* object_pointer1_0 = 0;
	long direction1;
	char* caption1;
	long caption_len1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* window2 = 0;
	wxWindow* object_pointer2_0 = 0;
	zval* pane_info2 = 0;
	wxAuiPaneInfo* object_pointer2_1 = 0;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zOO' (&window0, &pane_info0, php_wxAuiPaneInfo_entry, &drop_pos0, php_wxPoint_entry)\n");
		#endif

		char parse_parameters_string[] = "zOO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &window0, &pane_info0, php_wxAuiPaneInfo_entry, &drop_pos0, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(window0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(window0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(window0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxWindow*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(window0) != IS_NULL)
				{
					goto overload1;
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(pane_info0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiPaneInfo*) zend_object_store_get_object(pane_info0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiPaneInfo*) zend_object_store_get_object(pane_info0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxAuiPaneInfo*) argument_native_object;
					if (!object_pointer0_1 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(pane_info0) != IS_NULL)
				{
					goto overload1;
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(drop_pos0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(drop_pos0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(drop_pos0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxPoint*) argument_native_object;
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(drop_pos0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|ls' (&window1, &direction1, &caption1, &caption_len1)\n");
		#endif

		char parse_parameters_string[] = "z|ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &window1, &direction1, &caption1, &caption_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(window1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(window1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(window1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxWindow*) argument_native_object;
					if (!object_pointer1_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(window1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zO' (&window2, &pane_info2, php_wxAuiPaneInfo_entry)\n");
		#endif

		char parse_parameters_string[] = "zO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &window2, &pane_info2, php_wxAuiPaneInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(window2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(window2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(window2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxWindow*) argument_native_object;
					if (!object_pointer2_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'window' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(window2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'window' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(pane_info2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiPaneInfo*) zend_object_store_get_object(pane_info2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiPaneInfo*) zend_object_store_get_object(pane_info2 TSRMLS_CC))->native_object;
					object_pointer2_1 = (wxAuiPaneInfo*) argument_native_object;
					if (!object_pointer2_1 )
					{
						zend_error(E_ERROR, "Parameter 'pane_info' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pane_info2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pane_info' not null, could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::AddPane((wxWindow*) object_pointer0_0, *(wxAuiPaneInfo*) object_pointer0_1, *(wxPoint*) object_pointer0_2))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiManager_php*)native_object)->AddPane((wxWindow*) object_pointer0_0, *(wxAuiPaneInfo*) object_pointer0_1, *(wxPoint*) object_pointer0_2));

				references->AddReference(window0, "wxAuiManager::AddPane at call with 3 argument(s)");
				references->AddReference(pane_info0, "wxAuiManager::AddPane at call with 3 argument(s)");
				references->AddReference(drop_pos0, "wxAuiManager::AddPane at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::AddPane((wxWindow*) object_pointer1_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiManager_php*)native_object)->AddPane((wxWindow*) object_pointer1_0));

				references->AddReference(window1, "wxAuiManager::AddPane at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::AddPane((wxWindow*) object_pointer1_0, (int) direction1))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiManager_php*)native_object)->AddPane((wxWindow*) object_pointer1_0, (int) direction1));

				references->AddReference(window1, "wxAuiManager::AddPane at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::AddPane((wxWindow*) object_pointer1_0, (int) direction1, wxString(caption1, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiManager_php*)native_object)->AddPane((wxWindow*) object_pointer1_0, (int) direction1, wxString(caption1, wxConvUTF8)));

				references->AddReference(window1, "wxAuiManager::AddPane at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManager::AddPane((wxWindow*) object_pointer2_0, *(wxAuiPaneInfo*) object_pointer2_1))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiManager_php*)native_object)->AddPane((wxWindow*) object_pointer2_0, *(wxAuiPaneInfo*) object_pointer2_1));

				references->AddReference(window2, "wxAuiManager::AddPane at call with 2 argument(s)");
				references->AddReference(pane_info2, "wxAuiManager::AddPane at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManager::AddPane\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxAuiPaneInfo_free(void *object TSRMLS_DC) 
{
    zo_wxAuiPaneInfo* custom_object = (zo_wxAuiPaneInfo*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiPaneInfo_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAuiPaneInfo done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxAuiPaneInfo_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiPaneInfo_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxAuiPaneInfo* custom_object;
    custom_object = (zo_wxAuiPaneInfo*) emalloc(sizeof(zo_wxAuiPaneInfo));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxAuiPaneInfo_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXAUIPANEINFO_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxAuiPaneInfo::wxAuiPaneInfo(wxAuiPaneInfo c)
   Copy constructor. */
PHP_METHOD(php_wxAuiPaneInfo, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* c0 = 0;
	wxAuiPaneInfo* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&c0, php_wxAuiPaneInfo_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &c0, php_wxAuiPaneInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(c0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiPaneInfo*) zend_object_store_get_object(c0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiPaneInfo*) zend_object_store_get_object(c0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxAuiPaneInfo*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(c0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxAuiPaneInfo*) object_pointer0_0)\n");
				#endif

				native_object = new wxAuiPaneInfo_php(*(wxAuiPaneInfo*) object_pointer0_0);

				native_object->references.Initialize();
				((wxAuiPaneInfo_php*) native_object)->references.AddReference(c0, "wxAuiPaneInfo::wxAuiPaneInfo at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxAuiPaneInfo_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxAuiPaneInfo::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Window(wxWindow &w)
   Window() assigns the window pointer that the wxAuiPaneInfo should use. */
PHP_METHOD(php_wxAuiPaneInfo, Window)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Window\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Window call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* w0 = 0;
	wxWindow* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&w0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &w0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(w0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(w0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(w0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxWindow*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXMEDIACTRL_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'w' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(w0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'w' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Window((wxWindow*) object_pointer0_0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Window((wxWindow*) object_pointer0_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Window at call with 1 argument(s)");
				}

				references->AddReference(w0, "wxAuiPaneInfo::Window at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Window\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::TopDockable(bool b)
   TopDockable() indicates whether a pane can be docked at the top of the frame. */
PHP_METHOD(php_wxAuiPaneInfo, TopDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::TopDockable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::TopDockable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::TopDockable() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->TopDockable();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::TopDockable at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::TopDockable(b0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->TopDockable(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::TopDockable at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::TopDockable\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Top()
   Top() sets the pane dock position to the top of the frame. */
PHP_METHOD(php_wxAuiPaneInfo, Top)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Top\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Top call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Top() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Top();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Top at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Top\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::ToolbarPane()
   ToolbarPane() specifies that the pane should adopt the default toolbar pane settings. */
PHP_METHOD(php_wxAuiPaneInfo, ToolbarPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::ToolbarPane\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::ToolbarPane call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::ToolbarPane() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->ToolbarPane();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::ToolbarPane at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::ToolbarPane\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Show(bool show)
   Show() indicates that a pane should be shown. */
PHP_METHOD(php_wxAuiPaneInfo, Show)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Show\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Show call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool show0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&show0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &show0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Show() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Show();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Show at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Show(show0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Show(show0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Show at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Show\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::SetFlag(int flag, bool option_state)
   SetFlag() turns the property given by flag on or off with the option_state parameter. */
PHP_METHOD(php_wxAuiPaneInfo, SetFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::SetFlag\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::SetFlag call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flag0;
	bool option_state0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lb' (&flag0, &option_state0)\n");
		#endif

		char parse_parameters_string[] = "lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0, &option_state0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::SetFlag((int) flag0, option_state0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return2;
				value_to_return2 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->SetFlag((int) flag0, option_state0);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return2;
				}

				if((void*)value_to_return2 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::SetFlag at call with 2 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::SetFlag\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiPaneInfo::SafeSet(wxAuiPaneInfo source)
   Write the safe parts of a newly loaded PaneInfo structure "source" into "this" used on loading perspectives etc. */
PHP_METHOD(php_wxAuiPaneInfo, SafeSet)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::SafeSet\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::SafeSet call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* source0 = 0;
	wxAuiPaneInfo* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&source0, php_wxAuiPaneInfo_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &source0, php_wxAuiPaneInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(source0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiPaneInfo*) zend_object_store_get_object(source0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiPaneInfo*) zend_object_store_get_object(source0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxAuiPaneInfo*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'source' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(source0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'source' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::SafeSet(*(wxAuiPaneInfo*) object_pointer0_0)\n\n");
				#endif

				((wxAuiPaneInfo_php*)native_object)->SafeSet(*(wxAuiPaneInfo*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::SafeSet\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Row(int row)
   Row() determines the row of the docked pane. */
PHP_METHOD(php_wxAuiPaneInfo, Row)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Row\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Row call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Row((int) row0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Row((int) row0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Row at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Row\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::RightDockable(bool b)
   RightDockable() indicates whether a pane can be docked on the right of the frame. */
PHP_METHOD(php_wxAuiPaneInfo, RightDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::RightDockable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::RightDockable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::RightDockable() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->RightDockable();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::RightDockable at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::RightDockable(b0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->RightDockable(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::RightDockable at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::RightDockable\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Right()
   Right() sets the pane dock position to the right side of the frame. */
PHP_METHOD(php_wxAuiPaneInfo, Right)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Right\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Right call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Right() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Right();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Right at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Right\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Resizable(bool resizable)
   Resizable() allows a pane to be resized if the parameter is true, and forces it to be a fixed size if the parameter is false. */
PHP_METHOD(php_wxAuiPaneInfo, Resizable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Resizable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Resizable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool resizable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&resizable0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &resizable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Resizable() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Resizable();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Resizable at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Resizable(resizable0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Resizable(resizable0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Resizable at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Resizable\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Position(int pos)
   Position() determines the position of the docked pane. */
PHP_METHOD(php_wxAuiPaneInfo, Position)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Position\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Position call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pos0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Position((int) pos0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Position((int) pos0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Position at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Position\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::PinButton(bool visible)
   PinButton() indicates that a pin button should be drawn for the pane. */
PHP_METHOD(php_wxAuiPaneInfo, PinButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::PinButton\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::PinButton call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&visible0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::PinButton() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->PinButton();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::PinButton at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::PinButton(visible0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->PinButton(visible0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::PinButton at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::PinButton\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::PaneBorder(bool visible)
   PaneBorder indicates that a border should be drawn for the pane. */
PHP_METHOD(php_wxAuiPaneInfo, PaneBorder)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::PaneBorder\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::PaneBorder call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&visible0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::PaneBorder() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->PaneBorder();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::PaneBorder at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::PaneBorder(visible0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->PaneBorder(visible0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::PaneBorder at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::PaneBorder\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Name(string n)
   Name() sets the name of the pane so it can be referenced in lookup functions. */
PHP_METHOD(php_wxAuiPaneInfo, Name)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Name\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Name call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* n0;
	long n_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&n0, &n_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &n_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Name(wxString(n0, wxConvUTF8)) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Name(wxString(n0, wxConvUTF8));

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Name at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Name\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Movable(bool b)
   Movable indicates whether a frame can be moved. */
PHP_METHOD(php_wxAuiPaneInfo, Movable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Movable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Movable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Movable() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Movable();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Movable at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Movable(b0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Movable(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Movable at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Movable\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::MinimizeButton(bool visible)
   MinimizeButton() indicates that a minimize button should be drawn for the pane. */
PHP_METHOD(php_wxAuiPaneInfo, MinimizeButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::MinimizeButton\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::MinimizeButton call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&visible0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::MinimizeButton() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->MinimizeButton();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::MinimizeButton at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::MinimizeButton(visible0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->MinimizeButton(visible0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::MinimizeButton at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::MinimizeButton\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::MinSize(int x, int y)
   MinSize() sets the minimum size of the pane. */
PHP_METHOD(php_wxAuiPaneInfo, MinSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::MinSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::MinSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* size1 = 0;
	wxSize* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size1, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size1, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxSize*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::MinSize((int) x0, (int) y0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return2;
				value_to_return2 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->MinSize((int) x0, (int) y0);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return2;
				}

				if((void*)value_to_return2 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::MinSize at call with 2 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::MinSize(*(wxSize*) object_pointer1_0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->MinSize(*(wxSize*) object_pointer1_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::MinSize at call with 1 argument(s)");
				}

				references->AddReference(size1, "wxAuiPaneInfo::MinSize at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::MinSize\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::MaximizeButton(bool visible)
   MaximizeButton() indicates that a maximize button should be drawn for the pane. */
PHP_METHOD(php_wxAuiPaneInfo, MaximizeButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::MaximizeButton\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::MaximizeButton call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&visible0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::MaximizeButton() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->MaximizeButton();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::MaximizeButton at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::MaximizeButton(visible0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->MaximizeButton(visible0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::MaximizeButton at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::MaximizeButton\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::MaxSize(int x, int y)
   MaxSize() sets the maximum size of the pane. */
PHP_METHOD(php_wxAuiPaneInfo, MaxSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::MaxSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::MaxSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* size1 = 0;
	wxSize* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size1, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size1, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxSize*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::MaxSize((int) x0, (int) y0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return2;
				value_to_return2 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->MaxSize((int) x0, (int) y0);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return2;
				}

				if((void*)value_to_return2 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::MaxSize at call with 2 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::MaxSize(*(wxSize*) object_pointer1_0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->MaxSize(*(wxSize*) object_pointer1_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::MaxSize at call with 1 argument(s)");
				}

				references->AddReference(size1, "wxAuiPaneInfo::MaxSize at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::MaxSize\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::LeftDockable(bool b)
   LeftDockable() indicates whether a pane can be docked on the left of the frame. */
PHP_METHOD(php_wxAuiPaneInfo, LeftDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::LeftDockable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::LeftDockable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::LeftDockable() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->LeftDockable();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::LeftDockable at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::LeftDockable(b0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->LeftDockable(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::LeftDockable at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::LeftDockable\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Left()
   Left() sets the pane dock position to the left side of the frame. */
PHP_METHOD(php_wxAuiPaneInfo, Left)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Left\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Left call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Left() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Left();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Left at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Left\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Layer(int layer)
   Layer() determines the layer of the docked pane. */
PHP_METHOD(php_wxAuiPaneInfo, Layer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Layer\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Layer call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long layer0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&layer0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &layer0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Layer((int) layer0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Layer((int) layer0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Layer at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Layer\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::IsTopDockable()
   IsTopDockable() returns true if the pane can be docked at the top of the managed frame. */
PHP_METHOD(php_wxAuiPaneInfo, IsTopDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsTopDockable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::IsTopDockable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsTopDockable())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->IsTopDockable());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::IsTopDockable\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::IsToolbar()
   IsToolbar() returns true if the pane contains a toolbar. */
PHP_METHOD(php_wxAuiPaneInfo, IsToolbar)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsToolbar\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::IsToolbar call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsToolbar())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->IsToolbar());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::IsToolbar\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::IsShown()
   IsShown() returns true if the pane is currently shown. */
PHP_METHOD(php_wxAuiPaneInfo, IsShown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsShown\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::IsShown call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsShown())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->IsShown());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::IsShown\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::IsRightDockable()
   IsRightDockable() returns true if the pane can be docked on the right of the managed frame. */
PHP_METHOD(php_wxAuiPaneInfo, IsRightDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsRightDockable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::IsRightDockable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsRightDockable())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->IsRightDockable());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::IsRightDockable\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::IsResizable()
   IsResizable() returns true if the pane can be resized. */
PHP_METHOD(php_wxAuiPaneInfo, IsResizable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsResizable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::IsResizable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsResizable())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->IsResizable());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::IsResizable\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::IsOk()
   IsOk() returns true if the wxAuiPaneInfo structure is valid. */
PHP_METHOD(php_wxAuiPaneInfo, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::IsOk call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsOk())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->IsOk());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::IsOk\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::IsMovable()
   IsMoveable() returns true if the docked frame can be undocked or moved to another dock position. */
PHP_METHOD(php_wxAuiPaneInfo, IsMovable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsMovable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::IsMovable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsMovable())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->IsMovable());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::IsMovable\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::IsLeftDockable()
   IsLeftDockable() returns true if the pane can be docked on the left of the managed frame. */
PHP_METHOD(php_wxAuiPaneInfo, IsLeftDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsLeftDockable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::IsLeftDockable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsLeftDockable())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->IsLeftDockable());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::IsLeftDockable\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::IsFloating()
   IsFloating() returns true if the pane is floating. */
PHP_METHOD(php_wxAuiPaneInfo, IsFloating)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsFloating\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::IsFloating call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsFloating())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->IsFloating());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::IsFloating\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::IsFloatable()
   IsFloatable() returns true if the pane can be undocked and displayed as a floating window. */
PHP_METHOD(php_wxAuiPaneInfo, IsFloatable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsFloatable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::IsFloatable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsFloatable())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->IsFloatable());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::IsFloatable\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::IsFixed()
   IsFixed() returns true if the pane cannot be resized. */
PHP_METHOD(php_wxAuiPaneInfo, IsFixed)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsFixed\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::IsFixed call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsFixed())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->IsFixed());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::IsFixed\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::IsDocked()
   IsDocked() returns true if the pane is currently docked. */
PHP_METHOD(php_wxAuiPaneInfo, IsDocked)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsDocked\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::IsDocked call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsDocked())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->IsDocked());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::IsDocked\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::IsDockable()
   Returns true if the pane can be docked at any side. */
PHP_METHOD(php_wxAuiPaneInfo, IsDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsDockable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::IsDockable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsDockable())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->IsDockable());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::IsDockable\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::IsBottomDockable()
   IsBottomDockable() returns true if the pane can be docked at the bottom of the managed frame. */
PHP_METHOD(php_wxAuiPaneInfo, IsBottomDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::IsBottomDockable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::IsBottomDockable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::IsBottomDockable())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->IsBottomDockable());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::IsBottomDockable\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Icon(wxBitmap b)
   Icon() sets the icon of the pane. */
PHP_METHOD(php_wxAuiPaneInfo, Icon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Icon\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Icon call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* b0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&b0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(b0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(b0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(b0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'b' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(b0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'b' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Icon(*(wxBitmap*) object_pointer0_0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Icon(*(wxBitmap*) object_pointer0_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Icon at call with 1 argument(s)");
				}

				references->AddReference(b0, "wxAuiPaneInfo::Icon at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Icon\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Hide()
   Hide() indicates that a pane should be hidden. */
PHP_METHOD(php_wxAuiPaneInfo, Hide)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Hide\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Hide call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Hide() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Hide();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Hide at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Hide\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::HasPinButton()
   HasPinButton() returns true if the pane displays a button to float the pane. */
PHP_METHOD(php_wxAuiPaneInfo, HasPinButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasPinButton\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::HasPinButton call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasPinButton())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->HasPinButton());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::HasPinButton\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::HasMinimizeButton()
   HasMinimizeButton() returns true if the pane displays a button to minimize the pane. */
PHP_METHOD(php_wxAuiPaneInfo, HasMinimizeButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasMinimizeButton\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::HasMinimizeButton call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasMinimizeButton())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->HasMinimizeButton());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::HasMinimizeButton\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::HasMaximizeButton()
   HasMaximizeButton() returns true if the pane displays a button to maximize the pane. */
PHP_METHOD(php_wxAuiPaneInfo, HasMaximizeButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasMaximizeButton\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::HasMaximizeButton call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasMaximizeButton())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->HasMaximizeButton());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::HasMaximizeButton\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::HasGripperTop()
   HasGripper() returns true if the pane displays a gripper at the top. */
PHP_METHOD(php_wxAuiPaneInfo, HasGripperTop)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasGripperTop\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::HasGripperTop call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasGripperTop())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->HasGripperTop());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::HasGripperTop\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::HasGripper()
   HasGripper() returns true if the pane displays a gripper. */
PHP_METHOD(php_wxAuiPaneInfo, HasGripper)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasGripper\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::HasGripper call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasGripper())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->HasGripper());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::HasGripper\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::HasFlag(int flag)
   HasFlag() returns true if the property specified by flag is active for the pane. */
PHP_METHOD(php_wxAuiPaneInfo, HasFlag)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasFlag\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::HasFlag call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long flag0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&flag0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &flag0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasFlag((int) flag0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->HasFlag((int) flag0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::HasFlag\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::HasCloseButton()
   HasCloseButton() returns true if the pane displays a button to close the pane. */
PHP_METHOD(php_wxAuiPaneInfo, HasCloseButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasCloseButton\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::HasCloseButton call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasCloseButton())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->HasCloseButton());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::HasCloseButton\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::HasCaption()
   HasCaption() returns true if the pane displays a caption. */
PHP_METHOD(php_wxAuiPaneInfo, HasCaption)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasCaption\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::HasCaption call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasCaption())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->HasCaption());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::HasCaption\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiPaneInfo::HasBorder()
   HasBorder() returns true if the pane displays a border. */
PHP_METHOD(php_wxAuiPaneInfo, HasBorder)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::HasBorder\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::HasBorder call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiPaneInfo::HasBorder())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiPaneInfo_php*)native_object)->HasBorder());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::HasBorder\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::GripperTop(bool attop)
   GripperTop() indicates that a gripper should be drawn at the top of the pane. */
PHP_METHOD(php_wxAuiPaneInfo, GripperTop)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::GripperTop\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::GripperTop call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool attop0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&attop0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &attop0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::GripperTop() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->GripperTop();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::GripperTop at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::GripperTop(attop0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->GripperTop(attop0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::GripperTop at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::GripperTop\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Gripper(bool visible)
   Gripper() indicates that a gripper should be drawn for the pane. */
PHP_METHOD(php_wxAuiPaneInfo, Gripper)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Gripper\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Gripper call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&visible0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Gripper() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Gripper();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Gripper at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Gripper(visible0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Gripper(visible0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Gripper at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Gripper\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::FloatingSize(int x, int y)
   FloatingSize() sets the size of the floating pane. */
PHP_METHOD(php_wxAuiPaneInfo, FloatingSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::FloatingSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::FloatingSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* size1 = 0;
	wxSize* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size1, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size1, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxSize*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::FloatingSize((int) x0, (int) y0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return2;
				value_to_return2 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->FloatingSize((int) x0, (int) y0);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return2;
				}

				if((void*)value_to_return2 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::FloatingSize at call with 2 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::FloatingSize(*(wxSize*) object_pointer1_0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->FloatingSize(*(wxSize*) object_pointer1_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::FloatingSize at call with 1 argument(s)");
				}

				references->AddReference(size1, "wxAuiPaneInfo::FloatingSize at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::FloatingSize\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::FloatingPosition(int x, int y)
   FloatingPosition() sets the position of the floating pane. */
PHP_METHOD(php_wxAuiPaneInfo, FloatingPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::FloatingPosition\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::FloatingPosition call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* pos1 = 0;
	wxPoint* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pos1, php_wxPoint_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos1, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pos1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pos1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pos1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxPoint*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'pos' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pos' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::FloatingPosition((int) x0, (int) y0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return2;
				value_to_return2 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->FloatingPosition((int) x0, (int) y0);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return2;
				}

				if((void*)value_to_return2 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::FloatingPosition at call with 2 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::FloatingPosition(*(wxPoint*) object_pointer1_0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->FloatingPosition(*(wxPoint*) object_pointer1_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::FloatingPosition at call with 1 argument(s)");
				}

				references->AddReference(pos1, "wxAuiPaneInfo::FloatingPosition at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::FloatingPosition\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Floatable(bool b)
   Floatable() sets whether the user will be able to undock a pane and turn it into a floating window. */
PHP_METHOD(php_wxAuiPaneInfo, Floatable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Floatable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Floatable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Floatable() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Floatable();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Floatable at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Floatable(b0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Floatable(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Floatable at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Floatable\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Float()
   Float() indicates that a pane should be floated. */
PHP_METHOD(php_wxAuiPaneInfo, Float)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Float\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Float call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Float() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Float();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Float at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Float\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Fixed()
   Fixed() forces a pane to be fixed size so that it cannot be resized. */
PHP_METHOD(php_wxAuiPaneInfo, Fixed)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Fixed\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Fixed call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Fixed() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Fixed();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Fixed at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Fixed\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Dockable(bool b)
   Dockable() specifies whether a frame can be docked or not. */
PHP_METHOD(php_wxAuiPaneInfo, Dockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Dockable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Dockable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Dockable() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Dockable();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Dockable at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Dockable(b0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Dockable(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Dockable at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Dockable\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::DockFixed(bool b)
   DockFixed() causes the containing dock to have no resize sash. */
PHP_METHOD(php_wxAuiPaneInfo, DockFixed)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::DockFixed\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::DockFixed call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::DockFixed() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->DockFixed();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::DockFixed at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::DockFixed(b0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->DockFixed(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::DockFixed at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::DockFixed\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Dock()
   Dock() indicates that a pane should be docked. */
PHP_METHOD(php_wxAuiPaneInfo, Dock)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Dock\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Dock call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Dock() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Dock();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Dock at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Dock\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Direction(int direction)
   Direction() determines the direction of the docked pane. */
PHP_METHOD(php_wxAuiPaneInfo, Direction)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Direction\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Direction call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long direction0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&direction0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &direction0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Direction((int) direction0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Direction((int) direction0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Direction at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Direction\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::DestroyOnClose(bool b)
   DestroyOnClose() indicates whether a pane should be destroyed when it is closed. */
PHP_METHOD(php_wxAuiPaneInfo, DestroyOnClose)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::DestroyOnClose\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::DestroyOnClose call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::DestroyOnClose() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->DestroyOnClose();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::DestroyOnClose at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::DestroyOnClose(b0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->DestroyOnClose(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::DestroyOnClose at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::DestroyOnClose\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::DefaultPane()
   DefaultPane() specifies that the pane should adopt the default pane settings. */
PHP_METHOD(php_wxAuiPaneInfo, DefaultPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::DefaultPane\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::DefaultPane call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::DefaultPane() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->DefaultPane();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::DefaultPane at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::DefaultPane\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::CloseButton(bool visible)
   CloseButton() indicates that a close button should be drawn for the pane. */
PHP_METHOD(php_wxAuiPaneInfo, CloseButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::CloseButton\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::CloseButton call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&visible0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::CloseButton() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->CloseButton();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::CloseButton at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::CloseButton(visible0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->CloseButton(visible0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::CloseButton at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::CloseButton\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::CentrePane()
   CentrePane() specifies that the pane should adopt the default center pane settings. */
PHP_METHOD(php_wxAuiPaneInfo, CentrePane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::CentrePane\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::CentrePane call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::CentrePane() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->CentrePane();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::CentrePane at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::CentrePane\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Centre()
   Center() sets the pane dock position to the left side of the frame. */
PHP_METHOD(php_wxAuiPaneInfo, Centre)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Centre\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Centre call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Centre() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Centre();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Centre at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Centre\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::CenterPane()
   CentrePane() specifies that the pane should adopt the default center pane settings. */
PHP_METHOD(php_wxAuiPaneInfo, CenterPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::CenterPane\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::CenterPane call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::CenterPane() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->CenterPane();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::CenterPane at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::CenterPane\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Center()
   Center() sets the pane dock position to the left side of the frame. */
PHP_METHOD(php_wxAuiPaneInfo, Center)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Center\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Center call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Center() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Center();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Center at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Center\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::CaptionVisible(bool visible)
   CaptionVisible indicates that a pane caption should be visible. */
PHP_METHOD(php_wxAuiPaneInfo, CaptionVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::CaptionVisible\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::CaptionVisible call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool visible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&visible0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &visible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::CaptionVisible() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->CaptionVisible();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::CaptionVisible at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::CaptionVisible(visible0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->CaptionVisible(visible0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::CaptionVisible at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::CaptionVisible\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Caption(string c)
   Caption() sets the caption of the pane. */
PHP_METHOD(php_wxAuiPaneInfo, Caption)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Caption\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Caption call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* c0;
	long c_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&c0, &c_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &c0, &c_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Caption(wxString(c0, wxConvUTF8)) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Caption(wxString(c0, wxConvUTF8));

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Caption at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Caption\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::BottomDockable(bool b)
   BottomDockable() indicates whether a pane can be docked at the bottom of the frame. */
PHP_METHOD(php_wxAuiPaneInfo, BottomDockable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::BottomDockable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::BottomDockable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&b0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::BottomDockable() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->BottomDockable();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::BottomDockable at call with 0 argument(s)");
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::BottomDockable(b0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->BottomDockable(b0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::BottomDockable at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::BottomDockable\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::Bottom()
   Bottom() sets the pane dock position to the bottom side of the frame. */
PHP_METHOD(php_wxAuiPaneInfo, Bottom)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::Bottom\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::Bottom call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::Bottom() to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->Bottom();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::Bottom at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::Bottom\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiPaneInfo::BestSize(int x, int y)
   BestSize() sets the ideal size for the pane. */
PHP_METHOD(php_wxAuiPaneInfo, BestSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiPaneInfo::BestSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiPaneInfo* current_object;
	wxphp_object_type current_object_type;
	wxAuiPaneInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiPaneInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiPaneInfo::BestSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIPANEINFO_TYPE){
				references = &((wxAuiPaneInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* size1 = 0;
	wxSize* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size1, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size1, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxSize*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::BestSize((int) x0, (int) y0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return2;
				value_to_return2 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->BestSize((int) x0, (int) y0);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return2;
				}

				if((void*)value_to_return2 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::BestSize at call with 2 argument(s)");
				}


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiPaneInfo::BestSize(*(wxSize*) object_pointer1_0) to return object reference\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return1;
				value_to_return1 = (wxAuiPaneInfo_php*) &((wxAuiPaneInfo_php*)native_object)->BestSize(*(wxSize*) object_pointer1_0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxAuiPaneInfo::BestSize at call with 1 argument(s)");
				}

				references->AddReference(size1, "wxAuiPaneInfo::BestSize at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiPaneInfo::BestSize\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxAuiManagerEvent_free(void *object TSRMLS_DC) 
{
    zo_wxAuiManagerEvent* custom_object = (zo_wxAuiManagerEvent*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiManagerEvent_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAuiManagerEvent done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxAuiManagerEvent_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAuiManagerEvent_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxAuiManagerEvent* custom_object;
    custom_object = (zo_wxAuiManagerEvent*) emalloc(sizeof(zo_wxAuiManagerEvent));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxAuiManagerEvent_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXAUIMANAGEREVENT_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxAuiManagerEvent::wxAuiManagerEvent(int type)
   Constructor. */
PHP_METHOD(php_wxAuiManagerEvent, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManagerEvent::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManagerEvent* current_object;
	wxAuiManagerEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	long type0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&type0)\n");
		#endif

		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &type0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxAuiManagerEvent_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxEventType) type0)\n");
				#endif

				native_object = new wxAuiManagerEvent_php((wxEventType) type0);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxAuiManagerEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxAuiManagerEvent::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxAuiManagerEvent::Veto(bool veto)
   Cancels the action indicated by this event if CanVeto() is true. */
PHP_METHOD(php_wxAuiManagerEvent, Veto)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManagerEvent::Veto\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManagerEvent* current_object;
	wxphp_object_type current_object_type;
	wxAuiManagerEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManagerEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManagerEvent::Veto call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGEREVENT_TYPE){
				references = &((wxAuiManagerEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool veto0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&veto0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &veto0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManagerEvent::Veto()\n\n");
				#endif

				((wxAuiManagerEvent_php*)native_object)->Veto();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManagerEvent::Veto(veto0)\n\n");
				#endif

				((wxAuiManagerEvent_php*)native_object)->Veto(veto0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManagerEvent::Veto\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiManagerEvent::SetPane(wxAuiPaneInfo &pane)
   Sets the pane this event is associated with. */
PHP_METHOD(php_wxAuiManagerEvent, SetPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManagerEvent::SetPane\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManagerEvent* current_object;
	wxphp_object_type current_object_type;
	wxAuiManagerEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManagerEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManagerEvent::SetPane call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGEREVENT_TYPE){
				references = &((wxAuiManagerEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* pane0 = 0;
	wxAuiPaneInfo* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&pane0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pane0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pane0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiPaneInfo*) zend_object_store_get_object(pane0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiPaneInfo*) zend_object_store_get_object(pane0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxAuiPaneInfo*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXAUIPANEINFO_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'pane' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pane0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pane' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManagerEvent::SetPane((wxAuiPaneInfo*) object_pointer0_0)\n\n");
				#endif

				((wxAuiManagerEvent_php*)native_object)->SetPane((wxAuiPaneInfo*) object_pointer0_0);

				references->AddReference(pane0, "wxAuiManagerEvent::SetPane at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManagerEvent::SetPane\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiManagerEvent::SetManager(wxAuiManager &manager)
   Sets the wxAuiManager this event is associated with. */
PHP_METHOD(php_wxAuiManagerEvent, SetManager)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManagerEvent::SetManager\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManagerEvent* current_object;
	wxphp_object_type current_object_type;
	wxAuiManagerEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManagerEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManagerEvent::SetManager call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGEREVENT_TYPE){
				references = &((wxAuiManagerEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* manager0 = 0;
	wxAuiManager* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&manager0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &manager0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(manager0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAuiManager*) zend_object_store_get_object(manager0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAuiManager*) zend_object_store_get_object(manager0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxAuiManager*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXAUIMANAGER_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'manager' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(manager0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'manager' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManagerEvent::SetManager((wxAuiManager*) object_pointer0_0)\n\n");
				#endif

				((wxAuiManagerEvent_php*)native_object)->SetManager((wxAuiManager*) object_pointer0_0);

				references->AddReference(manager0, "wxAuiManagerEvent::SetManager at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManagerEvent::SetManager\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiManagerEvent::SetDC(wxDC &pdc) */
PHP_METHOD(php_wxAuiManagerEvent, SetDC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManagerEvent::SetDC\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManagerEvent* current_object;
	wxphp_object_type current_object_type;
	wxAuiManagerEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManagerEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManagerEvent::SetDC call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGEREVENT_TYPE){
				references = &((wxAuiManagerEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* pdc0 = 0;
	wxDC* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&pdc0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pdc0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pdc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(pdc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(pdc0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDC*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'pdc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pdc0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pdc' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManagerEvent::SetDC((wxDC*) object_pointer0_0)\n\n");
				#endif

				((wxAuiManagerEvent_php*)native_object)->SetDC((wxDC*) object_pointer0_0);

				references->AddReference(pdc0, "wxAuiManagerEvent::SetDC at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManagerEvent::SetDC\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiManagerEvent::SetCanVeto(bool can_veto)
   Sets whether or not this event can be vetoed. */
PHP_METHOD(php_wxAuiManagerEvent, SetCanVeto)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManagerEvent::SetCanVeto\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManagerEvent* current_object;
	wxphp_object_type current_object_type;
	wxAuiManagerEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManagerEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManagerEvent::SetCanVeto call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGEREVENT_TYPE){
				references = &((wxAuiManagerEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool can_veto0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&can_veto0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &can_veto0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManagerEvent::SetCanVeto(can_veto0)\n\n");
				#endif

				((wxAuiManagerEvent_php*)native_object)->SetCanVeto(can_veto0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManagerEvent::SetCanVeto\n");
	}
}
/* }}} */

/* {{{ proto  wxAuiManagerEvent::SetButton(int button)
   Sets the ID of the button clicked that triggered this event. */
PHP_METHOD(php_wxAuiManagerEvent, SetButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManagerEvent::SetButton\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManagerEvent* current_object;
	wxphp_object_type current_object_type;
	wxAuiManagerEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManagerEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManagerEvent::SetButton call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGEREVENT_TYPE){
				references = &((wxAuiManagerEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long button0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&button0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &button0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManagerEvent::SetButton((int) button0)\n\n");
				#endif

				((wxAuiManagerEvent_php*)native_object)->SetButton((int) button0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManagerEvent::SetButton\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiManagerEvent::GetVeto() */
PHP_METHOD(php_wxAuiManagerEvent, GetVeto)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManagerEvent::GetVeto\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManagerEvent* current_object;
	wxphp_object_type current_object_type;
	wxAuiManagerEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManagerEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManagerEvent::GetVeto call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGEREVENT_TYPE){
				references = &((wxAuiManagerEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManagerEvent::GetVeto())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiManagerEvent_php*)native_object)->GetVeto());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManagerEvent::GetVeto\n");
	}
}
/* }}} */

/* {{{ proto wxAuiPaneInfo wxAuiManagerEvent::GetPane() */
PHP_METHOD(php_wxAuiManagerEvent, GetPane)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManagerEvent::GetPane\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManagerEvent* current_object;
	wxphp_object_type current_object_type;
	wxAuiManagerEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManagerEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManagerEvent::GetPane call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGEREVENT_TYPE){
				references = &((wxAuiManagerEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManagerEvent::GetPane() to return object pointer\n\n");
				#endif

				wxAuiPaneInfo_php* value_to_return0;
				value_to_return0 = (wxAuiPaneInfo_php*) ((wxAuiManagerEvent_php*)native_object)->GetPane();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiPaneInfo_entry);
					((zo_wxAuiPaneInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiPaneInfo_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiManagerEvent::GetPane at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManagerEvent::GetPane\n");
	}
}
/* }}} */

/* {{{ proto wxAuiManager wxAuiManagerEvent::GetManager() */
PHP_METHOD(php_wxAuiManagerEvent, GetManager)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManagerEvent::GetManager\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManagerEvent* current_object;
	wxphp_object_type current_object_type;
	wxAuiManagerEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManagerEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManagerEvent::GetManager call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGEREVENT_TYPE){
				references = &((wxAuiManagerEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManagerEvent::GetManager() to return object pointer\n\n");
				#endif

				wxAuiManager_php* value_to_return0;
				value_to_return0 = (wxAuiManager_php*) ((wxAuiManagerEvent_php*)native_object)->GetManager();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxAuiManager_entry);
					((zo_wxAuiManager*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxAuiManager_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiManagerEvent::GetManager at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManagerEvent::GetManager\n");
	}
}
/* }}} */

/* {{{ proto wxDC wxAuiManagerEvent::GetDC() */
PHP_METHOD(php_wxAuiManagerEvent, GetDC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManagerEvent::GetDC\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManagerEvent* current_object;
	wxphp_object_type current_object_type;
	wxAuiManagerEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManagerEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManagerEvent::GetDC call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGEREVENT_TYPE){
				references = &((wxAuiManagerEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAuiManagerEvent::GetDC() to return object pointer\n\n");
				#endif

				wxDC_php* value_to_return0;
				value_to_return0 = (wxDC_php*) ((wxAuiManagerEvent_php*)native_object)->GetDC();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxDC_entry);
					((zo_wxDC*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxDC_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxAuiManagerEvent::GetDC at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManagerEvent::GetDC\n");
	}
}
/* }}} */

/* {{{ proto int wxAuiManagerEvent::GetButton() */
PHP_METHOD(php_wxAuiManagerEvent, GetButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManagerEvent::GetButton\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManagerEvent* current_object;
	wxphp_object_type current_object_type;
	wxAuiManagerEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManagerEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManagerEvent::GetButton call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGEREVENT_TYPE){
				references = &((wxAuiManagerEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAuiManagerEvent::GetButton())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAuiManagerEvent_php*)native_object)->GetButton());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManagerEvent::GetButton\n");
	}
}
/* }}} */

/* {{{ proto bool wxAuiManagerEvent::CanVeto() */
PHP_METHOD(php_wxAuiManagerEvent, CanVeto)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAuiManagerEvent::CanVeto\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAuiManagerEvent* current_object;
	wxphp_object_type current_object_type;
	wxAuiManagerEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAuiManagerEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAuiManagerEvent::CanVeto call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXAUIMANAGEREVENT_TYPE){
				references = &((wxAuiManagerEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAuiManagerEvent::CanVeto())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAuiManagerEvent_php*)native_object)->CanVeto());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAuiManagerEvent::CanVeto\n");
	}
}
/* }}} */

