/*
 * @author Mário Soares
 * @contributors Jefferson González
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "webview.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


BEGIN_EXTERN_C()
void php_wxFileHistory_free(void *object TSRMLS_DC) 
{
    zo_wxFileHistory* custom_object = (zo_wxFileHistory*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFileHistory_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxFileHistory done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxFileHistory_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFileHistory_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxFileHistory* custom_object;
    custom_object = (zo_wxFileHistory*) emalloc(sizeof(zo_wxFileHistory));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFILEHISTORY_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxFileHistory_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxFileHistory::AddFileToHistory(string filename)
   Adds a file to the file history list, if the object has a pointer to an appropriate file menu. */
PHP_METHOD(php_wxFileHistory, AddFileToHistory)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileHistory::AddFileToHistory\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileHistory* current_object;
	wxphp_object_type current_object_type;
	wxFileHistory_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileHistory*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileHistory::AddFileToHistory call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILEHISTORY_TYPE){
				references = &((wxFileHistory_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* filename0;
	long filename_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&filename0, &filename_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filename0, &filename_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileHistory::AddFileToHistory(wxString(filename0, wxConvUTF8))\n\n");
				#endif

				((wxFileHistory_php*)native_object)->AddFileToHistory(wxString(filename0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileHistory::AddFileToHistory\n");
	}
}
/* }}} */

/* {{{ proto  wxFileHistory::AddFilesToMenu()
   Appends the files in the history list, to all menus managed by the file history object. */
PHP_METHOD(php_wxFileHistory, AddFilesToMenu)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileHistory::AddFilesToMenu\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileHistory* current_object;
	wxphp_object_type current_object_type;
	wxFileHistory_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileHistory*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileHistory::AddFilesToMenu call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILEHISTORY_TYPE){
				references = &((wxFileHistory_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* menu1 = 0;
	wxMenu* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&menu1)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &menu1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(menu1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxMenu*) zend_object_store_get_object(menu1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxMenu*) zend_object_store_get_object(menu1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxMenu*) argument_native_object;
					if (!object_pointer1_0 || (argument_type != PHP_WXMENU_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'menu' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(menu1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'menu' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileHistory::AddFilesToMenu()\n\n");
				#endif

				((wxFileHistory_php*)native_object)->AddFilesToMenu();


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileHistory::AddFilesToMenu((wxMenu*) object_pointer1_0)\n\n");
				#endif

				((wxFileHistory_php*)native_object)->AddFilesToMenu((wxMenu*) object_pointer1_0);

				references->AddReference(menu1, "wxFileHistory::AddFilesToMenu at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileHistory::AddFilesToMenu\n");
	}
}
/* }}} */

/* {{{ proto int wxFileHistory::GetBaseId()
   Returns the base identifier for the range used for appending items. */
PHP_METHOD(php_wxFileHistory, GetBaseId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileHistory::GetBaseId\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileHistory* current_object;
	wxphp_object_type current_object_type;
	wxFileHistory_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileHistory*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileHistory::GetBaseId call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILEHISTORY_TYPE){
				references = &((wxFileHistory_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxFileHistory::GetBaseId())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxFileHistory_php*)native_object)->GetBaseId());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileHistory::GetBaseId\n");
	}
}
/* }}} */

/* {{{ proto int wxFileHistory::GetCount()
   Returns the number of files currently stored in the file history. */
PHP_METHOD(php_wxFileHistory, GetCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileHistory::GetCount\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileHistory* current_object;
	wxphp_object_type current_object_type;
	wxFileHistory_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileHistory*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileHistory::GetCount call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILEHISTORY_TYPE){
				references = &((wxFileHistory_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxFileHistory::GetCount())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxFileHistory_php*)native_object)->GetCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileHistory::GetCount\n");
	}
}
/* }}} */

/* {{{ proto string wxFileHistory::GetHistoryFile(int index)
   Returns the file at this index (zero-based). */
PHP_METHOD(php_wxFileHistory, GetHistoryFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileHistory::GetHistoryFile\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileHistory* current_object;
	wxphp_object_type current_object_type;
	wxFileHistory_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileHistory*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileHistory::GetHistoryFile call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILEHISTORY_TYPE){
				references = &((wxFileHistory_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long index0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&index0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFileHistory::GetHistoryFile((size_t) index0).fn_str(), 1)\n\n");
				#endif

				wxString value_to_return1;
				value_to_return1 = ((wxFileHistory_php*)native_object)->GetHistoryFile((size_t) index0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileHistory::GetHistoryFile\n");
	}
}
/* }}} */

/* {{{ proto int wxFileHistory::GetMaxFiles()
   Returns the maximum number of files that can be stored. */
PHP_METHOD(php_wxFileHistory, GetMaxFiles)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileHistory::GetMaxFiles\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileHistory* current_object;
	wxphp_object_type current_object_type;
	wxFileHistory_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileHistory*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileHistory::GetMaxFiles call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILEHISTORY_TYPE){
				references = &((wxFileHistory_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxFileHistory::GetMaxFiles())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxFileHistory_php*)native_object)->GetMaxFiles());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileHistory::GetMaxFiles\n");
	}
}
/* }}} */

/* {{{ proto  wxFileHistory::Load(wxConfigBase config)
   Loads the file history from the given config object. */
PHP_METHOD(php_wxFileHistory, Load)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileHistory::Load\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileHistory* current_object;
	wxphp_object_type current_object_type;
	wxFileHistory_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileHistory*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileHistory::Load call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILEHISTORY_TYPE){
				references = &((wxFileHistory_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* config0 = 0;
	wxConfigBase* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&config0, php_wxConfigBase_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &config0, php_wxConfigBase_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(config0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxConfigBase*) zend_object_store_get_object(config0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxConfigBase*) zend_object_store_get_object(config0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxConfigBase*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'config' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(config0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'config' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileHistory::Load(*(wxConfigBase*) object_pointer0_0)\n\n");
				#endif

				((wxFileHistory_php*)native_object)->Load(*(wxConfigBase*) object_pointer0_0);

				references->AddReference(config0, "wxFileHistory::Load at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileHistory::Load\n");
	}
}
/* }}} */

/* {{{ proto  wxFileHistory::RemoveFileFromHistory(int i)
   Removes the specified file from the history. */
PHP_METHOD(php_wxFileHistory, RemoveFileFromHistory)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileHistory::RemoveFileFromHistory\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileHistory* current_object;
	wxphp_object_type current_object_type;
	wxFileHistory_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileHistory*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileHistory::RemoveFileFromHistory call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILEHISTORY_TYPE){
				references = &((wxFileHistory_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long i0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&i0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &i0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileHistory::RemoveFileFromHistory((size_t) i0)\n\n");
				#endif

				((wxFileHistory_php*)native_object)->RemoveFileFromHistory((size_t) i0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileHistory::RemoveFileFromHistory\n");
	}
}
/* }}} */

/* {{{ proto  wxFileHistory::RemoveMenu(wxMenu &menu)
   Removes this menu from the list of those managed by this object. */
PHP_METHOD(php_wxFileHistory, RemoveMenu)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileHistory::RemoveMenu\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileHistory* current_object;
	wxphp_object_type current_object_type;
	wxFileHistory_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileHistory*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileHistory::RemoveMenu call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILEHISTORY_TYPE){
				references = &((wxFileHistory_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* menu0 = 0;
	wxMenu* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&menu0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &menu0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(menu0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxMenu*) zend_object_store_get_object(menu0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxMenu*) zend_object_store_get_object(menu0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxMenu*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXMENU_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'menu' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(menu0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'menu' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileHistory::RemoveMenu((wxMenu*) object_pointer0_0)\n\n");
				#endif

				((wxFileHistory_php*)native_object)->RemoveMenu((wxMenu*) object_pointer0_0);

				references->AddReference(menu0, "wxFileHistory::RemoveMenu at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileHistory::RemoveMenu\n");
	}
}
/* }}} */

/* {{{ proto  wxFileHistory::Save(wxConfigBase &config)
   Saves the file history into the given config object. */
PHP_METHOD(php_wxFileHistory, Save)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileHistory::Save\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileHistory* current_object;
	wxphp_object_type current_object_type;
	wxFileHistory_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileHistory*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileHistory::Save call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILEHISTORY_TYPE){
				references = &((wxFileHistory_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* config0 = 0;
	wxConfigBase* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&config0, php_wxConfigBase_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &config0, php_wxConfigBase_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(config0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxConfigBase*) zend_object_store_get_object(config0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxConfigBase*) zend_object_store_get_object(config0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxConfigBase*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'config' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(config0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'config' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileHistory::Save(*(wxConfigBase*) object_pointer0_0)\n\n");
				#endif

				((wxFileHistory_php*)native_object)->Save(*(wxConfigBase*) object_pointer0_0);

				references->AddReference(config0, "wxFileHistory::Save at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileHistory::Save\n");
	}
}
/* }}} */

/* {{{ proto  wxFileHistory::SetBaseId(int baseId)
   Sets the base identifier for the range used for appending items. */
PHP_METHOD(php_wxFileHistory, SetBaseId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileHistory::SetBaseId\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileHistory* current_object;
	wxphp_object_type current_object_type;
	wxFileHistory_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileHistory*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileHistory::SetBaseId call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILEHISTORY_TYPE){
				references = &((wxFileHistory_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long baseId0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&baseId0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &baseId0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileHistory::SetBaseId((wxWindowID) baseId0)\n\n");
				#endif

				((wxFileHistory_php*)native_object)->SetBaseId((wxWindowID) baseId0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileHistory::SetBaseId\n");
	}
}
/* }}} */

/* {{{ proto  wxFileHistory::UseMenu(wxMenu &menu)
   Adds this menu to the list of those menus that are managed by this file history object. */
PHP_METHOD(php_wxFileHistory, UseMenu)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileHistory::UseMenu\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileHistory* current_object;
	wxphp_object_type current_object_type;
	wxFileHistory_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileHistory*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileHistory::UseMenu call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILEHISTORY_TYPE){
				references = &((wxFileHistory_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* menu0 = 0;
	wxMenu* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&menu0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &menu0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(menu0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxMenu*) zend_object_store_get_object(menu0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxMenu*) zend_object_store_get_object(menu0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxMenu*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXMENU_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'menu' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(menu0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'menu' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileHistory::UseMenu((wxMenu*) object_pointer0_0)\n\n");
				#endif

				((wxFileHistory_php*)native_object)->UseMenu((wxMenu*) object_pointer0_0);

				references->AddReference(menu0, "wxFileHistory::UseMenu at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileHistory::UseMenu\n");
	}
}
/* }}} */

/* {{{ proto  wxFileHistory::wxFileHistory(int maxFiles, int idBase)
   Constructor. */
PHP_METHOD(php_wxFileHistory, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileHistory::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileHistory* current_object;
	wxFileHistory_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	long maxFiles0;
	long idBase0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|ll' (&maxFiles0, &idBase0)\n");
		#endif

		char parse_parameters_string[] = "|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &maxFiles0, &idBase0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxFileHistory_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((size_t) maxFiles0)\n");
				#endif

				native_object = new wxFileHistory_php((size_t) maxFiles0);

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((size_t) maxFiles0, (wxWindowID) idBase0)\n");
				#endif

				native_object = new wxFileHistory_php((size_t) maxFiles0, (wxWindowID) idBase0);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxFileHistory*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxFileHistory::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

