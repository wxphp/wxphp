/*
 * @author Mário Soares
 * @contributors Jefferson González
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "webview.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


BEGIN_EXTERN_C()
void php_wxGridCellRenderer_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellRenderer* custom_object = (zo_wxGridCellRenderer*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellRenderer_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCellRenderer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellRenderer_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellRenderer_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellRenderer* custom_object;
    custom_object = (zo_wxGridCellRenderer*) emalloc(sizeof(zo_wxGridCellRenderer));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->native_object = new wxGridCellRenderer_php(); 
    custom_object->native_object->phpObj = temp; 
    custom_object->object_type = PHP_WXGRIDCELLRENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellRenderer_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto wxSize wxGridCellRenderer::GetBestSize(wxGrid &grid, wxGridCellAttr &attr, wxDC &dc, int row, int col)
   Get the preferred size of the cell for its contents. */
wxSize wxGridCellRenderer_php::GetBestSize(wxGrid& grid, wxGridCellAttr& attr, wxDC& dc, int row, int col)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxGridCellRenderer::GetBestSize\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[5];
	zval *arguments[5];
	
	//Initilize arguments array
	for(int i=0; i<5; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetBestSize", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxGrid_entry);
	((zo_wxGrid*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxGrid_php*) &grid;
	object_init_ex(arguments[1], php_wxGridCellAttr_entry);
	((zo_wxGridCellAttr*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxGridCellAttr_php*) &attr;
	object_init_ex(arguments[2], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	ZVAL_LONG(arguments[3], row);
	ZVAL_LONG(arguments[4], col);
		
	for(int i=0; i<5; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetBestSize", 11, &return_value, 5, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<5; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxGridCellRenderer::GetBestSize'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	if(Z_TYPE_P(return_value) == IS_OBJECT)
	{
		return_object = (void*) ((zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object;
	}

	//Threat it as a normal object on the calling function and not a php user space intiialized one
	((zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC))->is_user_initialized = 0;
	wxSize_php* var = (wxSize_php*) return_object;
	var->references.UnInitialize();

	return *(wxSize*) return_object;
	
}
/* }}} */

/* {{{ proto  wxGridCellRenderer::Draw(wxGrid &grid, wxGridCellAttr &attr, wxDC &dc, wxRect rect, int row, int col, bool isSelected)
   Draw the given cell on the provided DC inside the given rectangle using the style specified by the attribute and the default or selected state corresponding to the isSelected value. */
void wxGridCellRenderer_php::Draw(wxGrid& grid, wxGridCellAttr& attr, wxDC& dc, const wxRect& rect, int row, int col, bool isSelected)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxGridCellRenderer::Draw\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[7];
	zval *arguments[7];
	
	//Initilize arguments array
	for(int i=0; i<7; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "Draw", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxGrid_entry);
	((zo_wxGrid*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxGrid_php*) &grid;
	object_init_ex(arguments[1], php_wxGridCellAttr_entry);
	((zo_wxGridCellAttr*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxGridCellAttr_php*) &attr;
	object_init_ex(arguments[2], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[3], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[3] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	ZVAL_LONG(arguments[4], row);
	ZVAL_LONG(arguments[5], col);
	ZVAL_BOOL(arguments[6], isSelected);
		
	for(int i=0; i<7; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "Draw", 4, &return_value, 7, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<7; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxGridCellRenderer::Draw'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto wxGridCellRenderer wxGridCellRenderer::Clone()
   This function must be implemented in derived classes to return a copy of itself. */
wxGridCellRenderer* wxGridCellRenderer_php::Clone()const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxGridCellRenderer::Clone\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "Clone", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "Clone", 5, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxGridCellRenderer::Clone'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	if(Z_TYPE_P(return_value) == IS_OBJECT)
	{
		return_object = (void*) ((zo_wxGridCellRenderer*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object;
	}

	//Threat it as a normal object on the calling function and not a php user space intiialized one
	((zo_wxGridCellRenderer*) zend_object_store_get_object(return_value TSRMLS_CC))->is_user_initialized = 0;
	wxGridCellRenderer_php* var = (wxGridCellRenderer_php*) return_object;
	var->references.UnInitialize();

	return (wxGridCellRenderer*) return_object;
	
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellAutoWrapStringRenderer_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellAutoWrapStringRenderer* custom_object = (zo_wxGridCellAutoWrapStringRenderer*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellAutoWrapStringRenderer_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCellAutoWrapStringRenderer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellAutoWrapStringRenderer_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellAutoWrapStringRenderer_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellAutoWrapStringRenderer* custom_object;
    custom_object = (zo_wxGridCellAutoWrapStringRenderer*) emalloc(sizeof(zo_wxGridCellAutoWrapStringRenderer));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLAUTOWRAPSTRINGRENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellAutoWrapStringRenderer_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridCellAutoWrapStringRenderer::wxGridCellAutoWrapStringRenderer()
   Default constructor. */
PHP_METHOD(php_wxGridCellAutoWrapStringRenderer, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAutoWrapStringRenderer::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAutoWrapStringRenderer* current_object;
	wxGridCellAutoWrapStringRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridCellAutoWrapStringRenderer_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridCellAutoWrapStringRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridCellAutoWrapStringRenderer::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellBoolRenderer_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellBoolRenderer* custom_object = (zo_wxGridCellBoolRenderer*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellBoolRenderer_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCellBoolRenderer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellBoolRenderer_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellBoolRenderer_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellBoolRenderer* custom_object;
    custom_object = (zo_wxGridCellBoolRenderer*) emalloc(sizeof(zo_wxGridCellBoolRenderer));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLBOOLRENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellBoolRenderer_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridCellBoolRenderer::wxGridCellBoolRenderer()
   Default constructor. */
PHP_METHOD(php_wxGridCellBoolRenderer, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellBoolRenderer::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellBoolRenderer* current_object;
	wxGridCellBoolRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridCellBoolRenderer_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridCellBoolRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridCellBoolRenderer::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellDateTimeRenderer_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellDateTimeRenderer* custom_object = (zo_wxGridCellDateTimeRenderer*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellDateTimeRenderer_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCellDateTimeRenderer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellDateTimeRenderer_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellDateTimeRenderer_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellDateTimeRenderer* custom_object;
    custom_object = (zo_wxGridCellDateTimeRenderer*) emalloc(sizeof(zo_wxGridCellDateTimeRenderer));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLDATETIMERENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellDateTimeRenderer_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridCellDateTimeRenderer::SetParameters(string params)
   Sets the strptime()-like format string which will be used to parse the date/time. */
PHP_METHOD(php_wxGridCellDateTimeRenderer, SetParameters)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellDateTimeRenderer::SetParameters\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellDateTimeRenderer* current_object;
	wxphp_object_type current_object_type;
	wxGridCellDateTimeRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellDateTimeRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellDateTimeRenderer::SetParameters call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLDATETIMERENDERER_TYPE){
				references = &((wxGridCellDateTimeRenderer_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* params0;
	long params_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&params0, &params_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &params0, &params_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellDateTimeRenderer::SetParameters(wxString(params0, wxConvUTF8))\n\n");
				#endif

				((wxGridCellDateTimeRenderer_php*)native_object)->SetParameters(wxString(params0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellDateTimeRenderer::SetParameters\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellDateTimeRenderer::wxGridCellDateTimeRenderer(string outformat, string informat)
   Date/time renderer constructor. */
PHP_METHOD(php_wxGridCellDateTimeRenderer, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellDateTimeRenderer::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellDateTimeRenderer* current_object;
	wxGridCellDateTimeRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	char* outformat0;
	long outformat_len0;
	char* informat0;
	long informat_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|ss' (&outformat0, &outformat_len0, &informat0, &informat_len0)\n");
		#endif

		char parse_parameters_string[] = "|ss";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &outformat0, &outformat_len0, &informat0, &informat_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridCellDateTimeRenderer_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(outformat0, wxConvUTF8))\n");
				#endif

				native_object = new wxGridCellDateTimeRenderer_php(wxString(outformat0, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(outformat0, wxConvUTF8), wxString(informat0, wxConvUTF8))\n");
				#endif

				native_object = new wxGridCellDateTimeRenderer_php(wxString(outformat0, wxConvUTF8), wxString(informat0, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridCellDateTimeRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridCellDateTimeRenderer::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellEnumRenderer_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellEnumRenderer* custom_object = (zo_wxGridCellEnumRenderer*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellEnumRenderer_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCellEnumRenderer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellEnumRenderer_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellEnumRenderer_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellEnumRenderer* custom_object;
    custom_object = (zo_wxGridCellEnumRenderer*) emalloc(sizeof(zo_wxGridCellEnumRenderer));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLENUMRENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellEnumRenderer_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridCellEnumRenderer::SetParameters(string params)
   Sets the comma separated string content of the enum. */
PHP_METHOD(php_wxGridCellEnumRenderer, SetParameters)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellEnumRenderer::SetParameters\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellEnumRenderer* current_object;
	wxphp_object_type current_object_type;
	wxGridCellEnumRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellEnumRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellEnumRenderer::SetParameters call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLENUMRENDERER_TYPE){
				references = &((wxGridCellEnumRenderer_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* params0;
	long params_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&params0, &params_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &params0, &params_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellEnumRenderer::SetParameters(wxString(params0, wxConvUTF8))\n\n");
				#endif

				((wxGridCellEnumRenderer_php*)native_object)->SetParameters(wxString(params0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellEnumRenderer::SetParameters\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellEnumRenderer::wxGridCellEnumRenderer(string choices)
   Enum renderer ctor. */
PHP_METHOD(php_wxGridCellEnumRenderer, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellEnumRenderer::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellEnumRenderer* current_object;
	wxGridCellEnumRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	char* choices0;
	long choices_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|s' (&choices0, &choices_len0)\n");
		#endif

		char parse_parameters_string[] = "|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &choices0, &choices_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridCellEnumRenderer_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(choices0, wxConvUTF8))\n");
				#endif

				native_object = new wxGridCellEnumRenderer_php(wxString(choices0, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridCellEnumRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridCellEnumRenderer::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellFloatRenderer_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellFloatRenderer* custom_object = (zo_wxGridCellFloatRenderer*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellFloatRenderer_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCellFloatRenderer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellFloatRenderer_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellFloatRenderer_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellFloatRenderer* custom_object;
    custom_object = (zo_wxGridCellFloatRenderer*) emalloc(sizeof(zo_wxGridCellFloatRenderer));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLFLOATRENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellFloatRenderer_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto int wxGridCellFloatRenderer::GetFormat()
   Returns the specifier used to format the data to string. */
PHP_METHOD(php_wxGridCellFloatRenderer, GetFormat)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellFloatRenderer::GetFormat\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellFloatRenderer* current_object;
	wxphp_object_type current_object_type;
	wxGridCellFloatRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellFloatRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellFloatRenderer::GetFormat call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLFLOATRENDERER_TYPE){
				references = &((wxGridCellFloatRenderer_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGridCellFloatRenderer::GetFormat())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGridCellFloatRenderer_php*)native_object)->GetFormat());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellFloatRenderer::GetFormat\n");
	}
}
/* }}} */

/* {{{ proto int wxGridCellFloatRenderer::GetPrecision()
   Returns the precision. */
PHP_METHOD(php_wxGridCellFloatRenderer, GetPrecision)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellFloatRenderer::GetPrecision\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellFloatRenderer* current_object;
	wxphp_object_type current_object_type;
	wxGridCellFloatRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellFloatRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellFloatRenderer::GetPrecision call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLFLOATRENDERER_TYPE){
				references = &((wxGridCellFloatRenderer_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGridCellFloatRenderer::GetPrecision())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGridCellFloatRenderer_php*)native_object)->GetPrecision());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellFloatRenderer::GetPrecision\n");
	}
}
/* }}} */

/* {{{ proto int wxGridCellFloatRenderer::GetWidth()
   Returns the width. */
PHP_METHOD(php_wxGridCellFloatRenderer, GetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellFloatRenderer::GetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellFloatRenderer* current_object;
	wxphp_object_type current_object_type;
	wxGridCellFloatRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellFloatRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellFloatRenderer::GetWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLFLOATRENDERER_TYPE){
				references = &((wxGridCellFloatRenderer_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGridCellFloatRenderer::GetWidth())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGridCellFloatRenderer_php*)native_object)->GetWidth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellFloatRenderer::GetWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellFloatRenderer::SetFormat(int format)
   Set the format to use for display the number. */
PHP_METHOD(php_wxGridCellFloatRenderer, SetFormat)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellFloatRenderer::SetFormat\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellFloatRenderer* current_object;
	wxphp_object_type current_object_type;
	wxGridCellFloatRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellFloatRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellFloatRenderer::SetFormat call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLFLOATRENDERER_TYPE){
				references = &((wxGridCellFloatRenderer_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long format0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&format0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &format0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellFloatRenderer::SetFormat((int) format0)\n\n");
				#endif

				((wxGridCellFloatRenderer_php*)native_object)->SetFormat((int) format0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellFloatRenderer::SetFormat\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellFloatRenderer::SetParameters(string params)
   The parameters string format is "width[,precision[,format]]" where format should be chosen between f|e|g|E|G (f is used by default) */
PHP_METHOD(php_wxGridCellFloatRenderer, SetParameters)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellFloatRenderer::SetParameters\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellFloatRenderer* current_object;
	wxphp_object_type current_object_type;
	wxGridCellFloatRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellFloatRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellFloatRenderer::SetParameters call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLFLOATRENDERER_TYPE){
				references = &((wxGridCellFloatRenderer_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* params0;
	long params_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&params0, &params_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &params0, &params_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellFloatRenderer::SetParameters(wxString(params0, wxConvUTF8))\n\n");
				#endif

				((wxGridCellFloatRenderer_php*)native_object)->SetParameters(wxString(params0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellFloatRenderer::SetParameters\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellFloatRenderer::SetPrecision(int precision)
   Sets the precision. */
PHP_METHOD(php_wxGridCellFloatRenderer, SetPrecision)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellFloatRenderer::SetPrecision\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellFloatRenderer* current_object;
	wxphp_object_type current_object_type;
	wxGridCellFloatRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellFloatRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellFloatRenderer::SetPrecision call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLFLOATRENDERER_TYPE){
				references = &((wxGridCellFloatRenderer_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long precision0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&precision0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &precision0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellFloatRenderer::SetPrecision((int) precision0)\n\n");
				#endif

				((wxGridCellFloatRenderer_php*)native_object)->SetPrecision((int) precision0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellFloatRenderer::SetPrecision\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellFloatRenderer::SetWidth(int width)
   Sets the width. */
PHP_METHOD(php_wxGridCellFloatRenderer, SetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellFloatRenderer::SetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellFloatRenderer* current_object;
	wxphp_object_type current_object_type;
	wxGridCellFloatRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellFloatRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellFloatRenderer::SetWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLFLOATRENDERER_TYPE){
				references = &((wxGridCellFloatRenderer_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellFloatRenderer::SetWidth((int) width0)\n\n");
				#endif

				((wxGridCellFloatRenderer_php*)native_object)->SetWidth((int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellFloatRenderer::SetWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellFloatRenderer::wxGridCellFloatRenderer(int width, int precision, int format)
   Float cell renderer ctor. */
PHP_METHOD(php_wxGridCellFloatRenderer, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellFloatRenderer::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellFloatRenderer* current_object;
	wxGridCellFloatRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	long width0;
	long precision0;
	long format0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|lll' (&width0, &precision0, &format0)\n");
		#endif

		char parse_parameters_string[] = "|lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0, &precision0, &format0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridCellFloatRenderer_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width0)\n");
				#endif

				native_object = new wxGridCellFloatRenderer_php((int) width0);

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width0, (int) precision0)\n");
				#endif

				native_object = new wxGridCellFloatRenderer_php((int) width0, (int) precision0);

				native_object->references.Initialize();
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width0, (int) precision0, (int) format0)\n");
				#endif

				native_object = new wxGridCellFloatRenderer_php((int) width0, (int) precision0, (int) format0);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridCellFloatRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridCellFloatRenderer::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellNumberRenderer_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellNumberRenderer* custom_object = (zo_wxGridCellNumberRenderer*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellNumberRenderer_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCellNumberRenderer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellNumberRenderer_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellNumberRenderer_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellNumberRenderer* custom_object;
    custom_object = (zo_wxGridCellNumberRenderer*) emalloc(sizeof(zo_wxGridCellNumberRenderer));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLNUMBERRENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellNumberRenderer_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridCellNumberRenderer::wxGridCellNumberRenderer()
   Default constructor. */
PHP_METHOD(php_wxGridCellNumberRenderer, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellNumberRenderer::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellNumberRenderer* current_object;
	wxGridCellNumberRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridCellNumberRenderer_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridCellNumberRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridCellNumberRenderer::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellStringRenderer_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellStringRenderer* custom_object = (zo_wxGridCellStringRenderer*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellStringRenderer_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCellStringRenderer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellStringRenderer_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellStringRenderer_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellStringRenderer* custom_object;
    custom_object = (zo_wxGridCellStringRenderer*) emalloc(sizeof(zo_wxGridCellStringRenderer));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLSTRINGRENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellStringRenderer_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridCellStringRenderer::wxGridCellStringRenderer()
   Default constructor. */
PHP_METHOD(php_wxGridCellStringRenderer, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellStringRenderer::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellStringRenderer* current_object;
	wxGridCellStringRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridCellStringRenderer_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridCellStringRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridCellStringRenderer::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellEditor_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellEditor* custom_object = (zo_wxGridCellEditor*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellEditor_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellEditor_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellEditor_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellEditor* custom_object;
    custom_object = (zo_wxGridCellEditor*) emalloc(sizeof(zo_wxGridCellEditor));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLEDITOR_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellEditor_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridCellEditor::ApplyEdit(int row, int col, wxGrid &grid)
   Effectively save the changes in the grid. */
void wxGridCellEditor_php::ApplyEdit(int row, int col, wxGrid* grid)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxGridCellEditor::ApplyEdit\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "ApplyEdit", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], row);
	ZVAL_LONG(arguments[1], col);
	object_init_ex(arguments[2], php_wxGrid_entry);
	((zo_wxGrid*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxGrid_php*) grid;
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "ApplyEdit", 9, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxGridCellEditor::ApplyEdit'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxGridCellEditor::BeginEdit(int row, int col, wxGrid &grid)
   Fetch the value from the table and prepare the edit control to begin editing. */
void wxGridCellEditor_php::BeginEdit(int row, int col, wxGrid* grid)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxGridCellEditor::BeginEdit\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "BeginEdit", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], row);
	ZVAL_LONG(arguments[1], col);
	object_init_ex(arguments[2], php_wxGrid_entry);
	((zo_wxGrid*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxGrid_php*) grid;
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "BeginEdit", 9, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxGridCellEditor::BeginEdit'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto wxGridCellEditor wxGridCellEditor::Clone()
   Create a new object which is the copy of this one. */
wxGridCellEditor* wxGridCellEditor_php::Clone()const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxGridCellEditor::Clone\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "Clone", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "Clone", 5, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxGridCellEditor::Clone'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	if(Z_TYPE_P(return_value) == IS_OBJECT)
	{
		return_object = (void*) ((zo_wxGridCellEditor*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object;
	}

	//Threat it as a normal object on the calling function and not a php user space intiialized one
	((zo_wxGridCellEditor*) zend_object_store_get_object(return_value TSRMLS_CC))->is_user_initialized = 0;
	wxGridCellEditor_php* var = (wxGridCellEditor_php*) return_object;
	var->references.UnInitialize();

	return (wxGridCellEditor*) return_object;
	
}
/* }}} */

/* {{{ proto  wxGridCellEditor::Create(wxWindow &parent, int id, wxEvtHandler &evtHandler)
   Creates the actual edit control. */
void wxGridCellEditor_php::Create(wxWindow* parent, wxWindowID id, wxEvtHandler* evtHandler)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxGridCellEditor::Create\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "Create", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) parent;
	ZVAL_LONG(arguments[1], id);
	object_init_ex(arguments[2], php_wxEvtHandler_entry);
	((zo_wxEvtHandler*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxEvtHandler_php*) evtHandler;
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "Create", 6, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxGridCellEditor::Create'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxGridCellEditor::Destroy()
   Final cleanup. */
PHP_METHOD(php_wxGridCellEditor, Destroy)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellEditor::Destroy\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellEditor* current_object;
	wxphp_object_type current_object_type;
	wxGridCellEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellEditor::Destroy call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE){
				references = &((wxGridCellEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellBoolEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellChoiceEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellEnumEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellTextEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellAutoWrapStringEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellFloatEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellNumberEditor_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellEditor::Destroy()\n\n");
				#endif

				if(current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE)
				{
					((wxGridCellBoolEditor_php*)native_object)->Destroy();
				}
				else if(current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE)
				{
					((wxGridCellChoiceEditor_php*)native_object)->Destroy();
				}
				else if(current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE)
				{
					((wxGridCellEnumEditor_php*)native_object)->Destroy();
				}
				else if(current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE)
				{
					((wxGridCellTextEditor_php*)native_object)->Destroy();
				}
				else if(current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE)
				{
					((wxGridCellAutoWrapStringEditor_php*)native_object)->Destroy();
				}
				else if(current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE)
				{
					((wxGridCellFloatEditor_php*)native_object)->Destroy();
				}
				else if(current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE)
				{
					((wxGridCellNumberEditor_php*)native_object)->Destroy();
				}
				else if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE)
				{
					((wxGridCellEditor_php*)native_object)->Destroy();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellEditor::Destroy\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridCellEditor::EndEdit(int row, int col, wxGrid grid, string oldval, string &newval)
   End editing the cell. */
bool wxGridCellEditor_php::EndEdit(int row, int col, const wxGrid* grid, const wxString& oldval, wxString* newval)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxGridCellEditor::EndEdit\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[5];
	zval *arguments[5];
	
	//Initilize arguments array
	for(int i=0; i<5; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "EndEdit", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], row);
	ZVAL_LONG(arguments[1], col);
	object_init_ex(arguments[2], php_wxGrid_entry);
	((zo_wxGrid*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxGrid_php*) grid;
	temp_string = (char*)malloc(sizeof(wxChar)*(oldval.size()+1));
	strcpy(temp_string, (const char *) oldval.char_str());
	ZVAL_STRING(arguments[3], temp_string, 1);
	free(temp_string);
	temp_string = (char*)malloc(sizeof(wxChar)*(newval->size()+1));
	strcpy(temp_string, (const char *) newval->char_str());
	ZVAL_STRING(arguments[4], temp_string, 1);
	free(temp_string);
		
	for(int i=0; i<5; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "EndEdit", 7, &return_value, 5, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<5; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxGridCellEditor::EndEdit'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return Z_BVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto  wxGridCellEditor::HandleReturn(wxKeyEvent &event)
   Some types of controls on some platforms may need some help with the Return key. */
PHP_METHOD(php_wxGridCellEditor, HandleReturn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellEditor::HandleReturn\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellEditor* current_object;
	wxphp_object_type current_object_type;
	wxGridCellEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellEditor::HandleReturn call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE){
				references = &((wxGridCellEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellBoolEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellChoiceEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellEnumEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellTextEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellAutoWrapStringEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellFloatEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellNumberEditor_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* event0 = 0;
	wxKeyEvent* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&event0, php_wxKeyEvent_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &event0, php_wxKeyEvent_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(event0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxKeyEvent*) zend_object_store_get_object(event0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxKeyEvent*) zend_object_store_get_object(event0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxKeyEvent*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'event' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(event0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'event' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellEditor::HandleReturn(*(wxKeyEvent*) object_pointer0_0)\n\n");
				#endif

				if(current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE)
				{
					((wxGridCellBoolEditor_php*)native_object)->HandleReturn(*(wxKeyEvent*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE)
				{
					((wxGridCellChoiceEditor_php*)native_object)->HandleReturn(*(wxKeyEvent*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE)
				{
					((wxGridCellEnumEditor_php*)native_object)->HandleReturn(*(wxKeyEvent*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE)
				{
					((wxGridCellTextEditor_php*)native_object)->HandleReturn(*(wxKeyEvent*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE)
				{
					((wxGridCellAutoWrapStringEditor_php*)native_object)->HandleReturn(*(wxKeyEvent*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE)
				{
					((wxGridCellFloatEditor_php*)native_object)->HandleReturn(*(wxKeyEvent*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE)
				{
					((wxGridCellNumberEditor_php*)native_object)->HandleReturn(*(wxKeyEvent*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE)
				{
					((wxGridCellEditor_php*)native_object)->HandleReturn(*(wxKeyEvent*) object_pointer0_0);
				}

				references->AddReference(event0, "wxGridCellEditor::HandleReturn at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellEditor::HandleReturn\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridCellEditor::IsCreated()
   Returns true if the edit control has been created. */
PHP_METHOD(php_wxGridCellEditor, IsCreated)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellEditor::IsCreated\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellEditor* current_object;
	wxphp_object_type current_object_type;
	wxGridCellEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellEditor::IsCreated call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE){
				references = &((wxGridCellEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellBoolEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellChoiceEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellEnumEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellTextEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellAutoWrapStringEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellFloatEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellNumberEditor_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridCellEditor::IsCreated())\n\n");
				#endif

				if(current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxGridCellBoolEditor_php*)native_object)->IsCreated());
				}
				else if(current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxGridCellChoiceEditor_php*)native_object)->IsCreated());
				}
				else if(current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxGridCellEnumEditor_php*)native_object)->IsCreated());
				}
				else if(current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxGridCellTextEditor_php*)native_object)->IsCreated());
				}
				else if(current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxGridCellAutoWrapStringEditor_php*)native_object)->IsCreated());
				}
				else if(current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxGridCellFloatEditor_php*)native_object)->IsCreated());
				}
				else if(current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxGridCellNumberEditor_php*)native_object)->IsCreated());
				}
				else if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxGridCellEditor_php*)native_object)->IsCreated());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellEditor::IsCreated\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellEditor::PaintBackground(wxRect rectCell, wxGridCellAttr &attr)
   Draws the part of the cell not occupied by the control: the base class version just fills it with background colour from the attribute. */
PHP_METHOD(php_wxGridCellEditor, PaintBackground)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellEditor::PaintBackground\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellEditor* current_object;
	wxphp_object_type current_object_type;
	wxGridCellEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellEditor::PaintBackground call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE){
				references = &((wxGridCellEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellBoolEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellChoiceEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellEnumEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellTextEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellAutoWrapStringEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellFloatEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellNumberEditor_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* rectCell0 = 0;
	wxRect* object_pointer0_0 = 0;
	zval* attr0 = 0;
	wxGridCellAttr* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Oz' (&rectCell0, php_wxRect_entry, &attr0)\n");
		#endif

		char parse_parameters_string[] = "Oz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rectCell0, php_wxRect_entry, &attr0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rectCell0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rectCell0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rectCell0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxRect*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'rectCell' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rectCell0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rectCell' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(attr0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxGridCellAttr*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXGRIDCELLATTR_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'attr' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(attr0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'attr' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellEditor::PaintBackground(*(wxRect*) object_pointer0_0, (wxGridCellAttr*) object_pointer0_1)\n\n");
				#endif

				if(current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE)
				{
					((wxGridCellBoolEditor_php*)native_object)->PaintBackground(*(wxRect*) object_pointer0_0, (wxGridCellAttr*) object_pointer0_1);
				}
				else if(current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE)
				{
					((wxGridCellChoiceEditor_php*)native_object)->PaintBackground(*(wxRect*) object_pointer0_0, (wxGridCellAttr*) object_pointer0_1);
				}
				else if(current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE)
				{
					((wxGridCellEnumEditor_php*)native_object)->PaintBackground(*(wxRect*) object_pointer0_0, (wxGridCellAttr*) object_pointer0_1);
				}
				else if(current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE)
				{
					((wxGridCellTextEditor_php*)native_object)->PaintBackground(*(wxRect*) object_pointer0_0, (wxGridCellAttr*) object_pointer0_1);
				}
				else if(current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE)
				{
					((wxGridCellAutoWrapStringEditor_php*)native_object)->PaintBackground(*(wxRect*) object_pointer0_0, (wxGridCellAttr*) object_pointer0_1);
				}
				else if(current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE)
				{
					((wxGridCellFloatEditor_php*)native_object)->PaintBackground(*(wxRect*) object_pointer0_0, (wxGridCellAttr*) object_pointer0_1);
				}
				else if(current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE)
				{
					((wxGridCellNumberEditor_php*)native_object)->PaintBackground(*(wxRect*) object_pointer0_0, (wxGridCellAttr*) object_pointer0_1);
				}
				else if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE)
				{
					((wxGridCellEditor_php*)native_object)->PaintBackground(*(wxRect*) object_pointer0_0, (wxGridCellAttr*) object_pointer0_1);
				}

				references->AddReference(rectCell0, "wxGridCellEditor::PaintBackground at call with 2 argument(s)");
				references->AddReference(attr0, "wxGridCellEditor::PaintBackground at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellEditor::PaintBackground\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellEditor::SetSize(wxRect rect)
   Size and position the edit control. */
PHP_METHOD(php_wxGridCellEditor, SetSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellEditor::SetSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellEditor* current_object;
	wxphp_object_type current_object_type;
	wxGridCellEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellEditor::SetSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE){
				references = &((wxGridCellEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellBoolEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellChoiceEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellEnumEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellTextEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellAutoWrapStringEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellFloatEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellNumberEditor_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* rect0 = 0;
	wxRect* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxRect*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellEditor::SetSize(*(wxRect*) object_pointer0_0)\n\n");
				#endif

				if(current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE)
				{
					((wxGridCellBoolEditor_php*)native_object)->SetSize(*(wxRect*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE)
				{
					((wxGridCellChoiceEditor_php*)native_object)->SetSize(*(wxRect*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE)
				{
					((wxGridCellEnumEditor_php*)native_object)->SetSize(*(wxRect*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE)
				{
					((wxGridCellTextEditor_php*)native_object)->SetSize(*(wxRect*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE)
				{
					((wxGridCellAutoWrapStringEditor_php*)native_object)->SetSize(*(wxRect*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE)
				{
					((wxGridCellFloatEditor_php*)native_object)->SetSize(*(wxRect*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE)
				{
					((wxGridCellNumberEditor_php*)native_object)->SetSize(*(wxRect*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE)
				{
					((wxGridCellEditor_php*)native_object)->SetSize(*(wxRect*) object_pointer0_0);
				}

				references->AddReference(rect0, "wxGridCellEditor::SetSize at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellEditor::SetSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellEditor::Reset()
   Reset the value in the control back to its starting value. */
void wxGridCellEditor_php::Reset()
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxGridCellEditor::Reset\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "Reset", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "Reset", 5, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxGridCellEditor::Reset'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxGridCellEditor::Show(bool show, wxGridCellAttr &attr)
   Show or hide the edit control, use the specified attributes to set colours/fonts for it. */
PHP_METHOD(php_wxGridCellEditor, Show)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellEditor::Show\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellEditor* current_object;
	wxphp_object_type current_object_type;
	wxGridCellEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellEditor::Show call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE){
				references = &((wxGridCellEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellBoolEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellChoiceEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellEnumEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellTextEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellAutoWrapStringEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellFloatEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellNumberEditor_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool show0;
	zval* attr0 = 0;
	wxGridCellAttr* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b|z' (&show0, &attr0)\n");
		#endif

		char parse_parameters_string[] = "b|z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &show0, &attr0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(attr0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxGridCellAttr*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXGRIDCELLATTR_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'attr' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(attr0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'attr' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellEditor::Show(show0)\n\n");
				#endif

				if(current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE)
				{
					((wxGridCellBoolEditor_php*)native_object)->Show(show0);
				}
				else if(current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE)
				{
					((wxGridCellChoiceEditor_php*)native_object)->Show(show0);
				}
				else if(current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE)
				{
					((wxGridCellEnumEditor_php*)native_object)->Show(show0);
				}
				else if(current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE)
				{
					((wxGridCellTextEditor_php*)native_object)->Show(show0);
				}
				else if(current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE)
				{
					((wxGridCellAutoWrapStringEditor_php*)native_object)->Show(show0);
				}
				else if(current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE)
				{
					((wxGridCellFloatEditor_php*)native_object)->Show(show0);
				}
				else if(current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE)
				{
					((wxGridCellNumberEditor_php*)native_object)->Show(show0);
				}
				else if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE)
				{
					((wxGridCellEditor_php*)native_object)->Show(show0);
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellEditor::Show(show0, (wxGridCellAttr*) object_pointer0_1)\n\n");
				#endif

				if(current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE)
				{
					((wxGridCellBoolEditor_php*)native_object)->Show(show0, (wxGridCellAttr*) object_pointer0_1);
				}
				else if(current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE)
				{
					((wxGridCellChoiceEditor_php*)native_object)->Show(show0, (wxGridCellAttr*) object_pointer0_1);
				}
				else if(current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE)
				{
					((wxGridCellEnumEditor_php*)native_object)->Show(show0, (wxGridCellAttr*) object_pointer0_1);
				}
				else if(current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE)
				{
					((wxGridCellTextEditor_php*)native_object)->Show(show0, (wxGridCellAttr*) object_pointer0_1);
				}
				else if(current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE)
				{
					((wxGridCellAutoWrapStringEditor_php*)native_object)->Show(show0, (wxGridCellAttr*) object_pointer0_1);
				}
				else if(current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE)
				{
					((wxGridCellFloatEditor_php*)native_object)->Show(show0, (wxGridCellAttr*) object_pointer0_1);
				}
				else if(current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE)
				{
					((wxGridCellNumberEditor_php*)native_object)->Show(show0, (wxGridCellAttr*) object_pointer0_1);
				}
				else if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE)
				{
					((wxGridCellEditor_php*)native_object)->Show(show0, (wxGridCellAttr*) object_pointer0_1);
				}

				references->AddReference(attr0, "wxGridCellEditor::Show at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellEditor::Show\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellEditor::StartingClick()
   If the editor is enabled by clicking on the cell, this method will be called. */
PHP_METHOD(php_wxGridCellEditor, StartingClick)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellEditor::StartingClick\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellEditor* current_object;
	wxphp_object_type current_object_type;
	wxGridCellEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellEditor::StartingClick call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE){
				references = &((wxGridCellEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellBoolEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellChoiceEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellEnumEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellTextEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellAutoWrapStringEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellFloatEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellNumberEditor_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellEditor::StartingClick()\n\n");
				#endif

				if(current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE)
				{
					((wxGridCellBoolEditor_php*)native_object)->StartingClick();
				}
				else if(current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE)
				{
					((wxGridCellChoiceEditor_php*)native_object)->StartingClick();
				}
				else if(current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE)
				{
					((wxGridCellEnumEditor_php*)native_object)->StartingClick();
				}
				else if(current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE)
				{
					((wxGridCellTextEditor_php*)native_object)->StartingClick();
				}
				else if(current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE)
				{
					((wxGridCellAutoWrapStringEditor_php*)native_object)->StartingClick();
				}
				else if(current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE)
				{
					((wxGridCellFloatEditor_php*)native_object)->StartingClick();
				}
				else if(current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE)
				{
					((wxGridCellNumberEditor_php*)native_object)->StartingClick();
				}
				else if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE)
				{
					((wxGridCellEditor_php*)native_object)->StartingClick();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellEditor::StartingClick\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellEditor::StartingKey(wxKeyEvent &event)
   If the editor is enabled by pressing keys on the grid, this will be called to let the editor do something about that first key if desired. */
PHP_METHOD(php_wxGridCellEditor, StartingKey)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellEditor::StartingKey\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellEditor* current_object;
	wxphp_object_type current_object_type;
	wxGridCellEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellEditor::StartingKey call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE){
				references = &((wxGridCellEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellBoolEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellChoiceEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellEnumEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellTextEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellAutoWrapStringEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellFloatEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellNumberEditor_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* event0 = 0;
	wxKeyEvent* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&event0, php_wxKeyEvent_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &event0, php_wxKeyEvent_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(event0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxKeyEvent*) zend_object_store_get_object(event0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxKeyEvent*) zend_object_store_get_object(event0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxKeyEvent*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'event' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(event0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'event' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellEditor::StartingKey(*(wxKeyEvent*) object_pointer0_0)\n\n");
				#endif

				if(current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE)
				{
					((wxGridCellBoolEditor_php*)native_object)->StartingKey(*(wxKeyEvent*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE)
				{
					((wxGridCellChoiceEditor_php*)native_object)->StartingKey(*(wxKeyEvent*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE)
				{
					((wxGridCellEnumEditor_php*)native_object)->StartingKey(*(wxKeyEvent*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE)
				{
					((wxGridCellTextEditor_php*)native_object)->StartingKey(*(wxKeyEvent*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE)
				{
					((wxGridCellAutoWrapStringEditor_php*)native_object)->StartingKey(*(wxKeyEvent*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE)
				{
					((wxGridCellFloatEditor_php*)native_object)->StartingKey(*(wxKeyEvent*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE)
				{
					((wxGridCellNumberEditor_php*)native_object)->StartingKey(*(wxKeyEvent*) object_pointer0_0);
				}
				else if(current_object_type == PHP_WXGRIDCELLEDITOR_TYPE)
				{
					((wxGridCellEditor_php*)native_object)->StartingKey(*(wxKeyEvent*) object_pointer0_0);
				}

				references->AddReference(event0, "wxGridCellEditor::StartingKey at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellEditor::StartingKey\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellAutoWrapStringEditor_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellAutoWrapStringEditor* custom_object = (zo_wxGridCellAutoWrapStringEditor*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellAutoWrapStringEditor_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCellAutoWrapStringEditor done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellAutoWrapStringEditor_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellAutoWrapStringEditor_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellAutoWrapStringEditor* custom_object;
    custom_object = (zo_wxGridCellAutoWrapStringEditor*) emalloc(sizeof(zo_wxGridCellAutoWrapStringEditor));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellAutoWrapStringEditor_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridCellAutoWrapStringEditor::wxGridCellAutoWrapStringEditor() */
PHP_METHOD(php_wxGridCellAutoWrapStringEditor, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAutoWrapStringEditor::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAutoWrapStringEditor* current_object;
	wxGridCellAutoWrapStringEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridCellAutoWrapStringEditor_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridCellAutoWrapStringEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridCellAutoWrapStringEditor::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellBoolEditor_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellBoolEditor* custom_object = (zo_wxGridCellBoolEditor*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellBoolEditor_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCellBoolEditor done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellBoolEditor_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellBoolEditor_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellBoolEditor* custom_object;
    custom_object = (zo_wxGridCellBoolEditor*) emalloc(sizeof(zo_wxGridCellBoolEditor));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLBOOLEDITOR_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellBoolEditor_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto bool wxGridCellBoolEditor::IsTrueValue(string value)
   Returns true if the given value is equal to the string representation of the truth value we currently use (see UseStringValues()). */
PHP_METHOD(php_wxGridCellBoolEditor, IsTrueValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellBoolEditor::IsTrueValue\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellBoolEditor* current_object;
	wxphp_object_type current_object_type;
	wxGridCellBoolEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellBoolEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellBoolEditor::IsTrueValue call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE){
				references = &((wxGridCellBoolEditor_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* value0;
	long value_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&value0, &value_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0, &value_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_BOOL(wxGridCellBoolEditor::IsTrueValue(wxString(value0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, wxGridCellBoolEditor::IsTrueValue(wxString(value0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellBoolEditor::IsTrueValue\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellBoolEditor::UseStringValues(string valueTrue, string valueFalse)
   This method allows you to customize the values returned by GetValue() for the cell using this editor. */
PHP_METHOD(php_wxGridCellBoolEditor, UseStringValues)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellBoolEditor::UseStringValues\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellBoolEditor* current_object;
	wxphp_object_type current_object_type;
	wxGridCellBoolEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellBoolEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellBoolEditor::UseStringValues call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLBOOLEDITOR_TYPE){
				references = &((wxGridCellBoolEditor_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* valueTrue0;
	long valueTrue_len0;
	char* valueFalse0;
	long valueFalse_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|ss' (&valueTrue0, &valueTrue_len0, &valueFalse0, &valueFalse_len0)\n");
		#endif

		char parse_parameters_string[] = "|ss";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &valueTrue0, &valueTrue_len0, &valueFalse0, &valueFalse_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxGridCellBoolEditor::UseStringValues()\n\n");
				#endif

				wxGridCellBoolEditor::UseStringValues();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxGridCellBoolEditor::UseStringValues(wxString(valueTrue0, wxConvUTF8))\n\n");
				#endif

				wxGridCellBoolEditor::UseStringValues(wxString(valueTrue0, wxConvUTF8));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxGridCellBoolEditor::UseStringValues(wxString(valueTrue0, wxConvUTF8), wxString(valueFalse0, wxConvUTF8))\n\n");
				#endif

				wxGridCellBoolEditor::UseStringValues(wxString(valueTrue0, wxConvUTF8), wxString(valueFalse0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellBoolEditor::UseStringValues\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellBoolEditor::wxGridCellBoolEditor()
   Default constructor. */
PHP_METHOD(php_wxGridCellBoolEditor, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellBoolEditor::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellBoolEditor* current_object;
	wxGridCellBoolEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridCellBoolEditor_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridCellBoolEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridCellBoolEditor::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellChoiceEditor_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellChoiceEditor* custom_object = (zo_wxGridCellChoiceEditor*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellChoiceEditor_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCellChoiceEditor done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellChoiceEditor_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellChoiceEditor_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellChoiceEditor* custom_object;
    custom_object = (zo_wxGridCellChoiceEditor*) emalloc(sizeof(zo_wxGridCellChoiceEditor));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLCHOICEEDITOR_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellChoiceEditor_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridCellChoiceEditor::SetParameters(string params)
   Parameters string format is "item1[,item2[...,itemN]]". */
PHP_METHOD(php_wxGridCellChoiceEditor, SetParameters)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellChoiceEditor::SetParameters\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellChoiceEditor* current_object;
	wxphp_object_type current_object_type;
	wxGridCellChoiceEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellChoiceEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellChoiceEditor::SetParameters call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLCHOICEEDITOR_TYPE){
				references = &((wxGridCellChoiceEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLENUMEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellEnumEditor_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* params0;
	long params_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&params0, &params_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &params0, &params_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellChoiceEditor::SetParameters(wxString(params0, wxConvUTF8))\n\n");
				#endif

				((wxGridCellChoiceEditor_php*)native_object)->SetParameters(wxString(params0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellChoiceEditor::SetParameters\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellChoiceEditor::wxGridCellChoiceEditor(array choices, bool allowOthers)
   Choice cell renderer ctor. */
PHP_METHOD(php_wxGridCellChoiceEditor, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellChoiceEditor::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellChoiceEditor* current_object;
	wxGridCellChoiceEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* choices0 = 0;
	bool allowOthers0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a|b' (&choices0, &allowOthers0)\n");
		#endif

		char parse_parameters_string[] = "a|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &choices0, &allowOthers0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(strings_array0_0)\n");
				#endif

				native_object = new wxGridCellChoiceEditor_php(strings_array0_0);

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(choices0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(strings_array0_0, allowOthers0)\n");
				#endif

				native_object = new wxGridCellChoiceEditor_php(strings_array0_0, allowOthers0);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridCellChoiceEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridCellChoiceEditor::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellEnumEditor_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellEnumEditor* custom_object = (zo_wxGridCellEnumEditor*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellEnumEditor_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCellEnumEditor done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellEnumEditor_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellEnumEditor_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellEnumEditor* custom_object;
    custom_object = (zo_wxGridCellEnumEditor*) emalloc(sizeof(zo_wxGridCellEnumEditor));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLENUMEDITOR_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellEnumEditor_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridCellEnumEditor::wxGridCellEnumEditor(string choices)
   Enum cell editor ctor. */
PHP_METHOD(php_wxGridCellEnumEditor, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellEnumEditor::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellEnumEditor* current_object;
	wxGridCellEnumEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	char* choices0;
	long choices_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|s' (&choices0, &choices_len0)\n");
		#endif

		char parse_parameters_string[] = "|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &choices0, &choices_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridCellEnumEditor_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(choices0, wxConvUTF8))\n");
				#endif

				native_object = new wxGridCellEnumEditor_php(wxString(choices0, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridCellEnumEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridCellEnumEditor::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellTextEditor_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellTextEditor* custom_object = (zo_wxGridCellTextEditor*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellTextEditor_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCellTextEditor done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellTextEditor_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellTextEditor_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellTextEditor* custom_object;
    custom_object = (zo_wxGridCellTextEditor*) emalloc(sizeof(zo_wxGridCellTextEditor));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLTEXTEDITOR_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellTextEditor_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridCellTextEditor::wxGridCellTextEditor()
   Default constructor. */
PHP_METHOD(php_wxGridCellTextEditor, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellTextEditor::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellTextEditor* current_object;
	wxGridCellTextEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridCellTextEditor_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridCellTextEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridCellTextEditor::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxGridCellTextEditor::SetParameters(string params)
   The parameters string format is "n" where n is a number representing the maximum width. */
PHP_METHOD(php_wxGridCellTextEditor, SetParameters)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellTextEditor::SetParameters\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellTextEditor* current_object;
	wxphp_object_type current_object_type;
	wxGridCellTextEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellTextEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellTextEditor::SetParameters call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLTEXTEDITOR_TYPE){
				references = &((wxGridCellTextEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellAutoWrapStringEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellFloatEditor_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE) && (!reference_type_found)){
				references = &((wxGridCellNumberEditor_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* params0;
	long params_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&params0, &params_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &params0, &params_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellTextEditor::SetParameters(wxString(params0, wxConvUTF8))\n\n");
				#endif

				((wxGridCellTextEditor_php*)native_object)->SetParameters(wxString(params0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellTextEditor::SetParameters\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellFloatEditor_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellFloatEditor* custom_object = (zo_wxGridCellFloatEditor*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellFloatEditor_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCellFloatEditor done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellFloatEditor_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellFloatEditor_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellFloatEditor* custom_object;
    custom_object = (zo_wxGridCellFloatEditor*) emalloc(sizeof(zo_wxGridCellFloatEditor));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLFLOATEDITOR_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellFloatEditor_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridCellFloatEditor::wxGridCellFloatEditor(int width, int precision, int format)
   Float cell editor ctor. */
PHP_METHOD(php_wxGridCellFloatEditor, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellFloatEditor::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellFloatEditor* current_object;
	wxGridCellFloatEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	long width0;
	long precision0;
	long format0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|lll' (&width0, &precision0, &format0)\n");
		#endif

		char parse_parameters_string[] = "|lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0, &precision0, &format0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridCellFloatEditor_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width0)\n");
				#endif

				native_object = new wxGridCellFloatEditor_php((int) width0);

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width0, (int) precision0)\n");
				#endif

				native_object = new wxGridCellFloatEditor_php((int) width0, (int) precision0);

				native_object->references.Initialize();
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width0, (int) precision0, (int) format0)\n");
				#endif

				native_object = new wxGridCellFloatEditor_php((int) width0, (int) precision0, (int) format0);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridCellFloatEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridCellFloatEditor::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxGridCellFloatEditor::SetParameters(string params)
   The parameters string format is "width[,precision[,format]]" where format should be chosen between f|e|g|E|G (f is used by default) */
PHP_METHOD(php_wxGridCellFloatEditor, SetParameters)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellFloatEditor::SetParameters\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellFloatEditor* current_object;
	wxphp_object_type current_object_type;
	wxGridCellFloatEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellFloatEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellFloatEditor::SetParameters call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLFLOATEDITOR_TYPE){
				references = &((wxGridCellFloatEditor_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* params0;
	long params_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&params0, &params_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &params0, &params_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellFloatEditor::SetParameters(wxString(params0, wxConvUTF8))\n\n");
				#endif

				((wxGridCellFloatEditor_php*)native_object)->SetParameters(wxString(params0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellFloatEditor::SetParameters\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellNumberEditor_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellNumberEditor* custom_object = (zo_wxGridCellNumberEditor*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellNumberEditor_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCellNumberEditor done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellNumberEditor_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellNumberEditor_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellNumberEditor* custom_object;
    custom_object = (zo_wxGridCellNumberEditor*) emalloc(sizeof(zo_wxGridCellNumberEditor));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLNUMBEREDITOR_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellNumberEditor_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridCellNumberEditor::wxGridCellNumberEditor(int min, int max)
   Allows you to specify the range for acceptable data. */
PHP_METHOD(php_wxGridCellNumberEditor, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellNumberEditor::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellNumberEditor* current_object;
	wxGridCellNumberEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	long min0;
	long max0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|ll' (&min0, &max0)\n");
		#endif

		char parse_parameters_string[] = "|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &min0, &max0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridCellNumberEditor_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) min0)\n");
				#endif

				native_object = new wxGridCellNumberEditor_php((int) min0);

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) min0, (int) max0)\n");
				#endif

				native_object = new wxGridCellNumberEditor_php((int) min0, (int) max0);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridCellNumberEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridCellNumberEditor::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxGridCellNumberEditor::SetParameters(string params)
   Parameters string format is "min,max". */
PHP_METHOD(php_wxGridCellNumberEditor, SetParameters)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellNumberEditor::SetParameters\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellNumberEditor* current_object;
	wxphp_object_type current_object_type;
	wxGridCellNumberEditor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellNumberEditor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellNumberEditor::SetParameters call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLNUMBEREDITOR_TYPE){
				references = &((wxGridCellNumberEditor_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* params0;
	long params_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&params0, &params_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &params0, &params_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellNumberEditor::SetParameters(wxString(params0, wxConvUTF8))\n\n");
				#endif

				((wxGridCellNumberEditor_php*)native_object)->SetParameters(wxString(params0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellNumberEditor::SetParameters\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellAttr_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellAttr* custom_object = (zo_wxGridCellAttr*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellAttr_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellAttr_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellAttr_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellAttr* custom_object;
    custom_object = (zo_wxGridCellAttr*) emalloc(sizeof(zo_wxGridCellAttr));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLATTR_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellAttr_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto wxGridCellAttr wxGridCellAttr::Clone()
   Creates a new copy of this object. */
PHP_METHOD(php_wxGridCellAttr, CloneMethod)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::Clone\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::Clone call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::Clone() to return object pointer\n\n");
				#endif

				wxGridCellAttr_php* value_to_return0;
				value_to_return0 = (wxGridCellAttr_php*) ((wxGridCellAttr_php*)native_object)->Clone();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxGridCellAttr_entry);
					((zo_wxGridCellAttr*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridCellAttr_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGridCellAttr::Clone at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::Clone\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttr::DecRef()
   This class is reference counted: it is created with ref count of 1, so calling DecRef() once will delete it. */
PHP_METHOD(php_wxGridCellAttr, DecRef)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::DecRef\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::DecRef call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::DecRef()\n\n");
				#endif

				((wxGridCellAttr_php*)native_object)->DecRef();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::DecRef\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttr::GetAlignment(int &hAlign, int &vAlign)
   Get the alignment to use for the cell with the given attribute. */
PHP_METHOD(php_wxGridCellAttr, GetAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::GetAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::GetAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long* hAlign0;
	zval* hAlign0_ref;
	long* vAlign0;
	zval* vAlign0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (hAlign0, vAlign0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, hAlign0, vAlign0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &hAlign0_ref, &vAlign0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::GetAlignment((int*) hAlign0, (int*) vAlign0)\n\n");
				#endif

				((wxGridCellAttr_php*)native_object)->GetAlignment((int*) hAlign0, (int*) vAlign0);

				size_t elements_returned0_0 = sizeof(hAlign0)/sizeof(*hAlign0);
				array_init(hAlign0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(hAlign0_ref, hAlign0[i]);
				}
				size_t elements_returned0_1 = sizeof(vAlign0)/sizeof(*vAlign0);
				array_init(vAlign0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(vAlign0_ref, vAlign0[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::GetAlignment\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxGridCellAttr::GetBackgroundColour()
   Returns the background colour. */
PHP_METHOD(php_wxGridCellAttr, GetBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::GetBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::GetBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::GetBackgroundColour() to return object reference\n\n");
				#endif

				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxGridCellAttr_php*)native_object)->GetBackgroundColour();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxGridCellAttr::GetBackgroundColour at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::GetBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto wxGridCellEditor wxGridCellAttr::GetEditor(wxGrid grid, int row, int col)
   Returns the cell editor. */
PHP_METHOD(php_wxGridCellAttr, GetEditor)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::GetEditor\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::GetEditor call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* grid0 = 0;
	wxGrid* object_pointer0_0 = 0;
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zll' (&grid0, &row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "zll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &grid0, &row0, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(grid0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGrid*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRID_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'grid' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(grid0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'grid' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::GetEditor((const wxGrid*) object_pointer0_0, (int) row0, (int) col0) to return object pointer\n\n");
				#endif

				wxGridCellEditor_php* value_to_return3;
				value_to_return3 = (wxGridCellEditor_php*) ((wxGridCellAttr_php*)native_object)->GetEditor((const wxGrid*) object_pointer0_0, (int) row0, (int) col0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxGridCellEditor_entry);
					((zo_wxGridCellEditor*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridCellEditor_php*) value_to_return3;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return3 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGridCellAttr::GetEditor at call with 3 argument(s)");
				}

				references->AddReference(grid0, "wxGridCellAttr::GetEditor at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::GetEditor\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxGridCellAttr::GetFont()
   Returns the font. */
PHP_METHOD(php_wxGridCellAttr, GetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::GetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::GetFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::GetFont() to return object reference\n\n");
				#endif

				wxFont_php* value_to_return0;
				value_to_return0 = (wxFont_php*) &((wxGridCellAttr_php*)native_object)->GetFont();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxGridCellAttr::GetFont at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::GetFont\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttr::GetNonDefaultAlignment(int &hAlign, int &vAlign)
   Get the alignment defined by this attribute. */
PHP_METHOD(php_wxGridCellAttr, GetNonDefaultAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::GetNonDefaultAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::GetNonDefaultAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long* hAlign0;
	zval* hAlign0_ref;
	long* vAlign0;
	zval* vAlign0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (hAlign0, vAlign0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, hAlign0, vAlign0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &hAlign0_ref, &vAlign0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::GetNonDefaultAlignment((int*) hAlign0, (int*) vAlign0)\n\n");
				#endif

				((wxGridCellAttr_php*)native_object)->GetNonDefaultAlignment((int*) hAlign0, (int*) vAlign0);

				size_t elements_returned0_0 = sizeof(hAlign0)/sizeof(*hAlign0);
				array_init(hAlign0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(hAlign0_ref, hAlign0[i]);
				}
				size_t elements_returned0_1 = sizeof(vAlign0)/sizeof(*vAlign0);
				array_init(vAlign0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(vAlign0_ref, vAlign0[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::GetNonDefaultAlignment\n");
	}
}
/* }}} */

/* {{{ proto wxGridCellRenderer wxGridCellAttr::GetRenderer(wxGrid grid, int row, int col)
   Returns the cell renderer. */
PHP_METHOD(php_wxGridCellAttr, GetRenderer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::GetRenderer\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::GetRenderer call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* grid0 = 0;
	wxGrid* object_pointer0_0 = 0;
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zll' (&grid0, &row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "zll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &grid0, &row0, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(grid0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGrid*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRID_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'grid' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(grid0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'grid' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::GetRenderer((const wxGrid*) object_pointer0_0, (int) row0, (int) col0) to return object pointer\n\n");
				#endif

				wxGridCellRenderer_php* value_to_return3;
				value_to_return3 = (wxGridCellRenderer_php*) ((wxGridCellAttr_php*)native_object)->GetRenderer((const wxGrid*) object_pointer0_0, (int) row0, (int) col0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxGridCellRenderer_entry);
					((zo_wxGridCellRenderer*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridCellRenderer_php*) value_to_return3;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return3 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGridCellAttr::GetRenderer at call with 3 argument(s)");
				}

				references->AddReference(grid0, "wxGridCellAttr::GetRenderer at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::GetRenderer\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxGridCellAttr::GetTextColour()
   Returns the text colour. */
PHP_METHOD(php_wxGridCellAttr, GetTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::GetTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::GetTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::GetTextColour() to return object reference\n\n");
				#endif

				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxGridCellAttr_php*)native_object)->GetTextColour();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxGridCellAttr::GetTextColour at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::GetTextColour\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridCellAttr::HasAlignment()
   Returns true if this attribute has a valid alignment set. */
PHP_METHOD(php_wxGridCellAttr, HasAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::HasAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::HasAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridCellAttr::HasAlignment())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridCellAttr_php*)native_object)->HasAlignment());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::HasAlignment\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridCellAttr::HasBackgroundColour()
   Returns true if this attribute has a valid background colour set. */
PHP_METHOD(php_wxGridCellAttr, HasBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::HasBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::HasBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridCellAttr::HasBackgroundColour())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridCellAttr_php*)native_object)->HasBackgroundColour());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::HasBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridCellAttr::HasEditor()
   Returns true if this attribute has a valid cell editor set. */
PHP_METHOD(php_wxGridCellAttr, HasEditor)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::HasEditor\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::HasEditor call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridCellAttr::HasEditor())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridCellAttr_php*)native_object)->HasEditor());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::HasEditor\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridCellAttr::HasFont()
   Returns true if this attribute has a valid font set. */
PHP_METHOD(php_wxGridCellAttr, HasFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::HasFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::HasFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridCellAttr::HasFont())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridCellAttr_php*)native_object)->HasFont());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::HasFont\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridCellAttr::HasRenderer()
   Returns true if this attribute has a valid cell renderer set. */
PHP_METHOD(php_wxGridCellAttr, HasRenderer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::HasRenderer\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::HasRenderer call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridCellAttr::HasRenderer())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridCellAttr_php*)native_object)->HasRenderer());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::HasRenderer\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridCellAttr::HasTextColour()
   Returns true if this attribute has a valid text colour set. */
PHP_METHOD(php_wxGridCellAttr, HasTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::HasTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::HasTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridCellAttr::HasTextColour())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridCellAttr_php*)native_object)->HasTextColour());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::HasTextColour\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttr::IncRef()
   This class is reference counted: it is created with ref count of 1, so calling DecRef() once will delete it. */
PHP_METHOD(php_wxGridCellAttr, IncRef)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::IncRef\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::IncRef call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::IncRef()\n\n");
				#endif

				((wxGridCellAttr_php*)native_object)->IncRef();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::IncRef\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridCellAttr::IsReadOnly()
   Returns true if this cell is set as read-only. */
PHP_METHOD(php_wxGridCellAttr, IsReadOnly)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::IsReadOnly\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::IsReadOnly call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridCellAttr::IsReadOnly())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridCellAttr_php*)native_object)->IsReadOnly());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::IsReadOnly\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttr::SetAlignment(int hAlign, int vAlign)
   Sets the alignment. */
PHP_METHOD(php_wxGridCellAttr, SetAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::SetAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::SetAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long hAlign0;
	long vAlign0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&hAlign0, &vAlign0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &hAlign0, &vAlign0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::SetAlignment((int) hAlign0, (int) vAlign0)\n\n");
				#endif

				((wxGridCellAttr_php*)native_object)->SetAlignment((int) hAlign0, (int) vAlign0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::SetAlignment\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttr::SetBackgroundColour(wxColour colBack)
   Sets the background colour. */
PHP_METHOD(php_wxGridCellAttr, SetBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::SetBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::SetBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colBack0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colBack0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colBack0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colBack0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colBack0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colBack0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colBack' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colBack0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colBack' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::SetBackgroundColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxGridCellAttr_php*)native_object)->SetBackgroundColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colBack0, "wxGridCellAttr::SetBackgroundColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::SetBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttr::SetDefAttr(wxGridCellAttr &defAttr) */
PHP_METHOD(php_wxGridCellAttr, SetDefAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::SetDefAttr\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::SetDefAttr call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* defAttr0 = 0;
	wxGridCellAttr* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&defAttr0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &defAttr0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(defAttr0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellAttr*) zend_object_store_get_object(defAttr0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellAttr*) zend_object_store_get_object(defAttr0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGridCellAttr*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRIDCELLATTR_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'defAttr' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(defAttr0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'defAttr' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::SetDefAttr((wxGridCellAttr*) object_pointer0_0)\n\n");
				#endif

				((wxGridCellAttr_php*)native_object)->SetDefAttr((wxGridCellAttr*) object_pointer0_0);

				references->AddReference(defAttr0, "wxGridCellAttr::SetDefAttr at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::SetDefAttr\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttr::SetEditor(wxGridCellEditor &editor)
   Sets the editor to be used with the cells with this attribute. */
PHP_METHOD(php_wxGridCellAttr, SetEditor)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::SetEditor\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::SetEditor call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* editor0 = 0;
	wxGridCellEditor* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&editor0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &editor0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(editor0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellEditor*) zend_object_store_get_object(editor0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellEditor*) zend_object_store_get_object(editor0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGridCellEditor*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRIDCELLEDITOR_TYPE && argument_type != PHP_WXGRIDCELLBOOLEDITOR_TYPE && argument_type != PHP_WXGRIDCELLCHOICEEDITOR_TYPE && argument_type != PHP_WXGRIDCELLENUMEDITOR_TYPE && argument_type != PHP_WXGRIDCELLTEXTEDITOR_TYPE && argument_type != PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE && argument_type != PHP_WXGRIDCELLFLOATEDITOR_TYPE && argument_type != PHP_WXGRIDCELLNUMBEREDITOR_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'editor' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(editor0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'editor' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::SetEditor((wxGridCellEditor*) object_pointer0_0)\n\n");
				#endif

				((wxGridCellAttr_php*)native_object)->SetEditor((wxGridCellEditor*) object_pointer0_0);

				references->AddReference(editor0, "wxGridCellAttr::SetEditor at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::SetEditor\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttr::SetFont(wxFont font)
   Sets the font. */
PHP_METHOD(php_wxGridCellAttr, SetFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::SetFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::SetFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* font0 = 0;
	wxFont* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxFont*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::SetFont(*(wxFont*) object_pointer0_0)\n\n");
				#endif

				((wxGridCellAttr_php*)native_object)->SetFont(*(wxFont*) object_pointer0_0);

				references->AddReference(font0, "wxGridCellAttr::SetFont at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::SetFont\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttr::SetReadOnly(bool isReadOnly)
   Sets the cell as read-only. */
PHP_METHOD(php_wxGridCellAttr, SetReadOnly)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::SetReadOnly\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::SetReadOnly call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool isReadOnly0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&isReadOnly0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &isReadOnly0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::SetReadOnly()\n\n");
				#endif

				((wxGridCellAttr_php*)native_object)->SetReadOnly();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::SetReadOnly(isReadOnly0)\n\n");
				#endif

				((wxGridCellAttr_php*)native_object)->SetReadOnly(isReadOnly0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::SetReadOnly\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttr::SetRenderer(wxGridCellRenderer &renderer)
   Sets the renderer to be used for cells with this attribute. */
PHP_METHOD(php_wxGridCellAttr, SetRenderer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::SetRenderer\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::SetRenderer call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* renderer0 = 0;
	wxGridCellRenderer* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&renderer0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &renderer0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(renderer0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellRenderer*) zend_object_store_get_object(renderer0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellRenderer*) zend_object_store_get_object(renderer0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGridCellRenderer*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRIDCELLRENDERER_TYPE && argument_type != PHP_WXGRIDCELLBOOLRENDERER_TYPE && argument_type != PHP_WXGRIDCELLSTRINGRENDERER_TYPE && argument_type != PHP_WXGRIDCELLDATETIMERENDERER_TYPE && argument_type != PHP_WXGRIDCELLAUTOWRAPSTRINGRENDERER_TYPE && argument_type != PHP_WXGRIDCELLENUMRENDERER_TYPE && argument_type != PHP_WXGRIDCELLFLOATRENDERER_TYPE && argument_type != PHP_WXGRIDCELLNUMBERRENDERER_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'renderer' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(renderer0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'renderer' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::SetRenderer((wxGridCellRenderer*) object_pointer0_0)\n\n");
				#endif

				((wxGridCellAttr_php*)native_object)->SetRenderer((wxGridCellRenderer*) object_pointer0_0);

				references->AddReference(renderer0, "wxGridCellAttr::SetRenderer at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::SetRenderer\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttr::SetTextColour(wxColour colText)
   Sets the text colour. */
PHP_METHOD(php_wxGridCellAttr, SetTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::SetTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttr::SetTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTR_TYPE){
				references = &((wxGridCellAttr_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colText0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colText0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colText0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colText0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colText0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colText0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colText' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colText0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colText' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttr::SetTextColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxGridCellAttr_php*)native_object)->SetTextColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colText0, "wxGridCellAttr::SetTextColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttr::SetTextColour\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttr::wxGridCellAttr(wxGridCellAttr &attrDefault)
   Default constructor. */
PHP_METHOD(php_wxGridCellAttr, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttr::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttr* current_object;
	wxGridCellAttr_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* attrDefault0 = 0;
	wxGridCellAttr* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* colText1 = 0;
	wxColour* object_pointer1_0 = 0;
	zval* colBack1 = 0;
	wxColour* object_pointer1_1 = 0;
	zval* font1 = 0;
	wxFont* object_pointer1_2 = 0;
	long hAlign1;
	long vAlign1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|z' (&attrDefault0)\n");
		#endif

		char parse_parameters_string[] = "|z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &attrDefault0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(attrDefault0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellAttr*) zend_object_store_get_object(attrDefault0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellAttr*) zend_object_store_get_object(attrDefault0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGridCellAttr*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRIDCELLATTR_TYPE))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(attrDefault0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OOOll' (&colText1, php_wxColour_entry, &colBack1, php_wxColour_entry, &font1, php_wxFont_entry, &hAlign1, &vAlign1)\n");
		#endif

		char parse_parameters_string[] = "OOOll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colText1, php_wxColour_entry, &colBack1, php_wxColour_entry, &font1, php_wxFont_entry, &hAlign1, &vAlign1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colText1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colText1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colText1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxColour*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'colText' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colText1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colText' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(colBack1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colBack1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colBack1 TSRMLS_CC))->native_object;
					object_pointer1_1 = (wxColour*) argument_native_object;
					if (!object_pointer1_1 )
					{
						zend_error(E_ERROR, "Parameter 'colBack' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colBack1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colBack' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(font1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font1 TSRMLS_CC))->native_object;
					object_pointer1_2 = (wxFont*) argument_native_object;
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridCellAttr_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxGridCellAttr*) object_pointer0_0)\n");
				#endif

				native_object = new wxGridCellAttr_php((wxGridCellAttr*) object_pointer0_0);

				native_object->references.Initialize();
				((wxGridCellAttr_php*) native_object)->references.AddReference(attrDefault0, "wxGridCellAttr::wxGridCellAttr at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1, *(wxFont*) object_pointer1_2, (int) hAlign1, (int) vAlign1)\n");
				#endif

				native_object = new wxGridCellAttr_php(*(wxColour*) object_pointer1_0, *(wxColour*) object_pointer1_1, *(wxFont*) object_pointer1_2, (int) hAlign1, (int) vAlign1);

				native_object->references.Initialize();
				((wxGridCellAttr_php*) native_object)->references.AddReference(colText1, "wxGridCellAttr::wxGridCellAttr at call with 5 argument(s)");
				((wxGridCellAttr_php*) native_object)->references.AddReference(colBack1, "wxGridCellAttr::wxGridCellAttr at call with 5 argument(s)");
				((wxGridCellAttr_php*) native_object)->references.AddReference(font1, "wxGridCellAttr::wxGridCellAttr at call with 5 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridCellAttr*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridCellAttr::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridTableBase_free(void *object TSRMLS_DC) 
{
    zo_wxGridTableBase* custom_object = (zo_wxGridTableBase*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridTableBase_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridTableBase done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridTableBase_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridTableBase_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridTableBase* custom_object;
    custom_object = (zo_wxGridTableBase*) emalloc(sizeof(zo_wxGridTableBase));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDTABLEBASE_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridTableBase_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto bool wxGridTableBase::AppendCols(int numCols)
   Exactly the same as AppendRows() but for columns. */
PHP_METHOD(php_wxGridTableBase, AppendCols)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::AppendCols\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::AppendCols call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long numCols0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&numCols0)\n");
		#endif

		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &numCols0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::AppendCols())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->AppendCols());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::AppendCols((size_t) numCols0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->AppendCols((size_t) numCols0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::AppendCols\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridTableBase::AppendRows(int numRows)
   Append additional rows at the end of the table. */
PHP_METHOD(php_wxGridTableBase, AppendRows)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::AppendRows\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::AppendRows call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long numRows0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&numRows0)\n");
		#endif

		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &numRows0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::AppendRows())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->AppendRows());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::AppendRows((size_t) numRows0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->AppendRows((size_t) numRows0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::AppendRows\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridTableBase::CanGetValueAs(int row, int col, string typeName)
   Returns true if the value of the given cell can be accessed as if it were of the specified type. */
PHP_METHOD(php_wxGridTableBase, CanGetValueAs)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::CanGetValueAs\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::CanGetValueAs call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	char* typeName0;
	long typeName_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lls' (&row0, &col0, &typeName0, &typeName_len0)\n");
		#endif

		char parse_parameters_string[] = "lls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &typeName0, &typeName_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::CanGetValueAs((int) row0, (int) col0, wxString(typeName0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->CanGetValueAs((int) row0, (int) col0, wxString(typeName0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::CanGetValueAs\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridTableBase::CanHaveAttributes()
   Returns true if this table supports attributes or false otherwise. */
PHP_METHOD(php_wxGridTableBase, CanHaveAttributes)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::CanHaveAttributes\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::CanHaveAttributes call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::CanHaveAttributes())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->CanHaveAttributes());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::CanHaveAttributes\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridTableBase::CanSetValueAs(int row, int col, string typeName)
   Returns true if the value of the given cell can be set as if it were of the specified type. */
PHP_METHOD(php_wxGridTableBase, CanSetValueAs)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::CanSetValueAs\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::CanSetValueAs call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	char* typeName0;
	long typeName_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lls' (&row0, &col0, &typeName0, &typeName_len0)\n");
		#endif

		char parse_parameters_string[] = "lls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &typeName0, &typeName_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::CanSetValueAs((int) row0, (int) col0, wxString(typeName0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->CanSetValueAs((int) row0, (int) col0, wxString(typeName0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::CanSetValueAs\n");
	}
}
/* }}} */

/* {{{ proto  wxGridTableBase::Clear()
   Clear the table contents. */
PHP_METHOD(php_wxGridTableBase, Clear)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::Clear\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::Clear call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridTableBase::Clear()\n\n");
				#endif

				((wxGridTableBase_php*)native_object)->Clear();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::Clear\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridTableBase::DeleteCols(int pos, int numCols)
   Exactly the same as DeleteRows() but for columns. */
PHP_METHOD(php_wxGridTableBase, DeleteCols)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::DeleteCols\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::DeleteCols call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	long numCols0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|ll' (&pos0, &numCols0)\n");
		#endif

		char parse_parameters_string[] = "|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, &numCols0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::DeleteCols())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->DeleteCols());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::DeleteCols((size_t) pos0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->DeleteCols((size_t) pos0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::DeleteCols((size_t) pos0, (size_t) numCols0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->DeleteCols((size_t) pos0, (size_t) numCols0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::DeleteCols\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridTableBase::DeleteRows(int pos, int numRows)
   Delete rows from the table. */
PHP_METHOD(php_wxGridTableBase, DeleteRows)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::DeleteRows\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::DeleteRows call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	long numRows0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|ll' (&pos0, &numRows0)\n");
		#endif

		char parse_parameters_string[] = "|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, &numRows0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::DeleteRows())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->DeleteRows());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::DeleteRows((size_t) pos0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->DeleteRows((size_t) pos0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::DeleteRows((size_t) pos0, (size_t) numRows0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->DeleteRows((size_t) pos0, (size_t) numRows0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::DeleteRows\n");
	}
}
/* }}} */

/* {{{ proto wxGridCellAttr wxGridTableBase::GetAttr(int row, int col, wxGridCellAttr::wxAttrKind kind)
   Return the attribute for the given cell. */
PHP_METHOD(php_wxGridTableBase, GetAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::GetAttr\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::GetAttr call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	long kind0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&row0, &col0, &kind0)\n");
		#endif

		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &kind0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridTableBase::GetAttr((int) row0, (int) col0, (wxGridCellAttr::wxAttrKind) kind0) to return object pointer\n\n");
				#endif

				wxGridCellAttr_php* value_to_return3;
				value_to_return3 = (wxGridCellAttr_php*) ((wxGridTableBase_php*)native_object)->GetAttr((int) row0, (int) col0, (wxGridCellAttr::wxAttrKind) kind0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxGridCellAttr_entry);
					((zo_wxGridCellAttr*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridCellAttr_php*) value_to_return3;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return3 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGridTableBase::GetAttr at call with 3 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::GetAttr\n");
	}
}
/* }}} */

/* {{{ proto wxGridCellAttrProvider wxGridTableBase::GetAttrProvider()
   Returns the attribute provider currently being used. */
PHP_METHOD(php_wxGridTableBase, GetAttrProvider)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::GetAttrProvider\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::GetAttrProvider call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridTableBase::GetAttrProvider() to return object pointer\n\n");
				#endif

				wxGridCellAttrProvider_php* value_to_return0;
				value_to_return0 = (wxGridCellAttrProvider_php*) ((wxGridTableBase_php*)native_object)->GetAttrProvider();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxGridCellAttrProvider_entry);
					((zo_wxGridCellAttrProvider*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridCellAttrProvider_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGridTableBase::GetAttrProvider at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::GetAttrProvider\n");
	}
}
/* }}} */

/* {{{ proto string wxGridTableBase::GetColLabelValue(int col)
   Return the label of the specified column. */
PHP_METHOD(php_wxGridTableBase, GetColLabelValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::GetColLabelValue\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::GetColLabelValue call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxGridTableBase::GetColLabelValue((int) col0).fn_str(), 1)\n\n");
				#endif

				wxString value_to_return1;
				value_to_return1 = ((wxGridTableBase_php*)native_object)->GetColLabelValue((int) col0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::GetColLabelValue\n");
	}
}
/* }}} */

/* {{{ proto int wxGridTableBase::GetColsCount()
   Return the number of columns in the table. */
PHP_METHOD(php_wxGridTableBase, GetColsCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::GetColsCount\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::GetColsCount call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGridTableBase::GetColsCount())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGridTableBase_php*)native_object)->GetColsCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::GetColsCount\n");
	}
}
/* }}} */

/* {{{ proto int wxGridTableBase::GetNumberCols()
   Must be overridden to return the number of columns in the table. */
int wxGridTableBase_php::GetNumberCols()
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxGridTableBase::GetNumberCols\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetNumberCols", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetNumberCols", 13, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxGridTableBase::GetNumberCols'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (int) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto int wxGridTableBase::GetNumberRows()
   Must be overridden to return the number of rows in the table. */
int wxGridTableBase_php::GetNumberRows()
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxGridTableBase::GetNumberRows\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetNumberRows", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetNumberRows", 13, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxGridTableBase::GetNumberRows'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (int) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto string wxGridTableBase::GetRowLabelValue(int row)
   Return the label of the specified row. */
PHP_METHOD(php_wxGridTableBase, GetRowLabelValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::GetRowLabelValue\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::GetRowLabelValue call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxGridTableBase::GetRowLabelValue((int) row0).fn_str(), 1)\n\n");
				#endif

				wxString value_to_return1;
				value_to_return1 = ((wxGridTableBase_php*)native_object)->GetRowLabelValue((int) row0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::GetRowLabelValue\n");
	}
}
/* }}} */

/* {{{ proto int wxGridTableBase::GetRowsCount()
   Return the number of rows in the table. */
PHP_METHOD(php_wxGridTableBase, GetRowsCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::GetRowsCount\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::GetRowsCount call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGridTableBase::GetRowsCount())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGridTableBase_php*)native_object)->GetRowsCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::GetRowsCount\n");
	}
}
/* }}} */

/* {{{ proto string wxGridTableBase::GetTypeName(int row, int col)
   Returns the type of the value in the given cell. */
PHP_METHOD(php_wxGridTableBase, GetTypeName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::GetTypeName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::GetTypeName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxGridTableBase::GetTypeName((int) row0, (int) col0).fn_str(), 1)\n\n");
				#endif

				wxString value_to_return2;
				value_to_return2 = ((wxGridTableBase_php*)native_object)->GetTypeName((int) row0, (int) col0);
				char* temp_string2;
				temp_string2 = (char*)malloc(sizeof(wxChar)*(value_to_return2.size()+1));
				strcpy (temp_string2, (const char *) value_to_return2.char_str() );
				ZVAL_STRING(return_value, temp_string2, 1);
				free(temp_string2);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::GetTypeName\n");
	}
}
/* }}} */

/* {{{ proto string wxGridTableBase::GetValue(int row, int col)
   Must be overridden to implement accessing the table values as text. */
wxString wxGridTableBase_php::GetValue(int row, int col)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxGridTableBase::GetValue\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetValue", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], row);
	ZVAL_LONG(arguments[1], col);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetValue", 8, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxGridTableBase::GetValue'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return wxString(Z_STRVAL_P(return_value), wxConvUTF8);
	
}
/* }}} */

/* {{{ proto bool wxGridTableBase::GetValueAsBool(int row, int col)
   Returns the value of the given cell as a boolean. */
PHP_METHOD(php_wxGridTableBase, GetValueAsBool)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::GetValueAsBool\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::GetValueAsBool call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::GetValueAsBool((int) row0, (int) col0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->GetValueAsBool((int) row0, (int) col0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::GetValueAsBool\n");
	}
}
/* }}} */

/* {{{ proto void wxGridTableBase::GetValueAsCustom(int row, int col, string typeName)
   Returns the value of the given cell as a user-defined type. */
PHP_METHOD(php_wxGridTableBase, GetValueAsCustom)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::GetValueAsCustom\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::GetValueAsCustom call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	char* typeName0;
	long typeName_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lls' (&row0, &col0, &typeName0, &typeName_len0)\n");
		#endif

		char parse_parameters_string[] = "lls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &typeName0, &typeName_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridTableBase::GetValueAsCustom((int) row0, (int) col0, wxString(typeName0, wxConvUTF8))\n\n");
				#endif

				ZVAL_STRING(return_value, (char*) ((wxGridTableBase_php*)native_object)->GetValueAsCustom((int) row0, (int) col0, wxString(typeName0, wxConvUTF8)), 1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::GetValueAsCustom\n");
	}
}
/* }}} */

/* {{{ proto float wxGridTableBase::GetValueAsDouble(int row, int col)
   Returns the value of the given cell as a double. */
PHP_METHOD(php_wxGridTableBase, GetValueAsDouble)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::GetValueAsDouble\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::GetValueAsDouble call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGridTableBase::GetValueAsDouble((int) row0, (int) col0))\n\n");
				#endif

				ZVAL_DOUBLE(return_value, ((wxGridTableBase_php*)native_object)->GetValueAsDouble((int) row0, (int) col0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::GetValueAsDouble\n");
	}
}
/* }}} */

/* {{{ proto int wxGridTableBase::GetValueAsLong(int row, int col)
   Returns the value of the given cell as a long. */
PHP_METHOD(php_wxGridTableBase, GetValueAsLong)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::GetValueAsLong\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::GetValueAsLong call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGridTableBase::GetValueAsLong((int) row0, (int) col0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGridTableBase_php*)native_object)->GetValueAsLong((int) row0, (int) col0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::GetValueAsLong\n");
	}
}
/* }}} */

/* {{{ proto wxGrid wxGridTableBase::GetView()
   Returns the last grid passed to SetView(). */
PHP_METHOD(php_wxGridTableBase, GetView)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::GetView\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::GetView call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridTableBase::GetView() to return object pointer\n\n");
				#endif

				wxGrid_php* value_to_return0;
				value_to_return0 = (wxGrid_php*) ((wxGridTableBase_php*)native_object)->GetView();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxGrid_entry);
					((zo_wxGrid*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGrid_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGridTableBase::GetView at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::GetView\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridTableBase::InsertCols(int pos, int numCols)
   Exactly the same as InsertRows() but for columns. */
PHP_METHOD(php_wxGridTableBase, InsertCols)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::InsertCols\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::InsertCols call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	long numCols0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|ll' (&pos0, &numCols0)\n");
		#endif

		char parse_parameters_string[] = "|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, &numCols0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::InsertCols())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->InsertCols());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::InsertCols((size_t) pos0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->InsertCols((size_t) pos0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::InsertCols((size_t) pos0, (size_t) numCols0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->InsertCols((size_t) pos0, (size_t) numCols0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::InsertCols\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridTableBase::InsertRows(int pos, int numRows)
   Insert additional rows into the table. */
PHP_METHOD(php_wxGridTableBase, InsertRows)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::InsertRows\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::InsertRows call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	long numRows0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|ll' (&pos0, &numRows0)\n");
		#endif

		char parse_parameters_string[] = "|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, &numRows0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::InsertRows())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->InsertRows());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::InsertRows((size_t) pos0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->InsertRows((size_t) pos0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::InsertRows((size_t) pos0, (size_t) numRows0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->InsertRows((size_t) pos0, (size_t) numRows0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::InsertRows\n");
	}
}
/* }}} */

/* {{{ proto bool wxGridTableBase::IsEmptyCell(int row, int col)
   May be overridden to implement testing for empty cells. */
PHP_METHOD(php_wxGridTableBase, IsEmptyCell)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::IsEmptyCell\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::IsEmptyCell call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGridTableBase::IsEmptyCell((int) row0, (int) col0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGridTableBase_php*)native_object)->IsEmptyCell((int) row0, (int) col0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::IsEmptyCell\n");
	}
}
/* }}} */

/* {{{ proto  wxGridTableBase::SetAttr(wxGridCellAttr &attr, int row, int col)
   Set attribute of the specified cell. */
PHP_METHOD(php_wxGridTableBase, SetAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::SetAttr\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::SetAttr call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* attr0 = 0;
	wxGridCellAttr* object_pointer0_0 = 0;
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zll' (&attr0, &row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "zll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &attr0, &row0, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(attr0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGridCellAttr*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRIDCELLATTR_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'attr' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(attr0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'attr' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridTableBase::SetAttr((wxGridCellAttr*) object_pointer0_0, (int) row0, (int) col0)\n\n");
				#endif

				((wxGridTableBase_php*)native_object)->SetAttr((wxGridCellAttr*) object_pointer0_0, (int) row0, (int) col0);

				references->AddReference(attr0, "wxGridTableBase::SetAttr at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::SetAttr\n");
	}
}
/* }}} */

/* {{{ proto  wxGridTableBase::SetAttrProvider(wxGridCellAttrProvider &attrProvider)
   Associate this attributes provider with the table. */
PHP_METHOD(php_wxGridTableBase, SetAttrProvider)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::SetAttrProvider\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::SetAttrProvider call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* attrProvider0 = 0;
	wxGridCellAttrProvider* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&attrProvider0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &attrProvider0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(attrProvider0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellAttrProvider*) zend_object_store_get_object(attrProvider0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellAttrProvider*) zend_object_store_get_object(attrProvider0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGridCellAttrProvider*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRIDCELLATTRPROVIDER_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'attrProvider' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(attrProvider0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'attrProvider' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridTableBase::SetAttrProvider((wxGridCellAttrProvider*) object_pointer0_0)\n\n");
				#endif

				((wxGridTableBase_php*)native_object)->SetAttrProvider((wxGridCellAttrProvider*) object_pointer0_0);

				references->AddReference(attrProvider0, "wxGridTableBase::SetAttrProvider at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::SetAttrProvider\n");
	}
}
/* }}} */

/* {{{ proto  wxGridTableBase::SetColAttr(wxGridCellAttr &attr, int col)
   Set attribute of the specified column. */
PHP_METHOD(php_wxGridTableBase, SetColAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::SetColAttr\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::SetColAttr call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* attr0 = 0;
	wxGridCellAttr* object_pointer0_0 = 0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl' (&attr0, &col0)\n");
		#endif

		char parse_parameters_string[] = "zl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &attr0, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(attr0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGridCellAttr*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRIDCELLATTR_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'attr' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(attr0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'attr' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridTableBase::SetColAttr((wxGridCellAttr*) object_pointer0_0, (int) col0)\n\n");
				#endif

				((wxGridTableBase_php*)native_object)->SetColAttr((wxGridCellAttr*) object_pointer0_0, (int) col0);

				references->AddReference(attr0, "wxGridTableBase::SetColAttr at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::SetColAttr\n");
	}
}
/* }}} */

/* {{{ proto  wxGridTableBase::SetColLabelValue(int col, string label)
   Exactly the same as SetRowLabelValue() but for columns. */
PHP_METHOD(php_wxGridTableBase, SetColLabelValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::SetColLabelValue\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::SetColLabelValue call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	char* label0;
	long label_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&col0, &label0, &label_len0)\n");
		#endif

		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &label0, &label_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridTableBase::SetColLabelValue((int) col0, wxString(label0, wxConvUTF8))\n\n");
				#endif

				((wxGridTableBase_php*)native_object)->SetColLabelValue((int) col0, wxString(label0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::SetColLabelValue\n");
	}
}
/* }}} */

/* {{{ proto  wxGridTableBase::SetRowAttr(wxGridCellAttr &attr, int row)
   Set attribute of the specified row. */
PHP_METHOD(php_wxGridTableBase, SetRowAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::SetRowAttr\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::SetRowAttr call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* attr0 = 0;
	wxGridCellAttr* object_pointer0_0 = 0;
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl' (&attr0, &row0)\n");
		#endif

		char parse_parameters_string[] = "zl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &attr0, &row0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(attr0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGridCellAttr*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRIDCELLATTR_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'attr' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(attr0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'attr' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridTableBase::SetRowAttr((wxGridCellAttr*) object_pointer0_0, (int) row0)\n\n");
				#endif

				((wxGridTableBase_php*)native_object)->SetRowAttr((wxGridCellAttr*) object_pointer0_0, (int) row0);

				references->AddReference(attr0, "wxGridTableBase::SetRowAttr at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::SetRowAttr\n");
	}
}
/* }}} */

/* {{{ proto  wxGridTableBase::SetRowLabelValue(int row, string label)
   Set the given label for the specified row. */
PHP_METHOD(php_wxGridTableBase, SetRowLabelValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::SetRowLabelValue\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::SetRowLabelValue call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	char* label0;
	long label_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&row0, &label0, &label_len0)\n");
		#endif

		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &label0, &label_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridTableBase::SetRowLabelValue((int) row0, wxString(label0, wxConvUTF8))\n\n");
				#endif

				((wxGridTableBase_php*)native_object)->SetRowLabelValue((int) row0, wxString(label0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::SetRowLabelValue\n");
	}
}
/* }}} */

/* {{{ proto  wxGridTableBase::SetValue(int row, int col, string value)
   Must be overridden to implement setting the table values as text. */
void wxGridTableBase_php::SetValue(int row, int col, const wxString& value)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxGridTableBase::SetValue\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "SetValue", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	ZVAL_LONG(arguments[0], row);
	ZVAL_LONG(arguments[1], col);
	temp_string = (char*)malloc(sizeof(wxChar)*(value.size()+1));
	strcpy(temp_string, (const char *) value.char_str());
	ZVAL_STRING(arguments[2], temp_string, 1);
	free(temp_string);
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "SetValue", 8, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxGridTableBase::SetValue'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxGridTableBase::SetValueAsBool(int row, int col, bool value)
   Sets the value of the given cell as a boolean. */
PHP_METHOD(php_wxGridTableBase, SetValueAsBool)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::SetValueAsBool\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::SetValueAsBool call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool value0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llb' (&row0, &col0, &value0)\n");
		#endif

		char parse_parameters_string[] = "llb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &value0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridTableBase::SetValueAsBool((int) row0, (int) col0, value0)\n\n");
				#endif

				((wxGridTableBase_php*)native_object)->SetValueAsBool((int) row0, (int) col0, value0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::SetValueAsBool\n");
	}
}
/* }}} */

/* {{{ proto  wxGridTableBase::SetValueAsCustom(int row, int col, string typeName, void value)
   Sets the value of the given cell as a user-defined type. */
PHP_METHOD(php_wxGridTableBase, SetValueAsCustom)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::SetValueAsCustom\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::SetValueAsCustom call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	char* typeName0;
	long typeName_len0;
	char* value0;
	long value_len0;
	zval* value0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llss' (&row0, &col0, &typeName0, &typeName_len0, &value0, &value_len0)\n");
		#endif

		char parse_parameters_string[] = "llss";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &typeName0, &typeName_len0, &value0, &value_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zzzz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &dummy, &dummy, &value0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridTableBase::SetValueAsCustom((int) row0, (int) col0, wxString(typeName0, wxConvUTF8), (void*) value0)\n\n");
				#endif

				((wxGridTableBase_php*)native_object)->SetValueAsCustom((int) row0, (int) col0, wxString(typeName0, wxConvUTF8), (void*) value0);

				ZVAL_STRING(value0_ref, (char*) value0, 1);

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::SetValueAsCustom\n");
	}
}
/* }}} */

/* {{{ proto  wxGridTableBase::SetValueAsDouble(int row, int col, float value)
   Sets the value of the given cell as a double. */
PHP_METHOD(php_wxGridTableBase, SetValueAsDouble)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::SetValueAsDouble\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::SetValueAsDouble call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	double value0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lld' (&row0, &col0, &value0)\n");
		#endif

		char parse_parameters_string[] = "lld";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &value0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridTableBase::SetValueAsDouble((int) row0, (int) col0, value0)\n\n");
				#endif

				((wxGridTableBase_php*)native_object)->SetValueAsDouble((int) row0, (int) col0, value0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::SetValueAsDouble\n");
	}
}
/* }}} */

/* {{{ proto  wxGridTableBase::SetValueAsLong(int row, int col, int value)
   Sets the value of the given cell as a long. */
PHP_METHOD(php_wxGridTableBase, SetValueAsLong)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::SetValueAsLong\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::SetValueAsLong call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	long value0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&row0, &col0, &value0)\n");
		#endif

		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &value0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridTableBase::SetValueAsLong((int) row0, (int) col0, (long) value0)\n\n");
				#endif

				((wxGridTableBase_php*)native_object)->SetValueAsLong((int) row0, (int) col0, (long) value0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::SetValueAsLong\n");
	}
}
/* }}} */

/* {{{ proto  wxGridTableBase::SetView(wxGrid &grid)
   Called by the grid when the table is associated with it. */
PHP_METHOD(php_wxGridTableBase, SetView)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::SetView\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxphp_object_type current_object_type;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridTableBase::SetView call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDTABLEBASE_TYPE){
				references = &((wxGridTableBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* grid0 = 0;
	wxGrid* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&grid0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &grid0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(grid0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGrid*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRID_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'grid' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(grid0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'grid' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridTableBase::SetView((wxGrid*) object_pointer0_0)\n\n");
				#endif

				((wxGridTableBase_php*)native_object)->SetView((wxGrid*) object_pointer0_0);

				references->AddReference(grid0, "wxGridTableBase::SetView at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridTableBase::SetView\n");
	}
}
/* }}} */

/* {{{ proto  wxGridTableBase::wxGridTableBase()
   Default constructor. */
PHP_METHOD(php_wxGridTableBase, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridTableBase::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridTableBase* current_object;
	wxGridTableBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridTableBase_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridTableBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridTableBase::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridSizesInfo_free(void *object TSRMLS_DC) 
{
    zo_wxGridSizesInfo* custom_object = (zo_wxGridSizesInfo*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridSizesInfo_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridSizesInfo done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridSizesInfo_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridSizesInfo_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridSizesInfo* custom_object;
    custom_object = (zo_wxGridSizesInfo*) emalloc(sizeof(zo_wxGridSizesInfo));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDSIZESINFO_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridSizesInfo_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridSizesInfo::wxGridSizesInfo()
   Default constructor. */
PHP_METHOD(php_wxGridSizesInfo, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridSizesInfo::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridSizesInfo* current_object;
	wxGridSizesInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridSizesInfo_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridSizesInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridSizesInfo::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

PHP_METHOD(php_wxGridSizesInfo, __get)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridSizesInfo::__get\n");
	php_printf("===========================================\n");
	#endif
	
	int arguments_received = ZEND_NUM_ARGS();
	zo_wxGridSizesInfo* current_object;
	wxGridSizesInfo_php* native_object;
	
	char* name;
	int name_len;
	
	//Get native object of the php object that called the method
	if (getThis() != NULL) 
	{
		current_object = (zo_wxGridSizesInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridSizesInfo::wxGridSizesInfo call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
		}
	}
	else
	{
		zend_error(E_ERROR, "Could not process __get call as static\n");
	}
	
	char parse_parameters_string[] = "s";
	
	if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name, &name_len ) == FAILURE)
	{
		RETVAL_NULL();
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Property to get: %s\n", name);
	php_printf("===========================================\n\n");
	#endif
	
	if(false){}
	else if(strcmp("m_sizeDefault", name) == 0)
	{
		RETVAL_LONG(*((int*) native_object->properties[0]));
	}
	else if(strcmp("m_customSizes", name) == 0)
	{
	}
	else
	{
		RETVAL_NULL();
	}
}
/* {{{ proto int wxGridSizesInfo::GetSize(int pos)
   Get the element size. */
PHP_METHOD(php_wxGridSizesInfo, GetSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridSizesInfo::GetSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridSizesInfo* current_object;
	wxphp_object_type current_object_type;
	wxGridSizesInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridSizesInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridSizesInfo::GetSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDSIZESINFO_TYPE){
				references = &((wxGridSizesInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pos0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGridSizesInfo::GetSize((unsigned) pos0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGridSizesInfo_php*)native_object)->GetSize((unsigned) pos0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridSizesInfo::GetSize\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGrid_free(void *object TSRMLS_DC) 
{
    zo_wxGrid* custom_object = (zo_wxGrid*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate delete call for wxGrid on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGrid_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGrid_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGrid* custom_object;
    custom_object = (zo_wxGrid*) emalloc(sizeof(zo_wxGrid));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRID_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGrid_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto bool wxGrid::AppendCols(int numCols, bool updateLabels)
   Appends one or more new columns to the right of the grid. */
PHP_METHOD(php_wxGrid, AppendCols)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::AppendCols\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::AppendCols call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long numCols0;
	bool updateLabels0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|lb' (&numCols0, &updateLabels0)\n");
		#endif

		char parse_parameters_string[] = "|lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &numCols0, &updateLabels0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::AppendCols())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->AppendCols());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::AppendCols((int) numCols0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->AppendCols((int) numCols0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::AppendCols((int) numCols0, updateLabels0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->AppendCols((int) numCols0, updateLabels0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::AppendCols\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::AppendRows(int numRows, bool updateLabels)
   Appends one or more new rows to the bottom of the grid. */
PHP_METHOD(php_wxGrid, AppendRows)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::AppendRows\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::AppendRows call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long numRows0;
	bool updateLabels0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|lb' (&numRows0, &updateLabels0)\n");
		#endif

		char parse_parameters_string[] = "|lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &numRows0, &updateLabels0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::AppendRows())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->AppendRows());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::AppendRows((int) numRows0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->AppendRows((int) numRows0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::AppendRows((int) numRows0, updateLabels0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->AppendRows((int) numRows0, updateLabels0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::AppendRows\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::AreHorzGridLinesClipped()
   Return true if the horizontal grid lines stop at the last column boundary or false if they continue to the end of the window. */
PHP_METHOD(php_wxGrid, AreHorzGridLinesClipped)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::AreHorzGridLinesClipped\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::AreHorzGridLinesClipped call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::AreHorzGridLinesClipped())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->AreHorzGridLinesClipped());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::AreHorzGridLinesClipped\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::AreVertGridLinesClipped()
   Return true if the vertical grid lines stop at the last row boundary or false if they continue to the end of the window. */
PHP_METHOD(php_wxGrid, AreVertGridLinesClipped)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::AreVertGridLinesClipped\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::AreVertGridLinesClipped call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::AreVertGridLinesClipped())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->AreVertGridLinesClipped());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::AreVertGridLinesClipped\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::AutoSize()
   Automatically sets the height and width of all rows and columns to fit their contents. */
PHP_METHOD(php_wxGrid, AutoSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::AutoSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::AutoSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::AutoSize()\n\n");
				#endif

				((wxGrid_php*)native_object)->AutoSize();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::AutoSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::AutoSizeColLabelSize(int col)
   Automatically adjusts width of the column to fit its label. */
PHP_METHOD(php_wxGrid, AutoSizeColLabelSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::AutoSizeColLabelSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::AutoSizeColLabelSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::AutoSizeColLabelSize((int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->AutoSizeColLabelSize((int) col0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::AutoSizeColLabelSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::AutoSizeColumn(int col, bool setAsMin)
   Automatically sizes the column to fit its contents. */
PHP_METHOD(php_wxGrid, AutoSizeColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::AutoSizeColumn\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::AutoSizeColumn call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool setAsMin0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&col0, &setAsMin0)\n");
		#endif

		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &setAsMin0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::AutoSizeColumn((int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->AutoSizeColumn((int) col0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::AutoSizeColumn((int) col0, setAsMin0)\n\n");
				#endif

				((wxGrid_php*)native_object)->AutoSizeColumn((int) col0, setAsMin0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::AutoSizeColumn\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::AutoSizeColumns(bool setAsMin)
   Automatically sizes all columns to fit their contents. */
PHP_METHOD(php_wxGrid, AutoSizeColumns)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::AutoSizeColumns\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::AutoSizeColumns call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool setAsMin0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&setAsMin0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &setAsMin0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::AutoSizeColumns()\n\n");
				#endif

				((wxGrid_php*)native_object)->AutoSizeColumns();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::AutoSizeColumns(setAsMin0)\n\n");
				#endif

				((wxGrid_php*)native_object)->AutoSizeColumns(setAsMin0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::AutoSizeColumns\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::AutoSizeRow(int row, bool setAsMin)
   Automatically sizes the row to fit its contents. */
PHP_METHOD(php_wxGrid, AutoSizeRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::AutoSizeRow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::AutoSizeRow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool setAsMin0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&row0, &setAsMin0)\n");
		#endif

		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &setAsMin0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::AutoSizeRow((int) row0)\n\n");
				#endif

				((wxGrid_php*)native_object)->AutoSizeRow((int) row0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::AutoSizeRow((int) row0, setAsMin0)\n\n");
				#endif

				((wxGrid_php*)native_object)->AutoSizeRow((int) row0, setAsMin0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::AutoSizeRow\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::AutoSizeRowLabelSize(int col)
   Automatically adjusts height of the row to fit its label. */
PHP_METHOD(php_wxGrid, AutoSizeRowLabelSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::AutoSizeRowLabelSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::AutoSizeRowLabelSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::AutoSizeRowLabelSize((int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->AutoSizeRowLabelSize((int) col0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::AutoSizeRowLabelSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::AutoSizeRows(bool setAsMin)
   Automatically sizes all rows to fit their contents. */
PHP_METHOD(php_wxGrid, AutoSizeRows)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::AutoSizeRows\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::AutoSizeRows call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool setAsMin0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&setAsMin0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &setAsMin0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::AutoSizeRows()\n\n");
				#endif

				((wxGrid_php*)native_object)->AutoSizeRows();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::AutoSizeRows(setAsMin0)\n\n");
				#endif

				((wxGrid_php*)native_object)->AutoSizeRows(setAsMin0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::AutoSizeRows\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::BeginBatch()
   Increments the grid's batch count. */
PHP_METHOD(php_wxGrid, BeginBatch)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::BeginBatch\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::BeginBatch call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::BeginBatch()\n\n");
				#endif

				((wxGrid_php*)native_object)->BeginBatch();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::BeginBatch\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::CanDragCell()
   Return true if the dragging of cells is enabled or false otherwise. */
PHP_METHOD(php_wxGrid, CanDragCell)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::CanDragCell\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::CanDragCell call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::CanDragCell())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->CanDragCell());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::CanDragCell\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::CanDragColMove()
   Returns true if columns can be moved by dragging with the mouse. */
PHP_METHOD(php_wxGrid, CanDragColMove)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::CanDragColMove\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::CanDragColMove call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::CanDragColMove())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->CanDragColMove());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::CanDragColMove\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::CanDragColSize(int col)
   Returns true if the given column can be resized by dragging with the mouse. */
PHP_METHOD(php_wxGrid, CanDragColSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::CanDragColSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::CanDragColSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::CanDragColSize((int) col0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->CanDragColSize((int) col0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::CanDragColSize\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::CanDragGridSize()
   Return true if the dragging of grid lines to resize rows and columns is enabled or false otherwise. */
PHP_METHOD(php_wxGrid, CanDragGridSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::CanDragGridSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::CanDragGridSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::CanDragGridSize())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->CanDragGridSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::CanDragGridSize\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::CanDragRowSize(int row)
   Returns true if the given row can be resized by dragging with the mouse. */
PHP_METHOD(php_wxGrid, CanDragRowSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::CanDragRowSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::CanDragRowSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::CanDragRowSize((int) row0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->CanDragRowSize((int) row0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::CanDragRowSize\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::CanEnableCellControl()
   Returns true if the in-place edit control for the current grid cell can be used and false otherwise. */
PHP_METHOD(php_wxGrid, CanEnableCellControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::CanEnableCellControl\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::CanEnableCellControl call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::CanEnableCellControl())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->CanEnableCellControl());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::CanEnableCellControl\n");
	}
}
/* }}} */

/* {{{ proto wxRect wxGrid::CellToRect(int row, int col)
   Return the rectangle corresponding to the grid cell's size and position in logical coordinates. */
PHP_METHOD(php_wxGrid, CellToRect)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::CellToRect\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::CellToRect call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::CellToRect((int) row0, (int) col0) to return new object\n\n");
				#endif

				wxRect value_to_return2;
				value_to_return2 = ((wxGrid_php*)native_object)->CellToRect((int) row0, (int) col0);
				void* ptr = safe_emalloc(1, sizeof(wxRect_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxRect));
				object_init_ex(return_value, php_wxRect_entry);
				((zo_wxRect*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRect_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::CellToRect\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::ClearGrid()
   Clears all data in the underlying grid table and repaints the grid. */
PHP_METHOD(php_wxGrid, ClearGrid)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::ClearGrid\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::ClearGrid call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::ClearGrid()\n\n");
				#endif

				((wxGrid_php*)native_object)->ClearGrid();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::ClearGrid\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::ClearSelection()
   Deselects all cells that are currently selected. */
PHP_METHOD(php_wxGrid, ClearSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::ClearSelection\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::ClearSelection call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::ClearSelection()\n\n");
				#endif

				((wxGrid_php*)native_object)->ClearSelection();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::ClearSelection\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::ClipHorzGridLines(bool clip)
   Change whether the horizontal grid lines are clipped by the end of the last column. */
PHP_METHOD(php_wxGrid, ClipHorzGridLines)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::ClipHorzGridLines\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::ClipHorzGridLines call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool clip0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&clip0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &clip0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::ClipHorzGridLines(clip0)\n\n");
				#endif

				((wxGrid_php*)native_object)->ClipHorzGridLines(clip0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::ClipHorzGridLines\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::ClipVertGridLines(bool clip)
   Change whether the vertical grid lines are clipped by the end of the last row. */
PHP_METHOD(php_wxGrid, ClipVertGridLines)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::ClipVertGridLines\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::ClipVertGridLines call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool clip0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&clip0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &clip0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::ClipVertGridLines(clip0)\n\n");
				#endif

				((wxGrid_php*)native_object)->ClipVertGridLines(clip0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::ClipVertGridLines\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::Create(wxWindow &parent, int id, wxPoint pos, wxSize size, int style, string name)
   Creates the grid window for an object initialized using the default constructor. */
PHP_METHOD(php_wxGrid, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::Create\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::Create call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* parent0 = 0;
	wxWindow* object_pointer0_0 = 0;
	long id0;
	zval* pos0 = 0;
	wxPoint* object_pointer0_2 = 0;
	zval* size0 = 0;
	wxSize* object_pointer0_3 = 0;
	long style0;
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOls' (&parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0)\n");
		#endif

		char parse_parameters_string[] = "zl|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent0, &id0, &pos0, php_wxPoint_entry, &size0, php_wxSize_entry, &style0, &name0, &name_len0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(parent0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(parent0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxWindow*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXPAGESETUPDIALOG_TYPE && argument_type != PHP_WXPRINTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'parent' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'parent' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pos0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pos0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxPoint*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'pos' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pos' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->native_object;
					object_pointer0_3 = (wxSize*) argument_native_object;
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0));

				references->AddReference(parent0, "wxGrid::Create at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2));

				references->AddReference(parent0, "wxGrid::Create at call with 3 argument(s)");
				references->AddReference(pos0, "wxGrid::Create at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3));

				references->AddReference(parent0, "wxGrid::Create at call with 4 argument(s)");
				references->AddReference(pos0, "wxGrid::Create at call with 4 argument(s)");
				references->AddReference(size0, "wxGrid::Create at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0));

				references->AddReference(parent0, "wxGrid::Create at call with 5 argument(s)");
				references->AddReference(pos0, "wxGrid::Create at call with 5 argument(s)");
				references->AddReference(size0, "wxGrid::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->Create((wxWindow*) object_pointer0_0, (wxWindowID) id0, *(wxPoint*) object_pointer0_2, *(wxSize*) object_pointer0_3, (long) style0, wxString(name0, wxConvUTF8)));

				references->AddReference(parent0, "wxGrid::Create at call with 6 argument(s)");
				references->AddReference(pos0, "wxGrid::Create at call with 6 argument(s)");
				references->AddReference(size0, "wxGrid::Create at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::Create\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::CreateGrid(int numRows, int numCols, wxGridSelectionModes selmode)
   Creates a grid with the specified initial number of rows and columns. */
PHP_METHOD(php_wxGrid, CreateGrid)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::CreateGrid\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::CreateGrid call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long numRows0;
	long numCols0;
	long selmode0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll|l' (&numRows0, &numCols0, &selmode0)\n");
		#endif

		char parse_parameters_string[] = "ll|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &numRows0, &numCols0, &selmode0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::CreateGrid((int) numRows0, (int) numCols0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->CreateGrid((int) numRows0, (int) numCols0));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::CreateGrid((int) numRows0, (int) numCols0, (wxGrid::wxGridSelectionModes) selmode0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->CreateGrid((int) numRows0, (int) numCols0, (wxGrid::wxGridSelectionModes) selmode0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::CreateGrid\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::DeleteCols(int pos, int numCols, bool updateLabels)
   Deletes one or more columns from a grid starting at the specified position. */
PHP_METHOD(php_wxGrid, DeleteCols)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::DeleteCols\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::DeleteCols call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	long numCols0;
	bool updateLabels0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|llb' (&pos0, &numCols0, &updateLabels0)\n");
		#endif

		char parse_parameters_string[] = "|llb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, &numCols0, &updateLabels0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::DeleteCols())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->DeleteCols());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::DeleteCols((int) pos0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->DeleteCols((int) pos0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::DeleteCols((int) pos0, (int) numCols0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->DeleteCols((int) pos0, (int) numCols0));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::DeleteCols((int) pos0, (int) numCols0, updateLabels0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->DeleteCols((int) pos0, (int) numCols0, updateLabels0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::DeleteCols\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::DeleteRows(int pos, int numRows, bool updateLabels)
   Deletes one or more rows from a grid starting at the specified position. */
PHP_METHOD(php_wxGrid, DeleteRows)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::DeleteRows\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::DeleteRows call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	long numRows0;
	bool updateLabels0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|llb' (&pos0, &numRows0, &updateLabels0)\n");
		#endif

		char parse_parameters_string[] = "|llb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, &numRows0, &updateLabels0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::DeleteRows())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->DeleteRows());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::DeleteRows((int) pos0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->DeleteRows((int) pos0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::DeleteRows((int) pos0, (int) numRows0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->DeleteRows((int) pos0, (int) numRows0));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::DeleteRows((int) pos0, (int) numRows0, updateLabels0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->DeleteRows((int) pos0, (int) numRows0, updateLabels0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::DeleteRows\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::DisableCellEditControl()
   Disables in-place editing of grid cells. */
PHP_METHOD(php_wxGrid, DisableCellEditControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::DisableCellEditControl\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::DisableCellEditControl call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::DisableCellEditControl()\n\n");
				#endif

				((wxGrid_php*)native_object)->DisableCellEditControl();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::DisableCellEditControl\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::DisableColResize(int col)
   Disable interactive resizing of the specified column. */
PHP_METHOD(php_wxGrid, DisableColResize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::DisableColResize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::DisableColResize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::DisableColResize((int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->DisableColResize((int) col0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::DisableColResize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::DisableDragColMove()
   Disables column moving by dragging with the mouse. */
PHP_METHOD(php_wxGrid, DisableDragColMove)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::DisableDragColMove\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::DisableDragColMove call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::DisableDragColMove()\n\n");
				#endif

				((wxGrid_php*)native_object)->DisableDragColMove();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::DisableDragColMove\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::DisableDragColSize()
   Disables column sizing by dragging with the mouse. */
PHP_METHOD(php_wxGrid, DisableDragColSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::DisableDragColSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::DisableDragColSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::DisableDragColSize()\n\n");
				#endif

				((wxGrid_php*)native_object)->DisableDragColSize();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::DisableDragColSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::DisableDragGridSize()
   Disable mouse dragging of grid lines to resize rows and columns. */
PHP_METHOD(php_wxGrid, DisableDragGridSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::DisableDragGridSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::DisableDragGridSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::DisableDragGridSize()\n\n");
				#endif

				((wxGrid_php*)native_object)->DisableDragGridSize();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::DisableDragGridSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::DisableDragRowSize()
   Disables row sizing by dragging with the mouse. */
PHP_METHOD(php_wxGrid, DisableDragRowSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::DisableDragRowSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::DisableDragRowSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::DisableDragRowSize()\n\n");
				#endif

				((wxGrid_php*)native_object)->DisableDragRowSize();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::DisableDragRowSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::DisableRowResize(int row)
   Disable interactive resizing of the specified row. */
PHP_METHOD(php_wxGrid, DisableRowResize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::DisableRowResize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::DisableRowResize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::DisableRowResize((int) row0)\n\n");
				#endif

				((wxGrid_php*)native_object)->DisableRowResize((int) row0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::DisableRowResize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::EnableCellEditControl(bool enable)
   Enables or disables in-place editing of grid cell data. */
PHP_METHOD(php_wxGrid, EnableCellEditControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::EnableCellEditControl\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::EnableCellEditControl call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&enable0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::EnableCellEditControl()\n\n");
				#endif

				((wxGrid_php*)native_object)->EnableCellEditControl();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::EnableCellEditControl(enable0)\n\n");
				#endif

				((wxGrid_php*)native_object)->EnableCellEditControl(enable0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::EnableCellEditControl\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::EnableDragCell(bool enable)
   Enables or disables cell dragging with the mouse. */
PHP_METHOD(php_wxGrid, EnableDragCell)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::EnableDragCell\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::EnableDragCell call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&enable0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::EnableDragCell()\n\n");
				#endif

				((wxGrid_php*)native_object)->EnableDragCell();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::EnableDragCell(enable0)\n\n");
				#endif

				((wxGrid_php*)native_object)->EnableDragCell(enable0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::EnableDragCell\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::EnableDragColMove(bool enable)
   Enables or disables column moving by dragging with the mouse. */
PHP_METHOD(php_wxGrid, EnableDragColMove)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::EnableDragColMove\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::EnableDragColMove call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&enable0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::EnableDragColMove()\n\n");
				#endif

				((wxGrid_php*)native_object)->EnableDragColMove();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::EnableDragColMove(enable0)\n\n");
				#endif

				((wxGrid_php*)native_object)->EnableDragColMove(enable0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::EnableDragColMove\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::EnableDragColSize(bool enable)
   Enables or disables column sizing by dragging with the mouse. */
PHP_METHOD(php_wxGrid, EnableDragColSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::EnableDragColSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::EnableDragColSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&enable0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::EnableDragColSize()\n\n");
				#endif

				((wxGrid_php*)native_object)->EnableDragColSize();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::EnableDragColSize(enable0)\n\n");
				#endif

				((wxGrid_php*)native_object)->EnableDragColSize(enable0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::EnableDragColSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::EnableDragGridSize(bool enable)
   Enables or disables row and column resizing by dragging gridlines with the mouse. */
PHP_METHOD(php_wxGrid, EnableDragGridSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::EnableDragGridSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::EnableDragGridSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&enable0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::EnableDragGridSize()\n\n");
				#endif

				((wxGrid_php*)native_object)->EnableDragGridSize();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::EnableDragGridSize(enable0)\n\n");
				#endif

				((wxGrid_php*)native_object)->EnableDragGridSize(enable0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::EnableDragGridSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::EnableDragRowSize(bool enable)
   Enables or disables row sizing by dragging with the mouse. */
PHP_METHOD(php_wxGrid, EnableDragRowSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::EnableDragRowSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::EnableDragRowSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&enable0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::EnableDragRowSize()\n\n");
				#endif

				((wxGrid_php*)native_object)->EnableDragRowSize();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::EnableDragRowSize(enable0)\n\n");
				#endif

				((wxGrid_php*)native_object)->EnableDragRowSize(enable0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::EnableDragRowSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::EnableEditing(bool edit)
   Makes the grid globally editable or read-only. */
PHP_METHOD(php_wxGrid, EnableEditing)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::EnableEditing\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::EnableEditing call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool edit0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&edit0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &edit0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::EnableEditing(edit0)\n\n");
				#endif

				((wxGrid_php*)native_object)->EnableEditing(edit0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::EnableEditing\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::EnableGridLines(bool enable)
   Turns the drawing of grid lines on or off. */
PHP_METHOD(php_wxGrid, EnableGridLines)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::EnableGridLines\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::EnableGridLines call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&enable0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::EnableGridLines()\n\n");
				#endif

				((wxGrid_php*)native_object)->EnableGridLines();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::EnableGridLines(enable0)\n\n");
				#endif

				((wxGrid_php*)native_object)->EnableGridLines(enable0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::EnableGridLines\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::EndBatch()
   Decrements the grid's batch count. */
PHP_METHOD(php_wxGrid, EndBatch)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::EndBatch\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::EndBatch call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::EndBatch()\n\n");
				#endif

				((wxGrid_php*)native_object)->EndBatch();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::EndBatch\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::Fit()
   Overridden wxWindow method. */
PHP_METHOD(php_wxGrid, Fit)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::Fit\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::Fit call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::Fit()\n\n");
				#endif

				((wxGrid_php*)native_object)->Fit();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::Fit\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::ForceRefresh()
   Causes immediate repainting of the grid. */
PHP_METHOD(php_wxGrid, ForceRefresh)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::ForceRefresh\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::ForceRefresh call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::ForceRefresh()\n\n");
				#endif

				((wxGrid_php*)native_object)->ForceRefresh();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::ForceRefresh\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetBatchCount()
   Returns the number of times that BeginBatch() has been called without (yet) matching calls to EndBatch(). */
PHP_METHOD(php_wxGrid, GetBatchCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetBatchCount\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetBatchCount call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetBatchCount())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetBatchCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetBatchCount\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::GetCellAlignment(int row, int col, int &horiz, int &vert)
   Sets the arguments to the horizontal and vertical text alignment values for the grid cell at the specified location. */
PHP_METHOD(php_wxGrid, GetCellAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetCellAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetCellAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	long* horiz0;
	zval* horiz0_ref;
	long* vert0;
	zval* vert0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll' (&row0, &col0, horiz0, vert0)\n");
		#endif

		char parse_parameters_string[] = "llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, horiz0, vert0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zzzz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &dummy, &horiz0_ref, &vert0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetCellAlignment((int) row0, (int) col0, (int*) horiz0, (int*) vert0)\n\n");
				#endif

				((wxGrid_php*)native_object)->GetCellAlignment((int) row0, (int) col0, (int*) horiz0, (int*) vert0);

				size_t elements_returned0_2 = sizeof(horiz0)/sizeof(*horiz0);
				array_init(horiz0_ref);
				for(size_t i=0; i<elements_returned0_2; i++)
				{
					add_next_index_long(horiz0_ref, horiz0[i]);
				}
				size_t elements_returned0_3 = sizeof(vert0)/sizeof(*vert0);
				array_init(vert0_ref);
				for(size_t i=0; i<elements_returned0_3; i++)
				{
					add_next_index_long(vert0_ref, vert0[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetCellAlignment\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxGrid::GetCellBackgroundColour(int row, int col)
   Returns the background colour of the cell at the specified location. */
PHP_METHOD(php_wxGrid, GetCellBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetCellBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetCellBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetCellBackgroundColour((int) row0, (int) col0) to return new object\n\n");
				#endif

				wxColour value_to_return2;
				value_to_return2 = ((wxGrid_php*)native_object)->GetCellBackgroundColour((int) row0, (int) col0);
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetCellBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto wxGridCellEditor wxGrid::GetCellEditor(int row, int col)
   Returns a pointer to the editor for the cell at the specified location. */
PHP_METHOD(php_wxGrid, GetCellEditor)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetCellEditor\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetCellEditor call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetCellEditor((int) row0, (int) col0) to return object pointer\n\n");
				#endif

				wxGridCellEditor_php* value_to_return2;
				value_to_return2 = (wxGridCellEditor_php*) ((wxGrid_php*)native_object)->GetCellEditor((int) row0, (int) col0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxGridCellEditor_entry);
					((zo_wxGridCellEditor*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridCellEditor_php*) value_to_return2;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return2 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGrid::GetCellEditor at call with 2 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetCellEditor\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxGrid::GetCellFont(int row, int col)
   Returns the font for text in the grid cell at the specified location. */
PHP_METHOD(php_wxGrid, GetCellFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetCellFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetCellFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetCellFont((int) row0, (int) col0) to return new object\n\n");
				#endif

				wxFont_php *value_to_return2;
				value_to_return2 = new wxFont_php(((wxGrid_php *) native_object)->GetCellFont((int) row0, (int) col0));
				object_init_ex(return_value, php_wxFont_entry);
				zo_wxFont* zo2 = (zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo2->native_object = value_to_return2;
				zo2->is_user_initialized = 1;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetCellFont\n");
	}
}
/* }}} */

/* {{{ proto wxGridCellRenderer wxGrid::GetCellRenderer(int row, int col)
   Returns a pointer to the renderer for the grid cell at the specified location. */
PHP_METHOD(php_wxGrid, GetCellRenderer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetCellRenderer\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetCellRenderer call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetCellRenderer((int) row0, (int) col0) to return object pointer\n\n");
				#endif

				wxGridCellRenderer_php* value_to_return2;
				value_to_return2 = (wxGridCellRenderer_php*) ((wxGrid_php*)native_object)->GetCellRenderer((int) row0, (int) col0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxGridCellRenderer_entry);
					((zo_wxGridCellRenderer*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridCellRenderer_php*) value_to_return2;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return2 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGrid::GetCellRenderer at call with 2 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetCellRenderer\n");
	}
}
/* }}} */

/* {{{ proto CellSpan wxGrid::GetCellSize(int row, int col, int &num_rows, int &num_cols)
   Get the size of the cell in number of cells covered by it. */
PHP_METHOD(php_wxGrid, GetCellSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetCellSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetCellSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	long* num_rows0;
	zval* num_rows0_ref;
	long* num_cols0;
	zval* num_cols0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll' (&row0, &col0, num_rows0, num_cols0)\n");
		#endif

		char parse_parameters_string[] = "llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, num_rows0, num_cols0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zzzz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &dummy, &num_rows0_ref, &num_cols0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetCellSize((int) row0, (int) col0, (int*) num_rows0, (int*) num_cols0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetCellSize((int) row0, (int) col0, (int*) num_rows0, (int*) num_cols0));

				size_t elements_returned0_2 = sizeof(num_rows0)/sizeof(*num_rows0);
				array_init(num_rows0_ref);
				for(size_t i=0; i<elements_returned0_2; i++)
				{
					add_next_index_long(num_rows0_ref, num_rows0[i]);
				}
				size_t elements_returned0_3 = sizeof(num_cols0)/sizeof(*num_cols0);
				array_init(num_cols0_ref);
				for(size_t i=0; i<elements_returned0_3; i++)
				{
					add_next_index_long(num_cols0_ref, num_cols0[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetCellSize\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxGrid::GetCellTextColour(int row, int col)
   Returns the text colour for the grid cell at the specified location. */
PHP_METHOD(php_wxGrid, GetCellTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetCellTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetCellTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetCellTextColour((int) row0, (int) col0) to return new object\n\n");
				#endif

				wxColour value_to_return2;
				value_to_return2 = ((wxGrid_php*)native_object)->GetCellTextColour((int) row0, (int) col0);
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetCellTextColour\n");
	}
}
/* }}} */

/* {{{ proto string wxGrid::GetCellValue(int row, int col)
   Returns the string contained in the cell at the specified location. */
PHP_METHOD(php_wxGrid, GetCellValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetCellValue\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetCellValue call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxGrid::GetCellValue((int) row0, (int) col0).fn_str(), 1)\n\n");
				#endif

				wxString value_to_return2;
				value_to_return2 = ((wxGrid_php*)native_object)->GetCellValue((int) row0, (int) col0);
				char* temp_string2;
				temp_string2 = (char*)malloc(sizeof(wxChar)*(value_to_return2.size()+1));
				strcpy (temp_string2, (const char *) value_to_return2.char_str() );
				ZVAL_STRING(return_value, temp_string2, 1);
				free(temp_string2);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetCellValue\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetColAt(int colPos)
   Returns the column ID of the specified column position. */
PHP_METHOD(php_wxGrid, GetColAt)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetColAt\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetColAt call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long colPos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&colPos0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colPos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetColAt((int) colPos0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetColAt((int) colPos0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetColAt\n");
	}
}
/* }}} */

/* {{{ proto wxPen wxGrid::GetColGridLinePen(int col)
   Returns the pen used for vertical grid lines. */
PHP_METHOD(php_wxGrid, GetColGridLinePen)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetColGridLinePen\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetColGridLinePen call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetColGridLinePen((int) col0) to return new object\n\n");
				#endif

				wxPen value_to_return1;
				value_to_return1 = ((wxGrid_php*)native_object)->GetColGridLinePen((int) col0);
				void* ptr = safe_emalloc(1, sizeof(wxPen_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxPen));
				object_init_ex(return_value, php_wxPen_entry);
				((zo_wxPen*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPen_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetColGridLinePen\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::GetColLabelAlignment(int &horiz, int &vert)
   Sets the arguments to the current column label alignment values. */
PHP_METHOD(php_wxGrid, GetColLabelAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetColLabelAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetColLabelAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long* horiz0;
	zval* horiz0_ref;
	long* vert0;
	zval* vert0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (horiz0, vert0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, horiz0, vert0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &horiz0_ref, &vert0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetColLabelAlignment((int*) horiz0, (int*) vert0)\n\n");
				#endif

				((wxGrid_php*)native_object)->GetColLabelAlignment((int*) horiz0, (int*) vert0);

				size_t elements_returned0_0 = sizeof(horiz0)/sizeof(*horiz0);
				array_init(horiz0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(horiz0_ref, horiz0[i]);
				}
				size_t elements_returned0_1 = sizeof(vert0)/sizeof(*vert0);
				array_init(vert0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(vert0_ref, vert0[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetColLabelAlignment\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetColLabelSize()
   Returns the current height of the column labels. */
PHP_METHOD(php_wxGrid, GetColLabelSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetColLabelSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetColLabelSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetColLabelSize())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetColLabelSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetColLabelSize\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetColLabelTextOrientation()
   Returns the orientation of the column labels (either wxHORIZONTAL or wxVERTICAL). */
PHP_METHOD(php_wxGrid, GetColLabelTextOrientation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetColLabelTextOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetColLabelTextOrientation call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetColLabelTextOrientation())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetColLabelTextOrientation());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetColLabelTextOrientation\n");
	}
}
/* }}} */

/* {{{ proto string wxGrid::GetColLabelValue(int col)
   Returns the specified column label. */
PHP_METHOD(php_wxGrid, GetColLabelValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetColLabelValue\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetColLabelValue call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxGrid::GetColLabelValue((int) col0).fn_str(), 1)\n\n");
				#endif

				wxString value_to_return1;
				value_to_return1 = ((wxGrid_php*)native_object)->GetColLabelValue((int) col0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetColLabelValue\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetColMinimalAcceptableWidth()
   Returns the minimal width to which a column may be resized. */
PHP_METHOD(php_wxGrid, GetColMinimalAcceptableWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetColMinimalAcceptableWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetColMinimalAcceptableWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetColMinimalAcceptableWidth())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetColMinimalAcceptableWidth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetColMinimalAcceptableWidth\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetColPos(int colID)
   Returns the position of the specified column. */
PHP_METHOD(php_wxGrid, GetColPos)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetColPos\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetColPos call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long colID0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&colID0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colID0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetColPos((int) colID0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetColPos((int) colID0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetColPos\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetColSize(int col)
   Returns the width of the specified column. */
PHP_METHOD(php_wxGrid, GetColSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetColSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetColSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetColSize((int) col0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetColSize((int) col0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetColSize\n");
	}
}
/* }}} */

/* {{{ proto wxGridSizesInfo wxGrid::GetColSizes()
   Get size information for all columns at once. */
PHP_METHOD(php_wxGrid, GetColSizes)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetColSizes\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetColSizes call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetColSizes() to return new object\n\n");
				#endif

				wxGridSizesInfo value_to_return0;
				value_to_return0 = ((wxGrid_php*)native_object)->GetColSizes();
				void* ptr = safe_emalloc(1, sizeof(wxGridSizesInfo_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxGridSizesInfo));
				object_init_ex(return_value, php_wxGridSizesInfo_entry);
				((zo_wxGridSizesInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridSizesInfo_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetColSizes\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::GetDefaultCellAlignment(int &horiz, int &vert)
   Returns the default cell alignment. */
PHP_METHOD(php_wxGrid, GetDefaultCellAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetDefaultCellAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetDefaultCellAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long* horiz0;
	zval* horiz0_ref;
	long* vert0;
	zval* vert0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (horiz0, vert0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, horiz0, vert0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &horiz0_ref, &vert0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetDefaultCellAlignment((int*) horiz0, (int*) vert0)\n\n");
				#endif

				((wxGrid_php*)native_object)->GetDefaultCellAlignment((int*) horiz0, (int*) vert0);

				size_t elements_returned0_0 = sizeof(horiz0)/sizeof(*horiz0);
				array_init(horiz0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(horiz0_ref, horiz0[i]);
				}
				size_t elements_returned0_1 = sizeof(vert0)/sizeof(*vert0);
				array_init(vert0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(vert0_ref, vert0[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetDefaultCellAlignment\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxGrid::GetDefaultCellBackgroundColour()
   Returns the current default background colour for grid cells. */
PHP_METHOD(php_wxGrid, GetDefaultCellBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetDefaultCellBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetDefaultCellBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetDefaultCellBackgroundColour() to return new object\n\n");
				#endif

				wxColour value_to_return0;
				value_to_return0 = ((wxGrid_php*)native_object)->GetDefaultCellBackgroundColour();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetDefaultCellBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxGrid::GetDefaultCellFont()
   Returns the current default font for grid cell text. */
PHP_METHOD(php_wxGrid, GetDefaultCellFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetDefaultCellFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetDefaultCellFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetDefaultCellFont() to return new object\n\n");
				#endif

				wxFont_php *value_to_return0;
				value_to_return0 = new wxFont_php(((wxGrid_php *) native_object)->GetDefaultCellFont());
				object_init_ex(return_value, php_wxFont_entry);
				zo_wxFont* zo0 = (zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = value_to_return0;
				zo0->is_user_initialized = 1;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetDefaultCellFont\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxGrid::GetDefaultCellTextColour()
   Returns the current default colour for grid cell text. */
PHP_METHOD(php_wxGrid, GetDefaultCellTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetDefaultCellTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetDefaultCellTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetDefaultCellTextColour() to return new object\n\n");
				#endif

				wxColour value_to_return0;
				value_to_return0 = ((wxGrid_php*)native_object)->GetDefaultCellTextColour();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetDefaultCellTextColour\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetDefaultColLabelSize()
   Returns the default height for column labels. */
PHP_METHOD(php_wxGrid, GetDefaultColLabelSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetDefaultColLabelSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetDefaultColLabelSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetDefaultColLabelSize())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetDefaultColLabelSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetDefaultColLabelSize\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetDefaultColSize()
   Returns the current default width for grid columns. */
PHP_METHOD(php_wxGrid, GetDefaultColSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetDefaultColSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetDefaultColSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetDefaultColSize())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetDefaultColSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetDefaultColSize\n");
	}
}
/* }}} */

/* {{{ proto wxGridCellEditor wxGrid::GetDefaultEditor()
   Returns a pointer to the current default grid cell editor. */
PHP_METHOD(php_wxGrid, GetDefaultEditor)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetDefaultEditor\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetDefaultEditor call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetDefaultEditor() to return object pointer\n\n");
				#endif

				wxGridCellEditor_php* value_to_return0;
				value_to_return0 = (wxGridCellEditor_php*) ((wxGrid_php*)native_object)->GetDefaultEditor();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxGridCellEditor_entry);
					((zo_wxGridCellEditor*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridCellEditor_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGrid::GetDefaultEditor at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetDefaultEditor\n");
	}
}
/* }}} */

/* {{{ proto wxGridCellEditor wxGrid::GetDefaultEditorForType(string typeName)
   Returns the default editor for the cells containing values of the given type. */
PHP_METHOD(php_wxGrid, GetDefaultEditorForType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetDefaultEditorForType\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetDefaultEditorForType call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* typeName0;
	long typeName_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&typeName0, &typeName_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &typeName0, &typeName_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetDefaultEditorForType(wxString(typeName0, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxGridCellEditor_php* value_to_return1;
				value_to_return1 = (wxGridCellEditor_php*) ((wxGrid_php*)native_object)->GetDefaultEditorForType(wxString(typeName0, wxConvUTF8));

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxGridCellEditor_entry);
					((zo_wxGridCellEditor*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridCellEditor_php*) value_to_return1;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return1 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGrid::GetDefaultEditorForType at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetDefaultEditorForType\n");
	}
}
/* }}} */

/* {{{ proto wxPen wxGrid::GetDefaultGridLinePen()
   Returns the pen used for grid lines. */
PHP_METHOD(php_wxGrid, GetDefaultGridLinePen)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetDefaultGridLinePen\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetDefaultGridLinePen call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetDefaultGridLinePen() to return new object\n\n");
				#endif

				wxPen value_to_return0;
				value_to_return0 = ((wxGrid_php*)native_object)->GetDefaultGridLinePen();
				void* ptr = safe_emalloc(1, sizeof(wxPen_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxPen));
				object_init_ex(return_value, php_wxPen_entry);
				((zo_wxPen*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPen_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetDefaultGridLinePen\n");
	}
}
/* }}} */

/* {{{ proto wxGridCellRenderer wxGrid::GetDefaultRenderer()
   Returns a pointer to the current default grid cell renderer. */
PHP_METHOD(php_wxGrid, GetDefaultRenderer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetDefaultRenderer\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetDefaultRenderer call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetDefaultRenderer() to return object pointer\n\n");
				#endif

				wxGridCellRenderer_php* value_to_return0;
				value_to_return0 = (wxGridCellRenderer_php*) ((wxGrid_php*)native_object)->GetDefaultRenderer();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxGridCellRenderer_entry);
					((zo_wxGridCellRenderer*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridCellRenderer_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGrid::GetDefaultRenderer at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetDefaultRenderer\n");
	}
}
/* }}} */

/* {{{ proto wxGridCellRenderer wxGrid::GetDefaultRendererForCell(int row, int col)
   Returns the default renderer for the given cell. */
PHP_METHOD(php_wxGrid, GetDefaultRendererForCell)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetDefaultRendererForCell\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetDefaultRendererForCell call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetDefaultRendererForCell((int) row0, (int) col0) to return object pointer\n\n");
				#endif

				wxGridCellRenderer_php* value_to_return2;
				value_to_return2 = (wxGridCellRenderer_php*) ((wxGrid_php*)native_object)->GetDefaultRendererForCell((int) row0, (int) col0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxGridCellRenderer_entry);
					((zo_wxGridCellRenderer*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridCellRenderer_php*) value_to_return2;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return2 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGrid::GetDefaultRendererForCell at call with 2 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetDefaultRendererForCell\n");
	}
}
/* }}} */

/* {{{ proto wxGridCellRenderer wxGrid::GetDefaultRendererForType(string typeName)
   Returns the default renderer for the cell containing values of the given type. */
PHP_METHOD(php_wxGrid, GetDefaultRendererForType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetDefaultRendererForType\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetDefaultRendererForType call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* typeName0;
	long typeName_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&typeName0, &typeName_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &typeName0, &typeName_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetDefaultRendererForType(wxString(typeName0, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxGridCellRenderer_php* value_to_return1;
				value_to_return1 = (wxGridCellRenderer_php*) ((wxGrid_php*)native_object)->GetDefaultRendererForType(wxString(typeName0, wxConvUTF8));

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxGridCellRenderer_entry);
					((zo_wxGridCellRenderer*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridCellRenderer_php*) value_to_return1;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return1 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGrid::GetDefaultRendererForType at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetDefaultRendererForType\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetDefaultRowLabelSize()
   Returns the default width for the row labels. */
PHP_METHOD(php_wxGrid, GetDefaultRowLabelSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetDefaultRowLabelSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetDefaultRowLabelSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetDefaultRowLabelSize())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetDefaultRowLabelSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetDefaultRowLabelSize\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetDefaultRowSize()
   Returns the current default height for grid rows. */
PHP_METHOD(php_wxGrid, GetDefaultRowSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetDefaultRowSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetDefaultRowSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetDefaultRowSize())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetDefaultRowSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetDefaultRowSize\n");
	}
}
/* }}} */

/* {{{ proto wxHeaderCtrl wxGrid::GetGridColHeader()
   Return the header control used for column labels display. */
PHP_METHOD(php_wxGrid, GetGridColHeader)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetGridColHeader\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetGridColHeader call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetGridColHeader() to return object pointer\n\n");
				#endif

				wxHeaderCtrl_php* value_to_return0;
				value_to_return0 = (wxHeaderCtrl_php*) ((wxGrid_php*)native_object)->GetGridColHeader();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxHeaderCtrl_entry);
					((zo_wxHeaderCtrl*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxHeaderCtrl_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGrid::GetGridColHeader at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetGridColHeader\n");
	}
}
/* }}} */

/* {{{ proto wxWindow wxGrid::GetGridColLabelWindow()
   Return the column labels window. */
PHP_METHOD(php_wxGrid, GetGridColLabelWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetGridColLabelWindow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetGridColLabelWindow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetGridColLabelWindow() to return object pointer\n\n");
				#endif

				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxGrid_php*)native_object)->GetGridColLabelWindow();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxWindow_entry);
					((zo_wxWindow*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxWindow_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGrid::GetGridColLabelWindow at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetGridColLabelWindow\n");
	}
}
/* }}} */

/* {{{ proto wxWindow wxGrid::GetGridCornerLabelWindow()
   Return the window in the top left grid corner. */
PHP_METHOD(php_wxGrid, GetGridCornerLabelWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetGridCornerLabelWindow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetGridCornerLabelWindow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetGridCornerLabelWindow() to return object pointer\n\n");
				#endif

				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxGrid_php*)native_object)->GetGridCornerLabelWindow();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxWindow_entry);
					((zo_wxWindow*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxWindow_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGrid::GetGridCornerLabelWindow at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetGridCornerLabelWindow\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetGridCursorCol()
   Returns the current grid cell column position. */
PHP_METHOD(php_wxGrid, GetGridCursorCol)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetGridCursorCol\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetGridCursorCol call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetGridCursorCol())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetGridCursorCol());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetGridCursorCol\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetGridCursorRow()
   Returns the current grid cell row position. */
PHP_METHOD(php_wxGrid, GetGridCursorRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetGridCursorRow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetGridCursorRow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetGridCursorRow())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetGridCursorRow());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetGridCursorRow\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxGrid::GetGridLineColour()
   Returns the colour used for grid lines. */
PHP_METHOD(php_wxGrid, GetGridLineColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetGridLineColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetGridLineColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetGridLineColour() to return new object\n\n");
				#endif

				wxColour value_to_return0;
				value_to_return0 = ((wxGrid_php*)native_object)->GetGridLineColour();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetGridLineColour\n");
	}
}
/* }}} */

/* {{{ proto wxWindow wxGrid::GetGridRowLabelWindow()
   Return the row labels window. */
PHP_METHOD(php_wxGrid, GetGridRowLabelWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetGridRowLabelWindow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetGridRowLabelWindow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetGridRowLabelWindow() to return object pointer\n\n");
				#endif

				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxGrid_php*)native_object)->GetGridRowLabelWindow();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxWindow_entry);
					((zo_wxWindow*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxWindow_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGrid::GetGridRowLabelWindow at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetGridRowLabelWindow\n");
	}
}
/* }}} */

/* {{{ proto wxWindow wxGrid::GetGridWindow()
   Return the main grid window containing the grid cells. */
PHP_METHOD(php_wxGrid, GetGridWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetGridWindow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetGridWindow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetGridWindow() to return object pointer\n\n");
				#endif

				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxGrid_php*)native_object)->GetGridWindow();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxWindow_entry);
					((zo_wxWindow*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxWindow_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGrid::GetGridWindow at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetGridWindow\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxGrid::GetLabelBackgroundColour()
   Returns the colour used for the background of row and column labels. */
PHP_METHOD(php_wxGrid, GetLabelBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetLabelBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetLabelBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetLabelBackgroundColour() to return new object\n\n");
				#endif

				wxColour value_to_return0;
				value_to_return0 = ((wxGrid_php*)native_object)->GetLabelBackgroundColour();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetLabelBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxGrid::GetLabelFont()
   Returns the font used for row and column labels. */
PHP_METHOD(php_wxGrid, GetLabelFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetLabelFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetLabelFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetLabelFont() to return new object\n\n");
				#endif

				wxFont_php *value_to_return0;
				value_to_return0 = new wxFont_php(((wxGrid_php *) native_object)->GetLabelFont());
				object_init_ex(return_value, php_wxFont_entry);
				zo_wxFont* zo0 = (zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = value_to_return0;
				zo0->is_user_initialized = 1;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetLabelFont\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxGrid::GetLabelTextColour()
   Returns the colour used for row and column label text. */
PHP_METHOD(php_wxGrid, GetLabelTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetLabelTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetLabelTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetLabelTextColour() to return new object\n\n");
				#endif

				wxColour value_to_return0;
				value_to_return0 = ((wxGrid_php*)native_object)->GetLabelTextColour();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetLabelTextColour\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetNumberCols()
   Returns the total number of grid columns. */
PHP_METHOD(php_wxGrid, GetNumberCols)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetNumberCols\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetNumberCols call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetNumberCols())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetNumberCols());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetNumberCols\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetNumberRows()
   Returns the total number of grid rows. */
PHP_METHOD(php_wxGrid, GetNumberRows)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetNumberRows\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetNumberRows call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetNumberRows())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetNumberRows());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetNumberRows\n");
	}
}
/* }}} */

/* {{{ proto wxGridCellAttr wxGrid::GetOrCreateCellAttr(int row, int col)
   Returns the attribute for the given cell creating one if necessary. */
PHP_METHOD(php_wxGrid, GetOrCreateCellAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetOrCreateCellAttr\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetOrCreateCellAttr call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetOrCreateCellAttr((int) row0, (int) col0) to return object pointer\n\n");
				#endif

				wxGridCellAttr_php* value_to_return2;
				value_to_return2 = (wxGridCellAttr_php*) ((wxGrid_php*)native_object)->GetOrCreateCellAttr((int) row0, (int) col0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxGridCellAttr_entry);
					((zo_wxGridCellAttr*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridCellAttr_php*) value_to_return2;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return2 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGrid::GetOrCreateCellAttr at call with 2 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetOrCreateCellAttr\n");
	}
}
/* }}} */

/* {{{ proto wxPen wxGrid::GetRowGridLinePen(int row)
   Returns the pen used for horizontal grid lines. */
PHP_METHOD(php_wxGrid, GetRowGridLinePen)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetRowGridLinePen\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetRowGridLinePen call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetRowGridLinePen((int) row0) to return new object\n\n");
				#endif

				wxPen value_to_return1;
				value_to_return1 = ((wxGrid_php*)native_object)->GetRowGridLinePen((int) row0);
				void* ptr = safe_emalloc(1, sizeof(wxPen_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxPen));
				object_init_ex(return_value, php_wxPen_entry);
				((zo_wxPen*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPen_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetRowGridLinePen\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::GetRowLabelAlignment(int &horiz, int &vert)
   Returns the alignment used for row labels. */
PHP_METHOD(php_wxGrid, GetRowLabelAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetRowLabelAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetRowLabelAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long* horiz0;
	zval* horiz0_ref;
	long* vert0;
	zval* vert0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (horiz0, vert0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, horiz0, vert0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &horiz0_ref, &vert0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetRowLabelAlignment((int*) horiz0, (int*) vert0)\n\n");
				#endif

				((wxGrid_php*)native_object)->GetRowLabelAlignment((int*) horiz0, (int*) vert0);

				size_t elements_returned0_0 = sizeof(horiz0)/sizeof(*horiz0);
				array_init(horiz0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(horiz0_ref, horiz0[i]);
				}
				size_t elements_returned0_1 = sizeof(vert0)/sizeof(*vert0);
				array_init(vert0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(vert0_ref, vert0[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetRowLabelAlignment\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetRowLabelSize()
   Returns the current width of the row labels. */
PHP_METHOD(php_wxGrid, GetRowLabelSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetRowLabelSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetRowLabelSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetRowLabelSize())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetRowLabelSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetRowLabelSize\n");
	}
}
/* }}} */

/* {{{ proto string wxGrid::GetRowLabelValue(int row)
   Returns the specified row label. */
PHP_METHOD(php_wxGrid, GetRowLabelValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetRowLabelValue\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetRowLabelValue call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxGrid::GetRowLabelValue((int) row0).fn_str(), 1)\n\n");
				#endif

				wxString value_to_return1;
				value_to_return1 = ((wxGrid_php*)native_object)->GetRowLabelValue((int) row0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetRowLabelValue\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetRowMinimalAcceptableHeight()
   Returns the minimal size to which rows can be resized. */
PHP_METHOD(php_wxGrid, GetRowMinimalAcceptableHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetRowMinimalAcceptableHeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetRowMinimalAcceptableHeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetRowMinimalAcceptableHeight())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetRowMinimalAcceptableHeight());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetRowMinimalAcceptableHeight\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetRowSize(int row)
   Returns the height of the specified row. */
PHP_METHOD(php_wxGrid, GetRowSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetRowSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetRowSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetRowSize((int) row0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetRowSize((int) row0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetRowSize\n");
	}
}
/* }}} */

/* {{{ proto wxGridSizesInfo wxGrid::GetRowSizes()
   Get size information for all row at once. */
PHP_METHOD(php_wxGrid, GetRowSizes)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetRowSizes\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetRowSizes call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetRowSizes() to return new object\n\n");
				#endif

				wxGridSizesInfo value_to_return0;
				value_to_return0 = ((wxGrid_php*)native_object)->GetRowSizes();
				void* ptr = safe_emalloc(1, sizeof(wxGridSizesInfo_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxGridSizesInfo));
				object_init_ex(return_value, php_wxGridSizesInfo_entry);
				((zo_wxGridSizesInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridSizesInfo_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetRowSizes\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetScrollLineX()
   Returns the number of pixels per horizontal scroll increment. */
PHP_METHOD(php_wxGrid, GetScrollLineX)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetScrollLineX\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetScrollLineX call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetScrollLineX())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetScrollLineX());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetScrollLineX\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetScrollLineY()
   Returns the number of pixels per vertical scroll increment. */
PHP_METHOD(php_wxGrid, GetScrollLineY)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetScrollLineY\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetScrollLineY call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetScrollLineY())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetScrollLineY());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetScrollLineY\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxGrid::GetSelectionBackground()
   Returns the colour used for drawing the selection background. */
PHP_METHOD(php_wxGrid, GetSelectionBackground)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetSelectionBackground\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetSelectionBackground call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetSelectionBackground() to return new object\n\n");
				#endif

				wxColour value_to_return0;
				value_to_return0 = ((wxGrid_php*)native_object)->GetSelectionBackground();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetSelectionBackground\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxGrid::GetSelectionForeground()
   Returns the colour used for drawing the selection foreground. */
PHP_METHOD(php_wxGrid, GetSelectionForeground)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetSelectionForeground\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetSelectionForeground call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetSelectionForeground() to return new object\n\n");
				#endif

				wxColour value_to_return0;
				value_to_return0 = ((wxGrid_php*)native_object)->GetSelectionForeground();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetSelectionForeground\n");
	}
}
/* }}} */

/* {{{ proto wxGridSelectionModes wxGrid::GetSelectionMode()
   Returns the current selection mode. */
PHP_METHOD(php_wxGrid, GetSelectionMode)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetSelectionMode\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetSelectionMode call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetSelectionMode())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetSelectionMode());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetSelectionMode\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::GetSortingColumn()
   Return the column in which the sorting indicator is currently displayed. */
PHP_METHOD(php_wxGrid, GetSortingColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetSortingColumn\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetSortingColumn call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::GetSortingColumn())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->GetSortingColumn());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetSortingColumn\n");
	}
}
/* }}} */

/* {{{ proto wxGridTableBase wxGrid::GetTable()
   Returns a base pointer to the current table object. */
PHP_METHOD(php_wxGrid, GetTable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GetTable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GetTable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GetTable() to return object pointer\n\n");
				#endif

				wxGridTableBase_php* value_to_return0;
				value_to_return0 = (wxGridTableBase_php*) ((wxGrid_php*)native_object)->GetTable();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxGridTableBase_entry);
					((zo_wxGridTableBase*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridTableBase_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGrid::GetTable at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GetTable\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::GoToCell(int row, int col)
   Make the given cell current and ensure it is visible. */
PHP_METHOD(php_wxGrid, GoToCell)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GoToCell\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GoToCell call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::GoToCell((int) row0, (int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->GoToCell((int) row0, (int) col0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GoToCell\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::GridLinesEnabled()
   Returns true if drawing of grid lines is turned on, false otherwise. */
PHP_METHOD(php_wxGrid, GridLinesEnabled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::GridLinesEnabled\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::GridLinesEnabled call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::GridLinesEnabled())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->GridLinesEnabled());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::GridLinesEnabled\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::HideCellEditControl()
   Hides the in-place cell edit control. */
PHP_METHOD(php_wxGrid, HideCellEditControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::HideCellEditControl\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::HideCellEditControl call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::HideCellEditControl()\n\n");
				#endif

				((wxGrid_php*)native_object)->HideCellEditControl();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::HideCellEditControl\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::HideCol(int col)
   Hides the specified column. */
PHP_METHOD(php_wxGrid, HideCol)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::HideCol\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::HideCol call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::HideCol((int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->HideCol((int) col0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::HideCol\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::HideColLabels()
   Hides the column labels by calling SetColLabelSize() with a size of 0. */
PHP_METHOD(php_wxGrid, HideColLabels)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::HideColLabels\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::HideColLabels call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::HideColLabels()\n\n");
				#endif

				((wxGrid_php*)native_object)->HideColLabels();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::HideColLabels\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::HideRow(int col)
   Hides the specified row. */
PHP_METHOD(php_wxGrid, HideRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::HideRow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::HideRow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::HideRow((int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->HideRow((int) col0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::HideRow\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::HideRowLabels()
   Hides the row labels by calling SetRowLabelSize() with a size of 0. */
PHP_METHOD(php_wxGrid, HideRowLabels)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::HideRowLabels\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::HideRowLabels call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::HideRowLabels()\n\n");
				#endif

				((wxGrid_php*)native_object)->HideRowLabels();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::HideRowLabels\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::InsertCols(int pos, int numCols, bool updateLabels)
   Inserts one or more new columns into a grid with the first new column at the specified position. */
PHP_METHOD(php_wxGrid, InsertCols)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::InsertCols\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::InsertCols call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	long numCols0;
	bool updateLabels0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|llb' (&pos0, &numCols0, &updateLabels0)\n");
		#endif

		char parse_parameters_string[] = "|llb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, &numCols0, &updateLabels0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::InsertCols())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->InsertCols());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::InsertCols((int) pos0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->InsertCols((int) pos0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::InsertCols((int) pos0, (int) numCols0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->InsertCols((int) pos0, (int) numCols0));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::InsertCols((int) pos0, (int) numCols0, updateLabels0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->InsertCols((int) pos0, (int) numCols0, updateLabels0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::InsertCols\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::InsertRows(int pos, int numRows, bool updateLabels)
   Inserts one or more new rows into a grid with the first new row at the specified position. */
PHP_METHOD(php_wxGrid, InsertRows)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::InsertRows\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::InsertRows call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pos0;
	long numRows0;
	bool updateLabels0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|llb' (&pos0, &numRows0, &updateLabels0)\n");
		#endif

		char parse_parameters_string[] = "|llb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0, &numRows0, &updateLabels0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::InsertRows())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->InsertRows());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::InsertRows((int) pos0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->InsertRows((int) pos0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::InsertRows((int) pos0, (int) numRows0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->InsertRows((int) pos0, (int) numRows0));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::InsertRows((int) pos0, (int) numRows0, updateLabels0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->InsertRows((int) pos0, (int) numRows0, updateLabels0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::InsertRows\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::IsCellEditControlEnabled()
   Returns true if the in-place edit control is currently enabled. */
PHP_METHOD(php_wxGrid, IsCellEditControlEnabled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::IsCellEditControlEnabled\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::IsCellEditControlEnabled call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::IsCellEditControlEnabled())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->IsCellEditControlEnabled());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::IsCellEditControlEnabled\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::IsCurrentCellReadOnly()
   Returns true if the current cell is read-only. */
PHP_METHOD(php_wxGrid, IsCurrentCellReadOnly)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::IsCurrentCellReadOnly\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::IsCurrentCellReadOnly call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::IsCurrentCellReadOnly())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->IsCurrentCellReadOnly());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::IsCurrentCellReadOnly\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::IsEditable()
   Returns false if the whole grid has been set as read-only or true otherwise. */
PHP_METHOD(php_wxGrid, IsEditable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::IsEditable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::IsEditable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::IsEditable())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->IsEditable());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::IsEditable\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::IsColShown(int col)
   Returns true if the specified column is not currently hidden. */
PHP_METHOD(php_wxGrid, IsColShown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::IsColShown\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::IsColShown call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::IsColShown((int) col0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->IsColShown((int) col0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::IsColShown\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::IsInSelection(int row, int col)
   Returns true if the given cell is selected. */
PHP_METHOD(php_wxGrid, IsInSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::IsInSelection\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::IsInSelection call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::IsInSelection((int) row0, (int) col0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->IsInSelection((int) row0, (int) col0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::IsInSelection\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::IsReadOnly(int row, int col)
   Returns true if the cell at the specified location can't be edited. */
PHP_METHOD(php_wxGrid, IsReadOnly)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::IsReadOnly\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::IsReadOnly call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::IsReadOnly((int) row0, (int) col0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->IsReadOnly((int) row0, (int) col0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::IsReadOnly\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::IsRowShown(int row)
   Returns true if the specified row is not currently hidden. */
PHP_METHOD(php_wxGrid, IsRowShown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::IsRowShown\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::IsRowShown call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::IsRowShown((int) row0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->IsRowShown((int) row0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::IsRowShown\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::IsSelection()
   Returns true if there are currently any selected cells, rows, columns or blocks. */
PHP_METHOD(php_wxGrid, IsSelection)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::IsSelection\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::IsSelection call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::IsSelection())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->IsSelection());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::IsSelection\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::IsSortOrderAscending()
   Return true if the current sorting order is ascending or false if it is descending. */
PHP_METHOD(php_wxGrid, IsSortOrderAscending)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::IsSortOrderAscending\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::IsSortOrderAscending call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::IsSortOrderAscending())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->IsSortOrderAscending());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::IsSortOrderAscending\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::IsSortingBy(int col)
   Return true if this column is currently used for sorting. */
PHP_METHOD(php_wxGrid, IsSortingBy)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::IsSortingBy\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::IsSortingBy call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::IsSortingBy((int) col0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->IsSortingBy((int) col0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::IsSortingBy\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::IsVisible(int row, int col, bool wholeCellVisible)
   Returns true if a cell is either entirely or at least partially visible in the grid window. */
PHP_METHOD(php_wxGrid, IsVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::IsVisible\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::IsVisible call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool wholeCellVisible0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll|b' (&row0, &col0, &wholeCellVisible0)\n");
		#endif

		char parse_parameters_string[] = "ll|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &wholeCellVisible0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::IsVisible((int) row0, (int) col0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->IsVisible((int) row0, (int) col0));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::IsVisible((int) row0, (int) col0, wholeCellVisible0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->IsVisible((int) row0, (int) col0, wholeCellVisible0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::IsVisible\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::MakeCellVisible(int row, int col)
   Brings the specified cell into the visible grid cell area with minimal scrolling. */
PHP_METHOD(php_wxGrid, MakeCellVisible)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::MakeCellVisible\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::MakeCellVisible call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::MakeCellVisible((int) row0, (int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->MakeCellVisible((int) row0, (int) col0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::MakeCellVisible\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::MoveCursorDown(bool expandSelection)
   Moves the grid cursor down by one row. */
PHP_METHOD(php_wxGrid, MoveCursorDown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::MoveCursorDown\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::MoveCursorDown call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool expandSelection0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&expandSelection0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &expandSelection0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::MoveCursorDown(expandSelection0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->MoveCursorDown(expandSelection0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::MoveCursorDown\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::MoveCursorDownBlock(bool expandSelection)
   Moves the grid cursor down in the current column such that it skips to the beginning or end of a block of non-empty cells. */
PHP_METHOD(php_wxGrid, MoveCursorDownBlock)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::MoveCursorDownBlock\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::MoveCursorDownBlock call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool expandSelection0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&expandSelection0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &expandSelection0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::MoveCursorDownBlock(expandSelection0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->MoveCursorDownBlock(expandSelection0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::MoveCursorDownBlock\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::MoveCursorLeft(bool expandSelection)
   Moves the grid cursor left by one column. */
PHP_METHOD(php_wxGrid, MoveCursorLeft)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::MoveCursorLeft\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::MoveCursorLeft call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool expandSelection0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&expandSelection0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &expandSelection0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::MoveCursorLeft(expandSelection0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->MoveCursorLeft(expandSelection0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::MoveCursorLeft\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::MoveCursorLeftBlock(bool expandSelection)
   Moves the grid cursor left in the current row such that it skips to the beginning or end of a block of non-empty cells. */
PHP_METHOD(php_wxGrid, MoveCursorLeftBlock)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::MoveCursorLeftBlock\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::MoveCursorLeftBlock call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool expandSelection0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&expandSelection0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &expandSelection0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::MoveCursorLeftBlock(expandSelection0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->MoveCursorLeftBlock(expandSelection0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::MoveCursorLeftBlock\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::MoveCursorRight(bool expandSelection)
   Moves the grid cursor right by one column. */
PHP_METHOD(php_wxGrid, MoveCursorRight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::MoveCursorRight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::MoveCursorRight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool expandSelection0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&expandSelection0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &expandSelection0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::MoveCursorRight(expandSelection0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->MoveCursorRight(expandSelection0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::MoveCursorRight\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::MoveCursorRightBlock(bool expandSelection)
   Moves the grid cursor right in the current row such that it skips to the beginning or end of a block of non-empty cells. */
PHP_METHOD(php_wxGrid, MoveCursorRightBlock)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::MoveCursorRightBlock\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::MoveCursorRightBlock call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool expandSelection0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&expandSelection0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &expandSelection0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::MoveCursorRightBlock(expandSelection0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->MoveCursorRightBlock(expandSelection0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::MoveCursorRightBlock\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::MoveCursorUp(bool expandSelection)
   Moves the grid cursor up by one row. */
PHP_METHOD(php_wxGrid, MoveCursorUp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::MoveCursorUp\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::MoveCursorUp call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool expandSelection0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&expandSelection0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &expandSelection0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::MoveCursorUp(expandSelection0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->MoveCursorUp(expandSelection0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::MoveCursorUp\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::MoveCursorUpBlock(bool expandSelection)
   Moves the grid cursor up in the current column such that it skips to the beginning or end of a block of non-empty cells. */
PHP_METHOD(php_wxGrid, MoveCursorUpBlock)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::MoveCursorUpBlock\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::MoveCursorUpBlock call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool expandSelection0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&expandSelection0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &expandSelection0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::MoveCursorUpBlock(expandSelection0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->MoveCursorUpBlock(expandSelection0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::MoveCursorUpBlock\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::MovePageDown()
   Moves the grid cursor down by some number of rows so that the previous bottom visible row becomes the top visible row. */
PHP_METHOD(php_wxGrid, MovePageDown)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::MovePageDown\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::MovePageDown call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::MovePageDown())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->MovePageDown());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::MovePageDown\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::MovePageUp()
   Moves the grid cursor up by some number of rows so that the previous top visible row becomes the bottom visible row. */
PHP_METHOD(php_wxGrid, MovePageUp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::MovePageUp\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::MovePageUp call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::MovePageUp())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->MovePageUp());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::MovePageUp\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::RefreshAttr(int row, int col)
   Invalidates the cached attribute for the given cell. */
PHP_METHOD(php_wxGrid, RefreshAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::RefreshAttr\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::RefreshAttr call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::RefreshAttr((int) row0, (int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->RefreshAttr((int) row0, (int) col0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::RefreshAttr\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::RegisterDataType(string typeName, wxGridCellRenderer &renderer, wxGridCellEditor &editor)
   Register a new data type. */
PHP_METHOD(php_wxGrid, RegisterDataType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::RegisterDataType\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::RegisterDataType call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* typeName0;
	long typeName_len0;
	zval* renderer0 = 0;
	wxGridCellRenderer* object_pointer0_1 = 0;
	zval* editor0 = 0;
	wxGridCellEditor* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'szz' (&typeName0, &typeName_len0, &renderer0, &editor0)\n");
		#endif

		char parse_parameters_string[] = "szz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &typeName0, &typeName_len0, &renderer0, &editor0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(renderer0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellRenderer*) zend_object_store_get_object(renderer0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellRenderer*) zend_object_store_get_object(renderer0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxGridCellRenderer*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXGRIDCELLRENDERER_TYPE && argument_type != PHP_WXGRIDCELLBOOLRENDERER_TYPE && argument_type != PHP_WXGRIDCELLSTRINGRENDERER_TYPE && argument_type != PHP_WXGRIDCELLDATETIMERENDERER_TYPE && argument_type != PHP_WXGRIDCELLAUTOWRAPSTRINGRENDERER_TYPE && argument_type != PHP_WXGRIDCELLENUMRENDERER_TYPE && argument_type != PHP_WXGRIDCELLFLOATRENDERER_TYPE && argument_type != PHP_WXGRIDCELLNUMBERRENDERER_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'renderer' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(renderer0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'renderer' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(editor0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellEditor*) zend_object_store_get_object(editor0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellEditor*) zend_object_store_get_object(editor0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxGridCellEditor*) argument_native_object;
					if (!object_pointer0_2 || (argument_type != PHP_WXGRIDCELLEDITOR_TYPE && argument_type != PHP_WXGRIDCELLBOOLEDITOR_TYPE && argument_type != PHP_WXGRIDCELLCHOICEEDITOR_TYPE && argument_type != PHP_WXGRIDCELLENUMEDITOR_TYPE && argument_type != PHP_WXGRIDCELLTEXTEDITOR_TYPE && argument_type != PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE && argument_type != PHP_WXGRIDCELLFLOATEDITOR_TYPE && argument_type != PHP_WXGRIDCELLNUMBEREDITOR_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'editor' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(editor0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'editor' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::RegisterDataType(wxString(typeName0, wxConvUTF8), (wxGridCellRenderer*) object_pointer0_1, (wxGridCellEditor*) object_pointer0_2)\n\n");
				#endif

				((wxGrid_php*)native_object)->RegisterDataType(wxString(typeName0, wxConvUTF8), (wxGridCellRenderer*) object_pointer0_1, (wxGridCellEditor*) object_pointer0_2);

				references->AddReference(renderer0, "wxGrid::RegisterDataType at call with 3 argument(s)");
				references->AddReference(editor0, "wxGrid::RegisterDataType at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::RegisterDataType\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::ResetColPos()
   Resets the position of the columns to the default. */
PHP_METHOD(php_wxGrid, ResetColPos)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::ResetColPos\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::ResetColPos call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::ResetColPos()\n\n");
				#endif

				((wxGrid_php*)native_object)->ResetColPos();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::ResetColPos\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SaveEditControlValue()
   Sets the value of the current grid cell to the current in-place edit control value. */
PHP_METHOD(php_wxGrid, SaveEditControlValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SaveEditControlValue\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SaveEditControlValue call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SaveEditControlValue()\n\n");
				#endif

				((wxGrid_php*)native_object)->SaveEditControlValue();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SaveEditControlValue\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SelectAll()
   Selects all cells in the grid. */
PHP_METHOD(php_wxGrid, SelectAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SelectAll\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SelectAll call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SelectAll()\n\n");
				#endif

				((wxGrid_php*)native_object)->SelectAll();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SelectAll\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SelectBlock(int topRow, int leftCol, int bottomRow, int rightCol, bool addToSelected)
   Selects a rectangular block of cells. */
PHP_METHOD(php_wxGrid, SelectBlock)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SelectBlock\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SelectBlock call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long topRow0;
	long leftCol0;
	long bottomRow0;
	long rightCol0;
	bool addToSelected0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 4  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll|b' (&topRow0, &leftCol0, &bottomRow0, &rightCol0, &addToSelected0)\n");
		#endif

		char parse_parameters_string[] = "llll|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &topRow0, &leftCol0, &bottomRow0, &rightCol0, &addToSelected0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SelectBlock((int) topRow0, (int) leftCol0, (int) bottomRow0, (int) rightCol0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SelectBlock((int) topRow0, (int) leftCol0, (int) bottomRow0, (int) rightCol0);


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SelectBlock((int) topRow0, (int) leftCol0, (int) bottomRow0, (int) rightCol0, addToSelected0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SelectBlock((int) topRow0, (int) leftCol0, (int) bottomRow0, (int) rightCol0, addToSelected0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SelectBlock\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SelectCol(int col, bool addToSelected)
   Selects the specified column. */
PHP_METHOD(php_wxGrid, SelectCol)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SelectCol\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SelectCol call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool addToSelected0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&col0, &addToSelected0)\n");
		#endif

		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &addToSelected0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SelectCol((int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SelectCol((int) col0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SelectCol((int) col0, addToSelected0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SelectCol((int) col0, addToSelected0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SelectCol\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SelectRow(int row, bool addToSelected)
   Selects the specified row. */
PHP_METHOD(php_wxGrid, SelectRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SelectRow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SelectRow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool addToSelected0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&row0, &addToSelected0)\n");
		#endif

		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &addToSelected0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SelectRow((int) row0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SelectRow((int) row0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SelectRow((int) row0, addToSelected0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SelectRow((int) row0, addToSelected0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SelectRow\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetCellAlignment(int row, int col, int horiz, int vert)
   Sets the horizontal and vertical alignment for grid cell text at the specified location. */
PHP_METHOD(php_wxGrid, SetCellAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetCellAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetCellAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	long horiz0;
	long vert0;
	bool overload0_called = false;
	//Parameters for overload 1
	long align1;
	long row1;
	long col1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll' (&row0, &col0, &horiz0, &vert0)\n");
		#endif

		char parse_parameters_string[] = "llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &horiz0, &vert0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&align1, &row1, &col1)\n");
		#endif

		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &align1, &row1, &col1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetCellAlignment((int) row0, (int) col0, (int) horiz0, (int) vert0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetCellAlignment((int) row0, (int) col0, (int) horiz0, (int) vert0);


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetCellAlignment((int) align1, (int) row1, (int) col1)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetCellAlignment((int) align1, (int) row1, (int) col1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetCellAlignment\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetCellBackgroundColour(int row, int col, wxColour colour)
   Set the background colour for the given cell or all cells by default. */
PHP_METHOD(php_wxGrid, SetCellBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetCellBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetCellBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	zval* colour0 = 0;
	wxColour* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llO' (&row0, &col0, &colour0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "llO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 3){
				if(Z_TYPE_P(colour0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxColour*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetCellBackgroundColour((int) row0, (int) col0, *(wxColour*) object_pointer0_2)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetCellBackgroundColour((int) row0, (int) col0, *(wxColour*) object_pointer0_2);

				references->AddReference(colour0, "wxGrid::SetCellBackgroundColour at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetCellBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetCellEditor(int row, int col, wxGridCellEditor &editor)
   Sets the editor for the grid cell at the specified location. */
PHP_METHOD(php_wxGrid, SetCellEditor)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetCellEditor\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetCellEditor call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	zval* editor0 = 0;
	wxGridCellEditor* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llz' (&row0, &col0, &editor0)\n");
		#endif

		char parse_parameters_string[] = "llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &editor0 ) == SUCCESS)
		{
			if(arguments_received >= 3){
				if(Z_TYPE_P(editor0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellEditor*) zend_object_store_get_object(editor0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellEditor*) zend_object_store_get_object(editor0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxGridCellEditor*) argument_native_object;
					if (!object_pointer0_2 || (argument_type != PHP_WXGRIDCELLEDITOR_TYPE && argument_type != PHP_WXGRIDCELLBOOLEDITOR_TYPE && argument_type != PHP_WXGRIDCELLCHOICEEDITOR_TYPE && argument_type != PHP_WXGRIDCELLENUMEDITOR_TYPE && argument_type != PHP_WXGRIDCELLTEXTEDITOR_TYPE && argument_type != PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE && argument_type != PHP_WXGRIDCELLFLOATEDITOR_TYPE && argument_type != PHP_WXGRIDCELLNUMBEREDITOR_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'editor' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(editor0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'editor' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetCellEditor((int) row0, (int) col0, (wxGridCellEditor*) object_pointer0_2)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetCellEditor((int) row0, (int) col0, (wxGridCellEditor*) object_pointer0_2);

				references->AddReference(editor0, "wxGrid::SetCellEditor at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetCellEditor\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetCellFont(int row, int col, wxFont font)
   Sets the font for text in the grid cell at the specified location. */
PHP_METHOD(php_wxGrid, SetCellFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetCellFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetCellFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	zval* font0 = 0;
	wxFont* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llO' (&row0, &col0, &font0, php_wxFont_entry)\n");
		#endif

		char parse_parameters_string[] = "llO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 3){
				if(Z_TYPE_P(font0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxFont*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetCellFont((int) row0, (int) col0, *(wxFont*) object_pointer0_2)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetCellFont((int) row0, (int) col0, *(wxFont*) object_pointer0_2);

				references->AddReference(font0, "wxGrid::SetCellFont at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetCellFont\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetCellRenderer(int row, int col, wxGridCellRenderer &renderer)
   Sets the renderer for the grid cell at the specified location. */
PHP_METHOD(php_wxGrid, SetCellRenderer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetCellRenderer\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetCellRenderer call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	zval* renderer0 = 0;
	wxGridCellRenderer* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llz' (&row0, &col0, &renderer0)\n");
		#endif

		char parse_parameters_string[] = "llz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &renderer0 ) == SUCCESS)
		{
			if(arguments_received >= 3){
				if(Z_TYPE_P(renderer0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellRenderer*) zend_object_store_get_object(renderer0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellRenderer*) zend_object_store_get_object(renderer0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxGridCellRenderer*) argument_native_object;
					if (!object_pointer0_2 || (argument_type != PHP_WXGRIDCELLRENDERER_TYPE && argument_type != PHP_WXGRIDCELLBOOLRENDERER_TYPE && argument_type != PHP_WXGRIDCELLSTRINGRENDERER_TYPE && argument_type != PHP_WXGRIDCELLDATETIMERENDERER_TYPE && argument_type != PHP_WXGRIDCELLAUTOWRAPSTRINGRENDERER_TYPE && argument_type != PHP_WXGRIDCELLENUMRENDERER_TYPE && argument_type != PHP_WXGRIDCELLFLOATRENDERER_TYPE && argument_type != PHP_WXGRIDCELLNUMBERRENDERER_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'renderer' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(renderer0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'renderer' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetCellRenderer((int) row0, (int) col0, (wxGridCellRenderer*) object_pointer0_2)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetCellRenderer((int) row0, (int) col0, (wxGridCellRenderer*) object_pointer0_2);

				references->AddReference(renderer0, "wxGrid::SetCellRenderer at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetCellRenderer\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetCellSize(int row, int col, int num_rows, int num_cols)
   Set the size of the cell. */
PHP_METHOD(php_wxGrid, SetCellSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetCellSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetCellSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	long num_rows0;
	long num_cols0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll' (&row0, &col0, &num_rows0, &num_cols0)\n");
		#endif

		char parse_parameters_string[] = "llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &num_rows0, &num_cols0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetCellSize((int) row0, (int) col0, (int) num_rows0, (int) num_cols0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetCellSize((int) row0, (int) col0, (int) num_rows0, (int) num_cols0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetCellSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetCellTextColour(int row, int col, wxColour colour)
   Sets the text colour for the given cell. */
PHP_METHOD(php_wxGrid, SetCellTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetCellTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetCellTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	zval* colour0 = 0;
	wxColour* object_pointer0_2 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* val1 = 0;
	wxColour* object_pointer1_0 = 0;
	long row1;
	long col1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* colour2 = 0;
	wxColour* object_pointer2_0 = 0;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llO' (&row0, &col0, &colour0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "llO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 3){
				if(Z_TYPE_P(colour0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxColour*) argument_native_object;
					if (!object_pointer0_2 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Oll' (&val1, php_wxColour_entry, &row1, &col1)\n");
		#endif

		char parse_parameters_string[] = "Oll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &val1, php_wxColour_entry, &row1, &col1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(val1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(val1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(val1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxColour*) argument_native_object;
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(val1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour2, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour2, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxColour*) argument_native_object;
					if (!object_pointer2_0 )
					{
						zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetCellTextColour((int) row0, (int) col0, *(wxColour*) object_pointer0_2)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetCellTextColour((int) row0, (int) col0, *(wxColour*) object_pointer0_2);

				references->AddReference(colour0, "wxGrid::SetCellTextColour at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetCellTextColour(*(wxColour*) object_pointer1_0, (int) row1, (int) col1)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetCellTextColour(*(wxColour*) object_pointer1_0, (int) row1, (int) col1);

				references->AddReference(val1, "wxGrid::SetCellTextColour at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetCellTextColour(*(wxColour*) object_pointer2_0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetCellTextColour(*(wxColour*) object_pointer2_0);

				references->AddReference(colour2, "wxGrid::SetCellTextColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetCellTextColour\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetCellValue(int row, int col, string s)
   Sets the string value for the cell at the specified location. */
PHP_METHOD(php_wxGrid, SetCellValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetCellValue\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetCellValue call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	char* s0;
	long s_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* val1;
	long val_len1;
	long row1;
	long col1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lls' (&row0, &col0, &s0, &s_len0)\n");
		#endif

		char parse_parameters_string[] = "lls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &s0, &s_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sll' (&val1, &val_len1, &row1, &col1)\n");
		#endif

		char parse_parameters_string[] = "sll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &val1, &val_len1, &row1, &col1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetCellValue((int) row0, (int) col0, wxString(s0, wxConvUTF8))\n\n");
				#endif

				((wxGrid_php*)native_object)->SetCellValue((int) row0, (int) col0, wxString(s0, wxConvUTF8));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetCellValue(wxString(val1, wxConvUTF8), (int) row1, (int) col1)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetCellValue(wxString(val1, wxConvUTF8), (int) row1, (int) col1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetCellValue\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetColAttr(int col, wxGridCellAttr &attr)
   Sets the cell attributes for all cells in the specified column. */
PHP_METHOD(php_wxGrid, SetColAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetColAttr\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetColAttr call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	zval* attr0 = 0;
	wxGridCellAttr* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lz' (&col0, &attr0)\n");
		#endif

		char parse_parameters_string[] = "lz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &attr0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(attr0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxGridCellAttr*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXGRIDCELLATTR_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'attr' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(attr0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'attr' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetColAttr((int) col0, (wxGridCellAttr*) object_pointer0_1)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetColAttr((int) col0, (wxGridCellAttr*) object_pointer0_1);

				references->AddReference(attr0, "wxGrid::SetColAttr at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetColAttr\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetColFormatBool(int col)
   Sets the specified column to display boolean values. */
PHP_METHOD(php_wxGrid, SetColFormatBool)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetColFormatBool\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetColFormatBool call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetColFormatBool((int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetColFormatBool((int) col0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetColFormatBool\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetColFormatCustom(int col, string typeName)
   Sets the specified column to display data in a custom format. */
PHP_METHOD(php_wxGrid, SetColFormatCustom)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetColFormatCustom\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetColFormatCustom call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	char* typeName0;
	long typeName_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&col0, &typeName0, &typeName_len0)\n");
		#endif

		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &typeName0, &typeName_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetColFormatCustom((int) col0, wxString(typeName0, wxConvUTF8))\n\n");
				#endif

				((wxGrid_php*)native_object)->SetColFormatCustom((int) col0, wxString(typeName0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetColFormatCustom\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetColFormatFloat(int col, int width, int precision)
   Sets the specified column to display floating point values with the given width and precision. */
PHP_METHOD(php_wxGrid, SetColFormatFloat)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetColFormatFloat\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetColFormatFloat call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	long width0;
	long precision0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|ll' (&col0, &width0, &precision0)\n");
		#endif

		char parse_parameters_string[] = "l|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &width0, &precision0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetColFormatFloat((int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetColFormatFloat((int) col0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetColFormatFloat((int) col0, (int) width0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetColFormatFloat((int) col0, (int) width0);


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetColFormatFloat((int) col0, (int) width0, (int) precision0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetColFormatFloat((int) col0, (int) width0, (int) precision0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetColFormatFloat\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetColFormatNumber(int col)
   Sets the specified column to display integer values. */
PHP_METHOD(php_wxGrid, SetColFormatNumber)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetColFormatNumber\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetColFormatNumber call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetColFormatNumber((int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetColFormatNumber((int) col0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetColFormatNumber\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetColLabelAlignment(int horiz, int vert)
   Sets the horizontal and vertical alignment of column label text. */
PHP_METHOD(php_wxGrid, SetColLabelAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetColLabelAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetColLabelAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long horiz0;
	long vert0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&horiz0, &vert0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &horiz0, &vert0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetColLabelAlignment((int) horiz0, (int) vert0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetColLabelAlignment((int) horiz0, (int) vert0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetColLabelAlignment\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetColLabelSize(int height)
   Sets the height of the column labels. */
PHP_METHOD(php_wxGrid, SetColLabelSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetColLabelSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetColLabelSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long height0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&height0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetColLabelSize((int) height0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetColLabelSize((int) height0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetColLabelSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetColLabelTextOrientation(int textOrientation)
   Sets the orientation of the column labels (either wxHORIZONTAL or wxVERTICAL). */
PHP_METHOD(php_wxGrid, SetColLabelTextOrientation)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetColLabelTextOrientation\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetColLabelTextOrientation call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long textOrientation0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&textOrientation0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &textOrientation0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetColLabelTextOrientation((int) textOrientation0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetColLabelTextOrientation((int) textOrientation0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetColLabelTextOrientation\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetColLabelValue(int col, string value)
   Set the value for the given column label. */
PHP_METHOD(php_wxGrid, SetColLabelValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetColLabelValue\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetColLabelValue call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	char* value0;
	long value_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&col0, &value0, &value_len0)\n");
		#endif

		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &value0, &value_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetColLabelValue((int) col0, wxString(value0, wxConvUTF8))\n\n");
				#endif

				((wxGrid_php*)native_object)->SetColLabelValue((int) col0, wxString(value0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetColLabelValue\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetColMinimalAcceptableWidth(int width)
   Sets the minimal width to which the user can resize columns. */
PHP_METHOD(php_wxGrid, SetColMinimalAcceptableWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetColMinimalAcceptableWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetColMinimalAcceptableWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetColMinimalAcceptableWidth((int) width0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetColMinimalAcceptableWidth((int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetColMinimalAcceptableWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetColMinimalWidth(int col, int width)
   Sets the minimal width for the specified column col. */
PHP_METHOD(php_wxGrid, SetColMinimalWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetColMinimalWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetColMinimalWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&col0, &width0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetColMinimalWidth((int) col0, (int) width0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetColMinimalWidth((int) col0, (int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetColMinimalWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetColPos(int colID, int newPos)
   Sets the position of the specified column. */
PHP_METHOD(php_wxGrid, SetColPos)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetColPos\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetColPos call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long colID0;
	long newPos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&colID0, &newPos0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colID0, &newPos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetColPos((int) colID0, (int) newPos0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetColPos((int) colID0, (int) newPos0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetColPos\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetColSize(int col, int width)
   Sets the width of the specified column. */
PHP_METHOD(php_wxGrid, SetColSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetColSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetColSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&col0, &width0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetColSize((int) col0, (int) width0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetColSize((int) col0, (int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetColSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetColSizes(wxGridSizesInfo sizeInfo)
   Restore all columns sizes. */
PHP_METHOD(php_wxGrid, SetColSizes)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetColSizes\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetColSizes call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* sizeInfo0 = 0;
	wxGridSizesInfo* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&sizeInfo0, php_wxGridSizesInfo_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &sizeInfo0, php_wxGridSizesInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(sizeInfo0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridSizesInfo*) zend_object_store_get_object(sizeInfo0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridSizesInfo*) zend_object_store_get_object(sizeInfo0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGridSizesInfo*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'sizeInfo' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(sizeInfo0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'sizeInfo' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetColSizes(*(wxGridSizesInfo*) object_pointer0_0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetColSizes(*(wxGridSizesInfo*) object_pointer0_0);

				references->AddReference(sizeInfo0, "wxGrid::SetColSizes at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetColSizes\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetDefaultCellAlignment(int horiz, int vert)
   Sets the default horizontal and vertical alignment for grid cell text. */
PHP_METHOD(php_wxGrid, SetDefaultCellAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetDefaultCellAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetDefaultCellAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long horiz0;
	long vert0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&horiz0, &vert0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &horiz0, &vert0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetDefaultCellAlignment((int) horiz0, (int) vert0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetDefaultCellAlignment((int) horiz0, (int) vert0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetDefaultCellAlignment\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetDefaultCellBackgroundColour(wxColour colour)
   Sets the default background colour for grid cells. */
PHP_METHOD(php_wxGrid, SetDefaultCellBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetDefaultCellBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetDefaultCellBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colour0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetDefaultCellBackgroundColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetDefaultCellBackgroundColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colour0, "wxGrid::SetDefaultCellBackgroundColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetDefaultCellBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetDefaultCellFont(wxFont font)
   Sets the default font to be used for grid cell text. */
PHP_METHOD(php_wxGrid, SetDefaultCellFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetDefaultCellFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetDefaultCellFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* font0 = 0;
	wxFont* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxFont*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetDefaultCellFont(*(wxFont*) object_pointer0_0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetDefaultCellFont(*(wxFont*) object_pointer0_0);

				references->AddReference(font0, "wxGrid::SetDefaultCellFont at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetDefaultCellFont\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetDefaultCellTextColour(wxColour colour)
   Sets the current default colour for grid cell text. */
PHP_METHOD(php_wxGrid, SetDefaultCellTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetDefaultCellTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetDefaultCellTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colour0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetDefaultCellTextColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetDefaultCellTextColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colour0, "wxGrid::SetDefaultCellTextColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetDefaultCellTextColour\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetDefaultColSize(int width, bool resizeExistingCols)
   Sets the default width for columns in the grid. */
PHP_METHOD(php_wxGrid, SetDefaultColSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetDefaultColSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetDefaultColSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	bool resizeExistingCols0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&width0, &resizeExistingCols0)\n");
		#endif

		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0, &resizeExistingCols0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetDefaultColSize((int) width0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetDefaultColSize((int) width0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetDefaultColSize((int) width0, resizeExistingCols0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetDefaultColSize((int) width0, resizeExistingCols0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetDefaultColSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetDefaultEditor(wxGridCellEditor &editor)
   Sets the default editor for grid cells. */
PHP_METHOD(php_wxGrid, SetDefaultEditor)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetDefaultEditor\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetDefaultEditor call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* editor0 = 0;
	wxGridCellEditor* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&editor0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &editor0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(editor0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellEditor*) zend_object_store_get_object(editor0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellEditor*) zend_object_store_get_object(editor0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGridCellEditor*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRIDCELLEDITOR_TYPE && argument_type != PHP_WXGRIDCELLBOOLEDITOR_TYPE && argument_type != PHP_WXGRIDCELLCHOICEEDITOR_TYPE && argument_type != PHP_WXGRIDCELLENUMEDITOR_TYPE && argument_type != PHP_WXGRIDCELLTEXTEDITOR_TYPE && argument_type != PHP_WXGRIDCELLAUTOWRAPSTRINGEDITOR_TYPE && argument_type != PHP_WXGRIDCELLFLOATEDITOR_TYPE && argument_type != PHP_WXGRIDCELLNUMBEREDITOR_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'editor' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(editor0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'editor' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetDefaultEditor((wxGridCellEditor*) object_pointer0_0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetDefaultEditor((wxGridCellEditor*) object_pointer0_0);

				references->AddReference(editor0, "wxGrid::SetDefaultEditor at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetDefaultEditor\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetDefaultRenderer(wxGridCellRenderer &renderer)
   Sets the default renderer for grid cells. */
PHP_METHOD(php_wxGrid, SetDefaultRenderer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetDefaultRenderer\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetDefaultRenderer call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* renderer0 = 0;
	wxGridCellRenderer* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&renderer0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &renderer0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(renderer0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellRenderer*) zend_object_store_get_object(renderer0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellRenderer*) zend_object_store_get_object(renderer0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGridCellRenderer*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRIDCELLRENDERER_TYPE && argument_type != PHP_WXGRIDCELLBOOLRENDERER_TYPE && argument_type != PHP_WXGRIDCELLSTRINGRENDERER_TYPE && argument_type != PHP_WXGRIDCELLDATETIMERENDERER_TYPE && argument_type != PHP_WXGRIDCELLAUTOWRAPSTRINGRENDERER_TYPE && argument_type != PHP_WXGRIDCELLENUMRENDERER_TYPE && argument_type != PHP_WXGRIDCELLFLOATRENDERER_TYPE && argument_type != PHP_WXGRIDCELLNUMBERRENDERER_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'renderer' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(renderer0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'renderer' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetDefaultRenderer((wxGridCellRenderer*) object_pointer0_0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetDefaultRenderer((wxGridCellRenderer*) object_pointer0_0);

				references->AddReference(renderer0, "wxGrid::SetDefaultRenderer at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetDefaultRenderer\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetDefaultRowSize(int height, bool resizeExistingRows)
   Sets the default height for rows in the grid. */
PHP_METHOD(php_wxGrid, SetDefaultRowSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetDefaultRowSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetDefaultRowSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long height0;
	bool resizeExistingRows0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&height0, &resizeExistingRows0)\n");
		#endif

		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &height0, &resizeExistingRows0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetDefaultRowSize((int) height0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetDefaultRowSize((int) height0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetDefaultRowSize((int) height0, resizeExistingRows0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetDefaultRowSize((int) height0, resizeExistingRows0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetDefaultRowSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetGridCursor(int row, int col)
   Set the grid cursor to the specified cell. */
PHP_METHOD(php_wxGrid, SetGridCursor)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetGridCursor\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetGridCursor call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetGridCursor((int) row0, (int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetGridCursor((int) row0, (int) col0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetGridCursor\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetGridLineColour(wxColour colour)
   Sets the colour used to draw grid lines. */
PHP_METHOD(php_wxGrid, SetGridLineColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetGridLineColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetGridLineColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colour0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetGridLineColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetGridLineColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colour0, "wxGrid::SetGridLineColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetGridLineColour\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetLabelBackgroundColour(wxColour colour)
   Sets the background colour for row and column labels. */
PHP_METHOD(php_wxGrid, SetLabelBackgroundColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetLabelBackgroundColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetLabelBackgroundColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colour0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetLabelBackgroundColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetLabelBackgroundColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colour0, "wxGrid::SetLabelBackgroundColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetLabelBackgroundColour\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetLabelFont(wxFont font)
   Sets the font for row and column labels. */
PHP_METHOD(php_wxGrid, SetLabelFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetLabelFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetLabelFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* font0 = 0;
	wxFont* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxFont*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetLabelFont(*(wxFont*) object_pointer0_0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetLabelFont(*(wxFont*) object_pointer0_0);

				references->AddReference(font0, "wxGrid::SetLabelFont at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetLabelFont\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetLabelTextColour(wxColour colour)
   Sets the colour for row and column label text. */
PHP_METHOD(php_wxGrid, SetLabelTextColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetLabelTextColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetLabelTextColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colour0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetLabelTextColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetLabelTextColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colour0, "wxGrid::SetLabelTextColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetLabelTextColour\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetMargins(int extraWidth, int extraHeight)
   Sets the extra margins used around the grid area. */
PHP_METHOD(php_wxGrid, SetMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetMargins\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetMargins call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long extraWidth0;
	long extraHeight0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&extraWidth0, &extraHeight0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &extraWidth0, &extraHeight0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetMargins((int) extraWidth0, (int) extraHeight0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetMargins((int) extraWidth0, (int) extraHeight0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetMargins\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetReadOnly(int row, int col, bool isReadOnly)
   Makes the cell at the specified location read-only or editable. */
PHP_METHOD(php_wxGrid, SetReadOnly)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetReadOnly\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetReadOnly call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	bool isReadOnly0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll|b' (&row0, &col0, &isReadOnly0)\n");
		#endif

		char parse_parameters_string[] = "ll|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &isReadOnly0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetReadOnly((int) row0, (int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetReadOnly((int) row0, (int) col0);


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetReadOnly((int) row0, (int) col0, isReadOnly0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetReadOnly((int) row0, (int) col0, isReadOnly0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetReadOnly\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetRowAttr(int row, wxGridCellAttr &attr)
   Sets the cell attributes for all cells in the specified row. */
PHP_METHOD(php_wxGrid, SetRowAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetRowAttr\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetRowAttr call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	zval* attr0 = 0;
	wxGridCellAttr* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lz' (&row0, &attr0)\n");
		#endif

		char parse_parameters_string[] = "lz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &attr0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(attr0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxGridCellAttr*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXGRIDCELLATTR_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'attr' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(attr0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'attr' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetRowAttr((int) row0, (wxGridCellAttr*) object_pointer0_1)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetRowAttr((int) row0, (wxGridCellAttr*) object_pointer0_1);

				references->AddReference(attr0, "wxGrid::SetRowAttr at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetRowAttr\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetRowLabelAlignment(int horiz, int vert)
   Sets the horizontal and vertical alignment of row label text. */
PHP_METHOD(php_wxGrid, SetRowLabelAlignment)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetRowLabelAlignment\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetRowLabelAlignment call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long horiz0;
	long vert0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&horiz0, &vert0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &horiz0, &vert0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetRowLabelAlignment((int) horiz0, (int) vert0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetRowLabelAlignment((int) horiz0, (int) vert0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetRowLabelAlignment\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetRowLabelSize(int width)
   Sets the width of the row labels. */
PHP_METHOD(php_wxGrid, SetRowLabelSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetRowLabelSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetRowLabelSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetRowLabelSize((int) width0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetRowLabelSize((int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetRowLabelSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetRowLabelValue(int row, string value)
   Sets the value for the given row label. */
PHP_METHOD(php_wxGrid, SetRowLabelValue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetRowLabelValue\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetRowLabelValue call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	char* value0;
	long value_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ls' (&row0, &value0, &value_len0)\n");
		#endif

		char parse_parameters_string[] = "ls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &value0, &value_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetRowLabelValue((int) row0, wxString(value0, wxConvUTF8))\n\n");
				#endif

				((wxGrid_php*)native_object)->SetRowLabelValue((int) row0, wxString(value0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetRowLabelValue\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetRowMinimalAcceptableHeight(int height)
   Sets the minimal row height used by default. */
PHP_METHOD(php_wxGrid, SetRowMinimalAcceptableHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetRowMinimalAcceptableHeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetRowMinimalAcceptableHeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long height0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&height0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetRowMinimalAcceptableHeight((int) height0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetRowMinimalAcceptableHeight((int) height0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetRowMinimalAcceptableHeight\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetRowMinimalHeight(int row, int height)
   Sets the minimal height for the specified row. */
PHP_METHOD(php_wxGrid, SetRowMinimalHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetRowMinimalHeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetRowMinimalHeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long height0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &height0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetRowMinimalHeight((int) row0, (int) height0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetRowMinimalHeight((int) row0, (int) height0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetRowMinimalHeight\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetRowSize(int row, int height)
   Sets the height of the specified row. */
PHP_METHOD(php_wxGrid, SetRowSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetRowSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetRowSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long height0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&row0, &height0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetRowSize((int) row0, (int) height0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetRowSize((int) row0, (int) height0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetRowSize\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetRowSizes(wxGridSizesInfo sizeInfo)
   Restore all rows sizes. */
PHP_METHOD(php_wxGrid, SetRowSizes)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetRowSizes\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetRowSizes call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* sizeInfo0 = 0;
	wxGridSizesInfo* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&sizeInfo0, php_wxGridSizesInfo_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &sizeInfo0, php_wxGridSizesInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(sizeInfo0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridSizesInfo*) zend_object_store_get_object(sizeInfo0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridSizesInfo*) zend_object_store_get_object(sizeInfo0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGridSizesInfo*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'sizeInfo' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(sizeInfo0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'sizeInfo' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetRowSizes(*(wxGridSizesInfo*) object_pointer0_0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetRowSizes(*(wxGridSizesInfo*) object_pointer0_0);

				references->AddReference(sizeInfo0, "wxGrid::SetRowSizes at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetRowSizes\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetScrollLineX(int x)
   Sets the number of pixels per horizontal scroll increment. */
PHP_METHOD(php_wxGrid, SetScrollLineX)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetScrollLineX\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetScrollLineX call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&x0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetScrollLineX((int) x0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetScrollLineX((int) x0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetScrollLineX\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetScrollLineY(int y)
   Sets the number of pixels per vertical scroll increment. */
PHP_METHOD(php_wxGrid, SetScrollLineY)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetScrollLineY\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetScrollLineY call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long y0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&y0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetScrollLineY((int) y0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetScrollLineY((int) y0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetScrollLineY\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetSelectionBackground(wxColour c)
   Set the colour to be used for drawing the selection background. */
PHP_METHOD(php_wxGrid, SetSelectionBackground)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetSelectionBackground\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetSelectionBackground call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* c0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&c0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &c0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(c0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(c0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(c0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'c' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(c0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'c' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetSelectionBackground(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetSelectionBackground(*(wxColour*) object_pointer0_0);

				references->AddReference(c0, "wxGrid::SetSelectionBackground at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetSelectionBackground\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetSelectionForeground(wxColour c)
   Set the colour to be used for drawing the selection foreground. */
PHP_METHOD(php_wxGrid, SetSelectionForeground)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetSelectionForeground\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetSelectionForeground call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* c0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&c0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &c0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(c0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(c0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(c0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'c' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(c0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'c' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetSelectionForeground(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetSelectionForeground(*(wxColour*) object_pointer0_0);

				references->AddReference(c0, "wxGrid::SetSelectionForeground at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetSelectionForeground\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetSelectionMode(wxGridSelectionModes selmode)
   Set the selection behaviour of the grid. */
PHP_METHOD(php_wxGrid, SetSelectionMode)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetSelectionMode\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetSelectionMode call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long selmode0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&selmode0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &selmode0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetSelectionMode((wxGrid::wxGridSelectionModes) selmode0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetSelectionMode((wxGrid::wxGridSelectionModes) selmode0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetSelectionMode\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetSortingColumn(int col, bool ascending)
   Set the column to display the sorting indicator in and its direction. */
PHP_METHOD(php_wxGrid, SetSortingColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetSortingColumn\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetSortingColumn call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool ascending0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&col0, &ascending0)\n");
		#endif

		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, &ascending0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetSortingColumn((int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetSortingColumn((int) col0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetSortingColumn((int) col0, ascending0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetSortingColumn((int) col0, ascending0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetSortingColumn\n");
	}
}
/* }}} */

/* {{{ proto bool wxGrid::SetTable(wxGridTableBase &table, bool takeOwnership, wxGridSelectionModes selmode)
   Passes a pointer to a custom grid table to be used by the grid. */
PHP_METHOD(php_wxGrid, SetTable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetTable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetTable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* table0 = 0;
	wxGridTableBase* object_pointer0_0 = 0;
	bool takeOwnership0;
	long selmode0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z|bl' (&table0, &takeOwnership0, &selmode0)\n");
		#endif

		char parse_parameters_string[] = "z|bl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &table0, &takeOwnership0, &selmode0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(table0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridTableBase*) zend_object_store_get_object(table0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridTableBase*) zend_object_store_get_object(table0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGridTableBase*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRIDTABLEBASE_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'table' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(table0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'table' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::SetTable((wxGridTableBase*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->SetTable((wxGridTableBase*) object_pointer0_0));

				references->AddReference(table0, "wxGrid::SetTable at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::SetTable((wxGridTableBase*) object_pointer0_0, takeOwnership0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->SetTable((wxGridTableBase*) object_pointer0_0, takeOwnership0));

				references->AddReference(table0, "wxGrid::SetTable at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxGrid::SetTable((wxGridTableBase*) object_pointer0_0, takeOwnership0, (wxGrid::wxGridSelectionModes) selmode0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxGrid_php*)native_object)->SetTable((wxGridTableBase*) object_pointer0_0, takeOwnership0, (wxGrid::wxGridSelectionModes) selmode0));

				references->AddReference(table0, "wxGrid::SetTable at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetTable\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::SetUseNativeColLabels(bool native)
   Call this in order to make the column labels use a native look by using wxRendererNative::DrawHeaderButton() internally. */
PHP_METHOD(php_wxGrid, SetUseNativeColLabels)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::SetUseNativeColLabels\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::SetUseNativeColLabels call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool native0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&native0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &native0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetUseNativeColLabels()\n\n");
				#endif

				((wxGrid_php*)native_object)->SetUseNativeColLabels();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::SetUseNativeColLabels(native0)\n\n");
				#endif

				((wxGrid_php*)native_object)->SetUseNativeColLabels(native0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::SetUseNativeColLabels\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::ShowCellEditControl()
   Displays the in-place cell edit control for the current cell. */
PHP_METHOD(php_wxGrid, ShowCellEditControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::ShowCellEditControl\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::ShowCellEditControl call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::ShowCellEditControl()\n\n");
				#endif

				((wxGrid_php*)native_object)->ShowCellEditControl();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::ShowCellEditControl\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::ShowCol(int col)
   Shows the previously hidden column by resizing it to non-0 size. */
PHP_METHOD(php_wxGrid, ShowCol)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::ShowCol\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::ShowCol call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::ShowCol((int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->ShowCol((int) col0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::ShowCol\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::ShowRow(int col)
   Shows the previously hidden row by resizing it to non-0 size. */
PHP_METHOD(php_wxGrid, ShowRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::ShowRow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::ShowRow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::ShowRow((int) col0)\n\n");
				#endif

				((wxGrid_php*)native_object)->ShowRow((int) col0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::ShowRow\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::UnsetSortingColumn()
   Remove any currently shown sorting indicator. */
PHP_METHOD(php_wxGrid, UnsetSortingColumn)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::UnsetSortingColumn\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::UnsetSortingColumn call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::UnsetSortingColumn()\n\n");
				#endif

				((wxGrid_php*)native_object)->UnsetSortingColumn();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::UnsetSortingColumn\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::UseNativeColHeader(bool native)
   Enable the use of native header window for column labels. */
PHP_METHOD(php_wxGrid, UseNativeColHeader)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::UseNativeColHeader\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::UseNativeColHeader call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool native0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&native0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &native0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::UseNativeColHeader()\n\n");
				#endif

				((wxGrid_php*)native_object)->UseNativeColHeader();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGrid::UseNativeColHeader(native0)\n\n");
				#endif

				((wxGrid_php*)native_object)->UseNativeColHeader(native0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::UseNativeColHeader\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::XToCol(int x, bool clipToMinMax)
   Returns the column at the given pixel position. */
PHP_METHOD(php_wxGrid, XToCol)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::XToCol\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::XToCol call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	bool clipToMinMax0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&x0, &clipToMinMax0)\n");
		#endif

		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &clipToMinMax0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::XToCol((int) x0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->XToCol((int) x0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::XToCol((int) x0, clipToMinMax0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->XToCol((int) x0, clipToMinMax0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::XToCol\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::XToEdgeOfCol(int x)
   Returns the column whose right hand edge is close to the given logical x position. */
PHP_METHOD(php_wxGrid, XToEdgeOfCol)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::XToEdgeOfCol\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::XToEdgeOfCol call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&x0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::XToEdgeOfCol((int) x0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->XToEdgeOfCol((int) x0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::XToEdgeOfCol\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::YToEdgeOfRow(int y)
   Returns the row whose bottom edge is close to the given logical y position. */
PHP_METHOD(php_wxGrid, YToEdgeOfRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::YToEdgeOfRow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::YToEdgeOfRow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long y0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&y0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::YToEdgeOfRow((int) y0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->YToEdgeOfRow((int) y0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::YToEdgeOfRow\n");
	}
}
/* }}} */

/* {{{ proto int wxGrid::YToRow(int y, bool clipToMinMax)
   Returns the grid row that corresponds to the logical y coordinate. */
PHP_METHOD(php_wxGrid, YToRow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::YToRow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxphp_object_type current_object_type;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGrid::YToRow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRID_TYPE){
				references = &((wxGrid_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long y0;
	bool clipToMinMax0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&y0, &clipToMinMax0)\n");
		#endif

		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &y0, &clipToMinMax0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::YToRow((int) y0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->YToRow((int) y0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGrid::YToRow((int) y0, clipToMinMax0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGrid_php*)native_object)->YToRow((int) y0, clipToMinMax0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGrid::YToRow\n");
	}
}
/* }}} */

/* {{{ proto  wxGrid::wxGrid()
   Default constructor. */
PHP_METHOD(php_wxGrid, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGrid::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGrid* current_object;
	wxGrid_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* parent1 = 0;
	wxWindow* object_pointer1_0 = 0;
	long id1;
	zval* pos1 = 0;
	wxPoint* object_pointer1_2 = 0;
	zval* size1 = 0;
	wxSize* object_pointer1_3 = 0;
	long style1;
	char* name1;
	long name_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl|OOls' (&parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1)\n");
		#endif

		char parse_parameters_string[] = "zl|OOls";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &parent1, &id1, &pos1, php_wxPoint_entry, &size1, php_wxSize_entry, &style1, &name1, &name_len1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(parent1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(parent1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(parent1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxWindow*) argument_native_object;
					if (!object_pointer1_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXPAGESETUPDIALOG_TYPE && argument_type != PHP_WXPRINTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'parent' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'parent' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(pos1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pos1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pos1 TSRMLS_CC))->native_object;
					object_pointer1_2 = (wxPoint*) argument_native_object;
					if (!object_pointer1_2 )
					{
						zend_error(E_ERROR, "Parameter 'pos' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pos' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(size1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size1 TSRMLS_CC))->native_object;
					object_pointer1_3 = (wxSize*) argument_native_object;
					if (!object_pointer1_3 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGrid_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1)\n");
				#endif

				native_object = new wxGrid_php((wxWindow*) object_pointer1_0, (wxWindowID) id1);

				native_object->references.Initialize();
				((wxGrid_php*) native_object)->references.AddReference(parent1, "wxGrid::wxGrid at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2)\n");
				#endif

				native_object = new wxGrid_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2);

				native_object->references.Initialize();
				((wxGrid_php*) native_object)->references.AddReference(parent1, "wxGrid::wxGrid at call with 3 argument(s)");
				((wxGrid_php*) native_object)->references.AddReference(pos1, "wxGrid::wxGrid at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3)\n");
				#endif

				native_object = new wxGrid_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3);

				native_object->references.Initialize();
				((wxGrid_php*) native_object)->references.AddReference(parent1, "wxGrid::wxGrid at call with 4 argument(s)");
				((wxGrid_php*) native_object)->references.AddReference(pos1, "wxGrid::wxGrid at call with 4 argument(s)");
				((wxGrid_php*) native_object)->references.AddReference(size1, "wxGrid::wxGrid at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1)\n");
				#endif

				native_object = new wxGrid_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1);

				native_object->references.Initialize();
				((wxGrid_php*) native_object)->references.AddReference(parent1, "wxGrid::wxGrid at call with 5 argument(s)");
				((wxGrid_php*) native_object)->references.AddReference(pos1, "wxGrid::wxGrid at call with 5 argument(s)");
				((wxGrid_php*) native_object)->references.AddReference(size1, "wxGrid::wxGrid at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8))\n");
				#endif

				native_object = new wxGrid_php((wxWindow*) object_pointer1_0, (wxWindowID) id1, *(wxPoint*) object_pointer1_2, *(wxSize*) object_pointer1_3, (long) style1, wxString(name1, wxConvUTF8));

				native_object->references.Initialize();
				((wxGrid_php*) native_object)->references.AddReference(parent1, "wxGrid::wxGrid at call with 6 argument(s)");
				((wxGrid_php*) native_object)->references.AddReference(pos1, "wxGrid::wxGrid at call with 6 argument(s)");
				((wxGrid_php*) native_object)->references.AddReference(size1, "wxGrid::wxGrid at call with 6 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGrid*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGrid::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridUpdateLocker_free(void *object TSRMLS_DC) 
{
    zo_wxGridUpdateLocker* custom_object = (zo_wxGridUpdateLocker*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridUpdateLocker_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridUpdateLocker done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridUpdateLocker_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridUpdateLocker_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridUpdateLocker* custom_object;
    custom_object = (zo_wxGridUpdateLocker*) emalloc(sizeof(zo_wxGridUpdateLocker));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDUPDATELOCKER_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridUpdateLocker_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridUpdateLocker::Create(wxGrid &grid)
   This method can be called if the object had been constructed using the default constructor. */
PHP_METHOD(php_wxGridUpdateLocker, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridUpdateLocker::Create\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridUpdateLocker* current_object;
	wxphp_object_type current_object_type;
	wxGridUpdateLocker_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridUpdateLocker*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridUpdateLocker::Create call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDUPDATELOCKER_TYPE){
				references = &((wxGridUpdateLocker_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* grid0 = 0;
	wxGrid* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&grid0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &grid0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(grid0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGrid*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRID_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'grid' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(grid0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'grid' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridUpdateLocker::Create((wxGrid*) object_pointer0_0)\n\n");
				#endif

				((wxGridUpdateLocker_php*)native_object)->Create((wxGrid*) object_pointer0_0);

				references->AddReference(grid0, "wxGridUpdateLocker::Create at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridUpdateLocker::Create\n");
	}
}
/* }}} */

/* {{{ proto  wxGridUpdateLocker::wxGridUpdateLocker(wxGrid &grid)
   Creates an object preventing the updates of the specified grid. */
PHP_METHOD(php_wxGridUpdateLocker, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridUpdateLocker::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridUpdateLocker* current_object;
	wxGridUpdateLocker_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* grid0 = 0;
	wxGrid* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|z' (&grid0)\n");
		#endif

		char parse_parameters_string[] = "|z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &grid0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(grid0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGrid*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRID_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'grid' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(grid0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'grid' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridUpdateLocker_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxGrid*) object_pointer0_0)\n");
				#endif

				native_object = new wxGridUpdateLocker_php((wxGrid*) object_pointer0_0);

				native_object->references.Initialize();
				((wxGridUpdateLocker_php*) native_object)->references.AddReference(grid0, "wxGridUpdateLocker::wxGridUpdateLocker at call with 1 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridUpdateLocker*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridUpdateLocker::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

