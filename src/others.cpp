/*
 * @author Mário Soares
 * @contributors Jefferson González
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "cfg.h"
#include "bookctrl.h"
#include "dnd.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "docview.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "html.h"
#include "help.h"
#include "logging.h"
#include "managedwnd.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "media.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "webview.h"
#include "aui.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "dvc.h"
#include "others.h"


BEGIN_EXTERN_C()
void php_wxScrolledWindow_free(void *object TSRMLS_DC) 
{
    zo_wxScrolledWindow* custom_object = (zo_wxScrolledWindow*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate delete call for wxScrolledWindow on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxScrolledWindow_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxScrolledWindow_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxScrolledWindow* custom_object;
    custom_object = (zo_wxScrolledWindow*) emalloc(sizeof(zo_wxScrolledWindow));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXSCROLLEDWINDOW_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxScrolledWindow_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxRibbonButtonBarButtonBase_free(void *object TSRMLS_DC) 
{
    zo_wxRibbonButtonBarButtonBase* custom_object = (zo_wxRibbonButtonBarButtonBase*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxRibbonButtonBarButtonBase_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxRibbonButtonBarButtonBase done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxRibbonButtonBarButtonBase_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxRibbonButtonBarButtonBase_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxRibbonButtonBarButtonBase* custom_object;
    custom_object = (zo_wxRibbonButtonBarButtonBase*) emalloc(sizeof(zo_wxRibbonButtonBarButtonBase));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXRIBBONBUTTONBARBUTTONBASE_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxRibbonButtonBarButtonBase_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxRibbonGalleryItem_free(void *object TSRMLS_DC) 
{
    zo_wxRibbonGalleryItem* custom_object = (zo_wxRibbonGalleryItem*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxRibbonGalleryItem_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxRibbonGalleryItem done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxRibbonGalleryItem_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxRibbonGalleryItem_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxRibbonGalleryItem* custom_object;
    custom_object = (zo_wxRibbonGalleryItem*) emalloc(sizeof(zo_wxRibbonGalleryItem));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXRIBBONGALLERYITEM_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxRibbonGalleryItem_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxRibbonToolBarToolBase_free(void *object TSRMLS_DC) 
{
    zo_wxRibbonToolBarToolBase* custom_object = (zo_wxRibbonToolBarToolBase*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxRibbonToolBarToolBase_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxRibbonToolBarToolBase done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxRibbonToolBarToolBase_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxRibbonToolBarToolBase_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxRibbonToolBarToolBase* custom_object;
    custom_object = (zo_wxRibbonToolBarToolBase*) emalloc(sizeof(zo_wxRibbonToolBarToolBase));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXRIBBONTOOLBARTOOLBASE_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxRibbonToolBarToolBase_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxNonOwnedWindow_free(void *object TSRMLS_DC) 
{
    zo_wxNonOwnedWindow* custom_object = (zo_wxNonOwnedWindow*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxNonOwnedWindow_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
	
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting object by calling destroy and delete\n");
			#endif
			
			custom_object->native_object->Destroy();
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxNonOwnedWindow done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxNonOwnedWindow_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxNonOwnedWindow_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxNonOwnedWindow* custom_object;
    custom_object = (zo_wxNonOwnedWindow*) emalloc(sizeof(zo_wxNonOwnedWindow));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXNONOWNEDWINDOW_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxNonOwnedWindow_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxAnyButton_free(void *object TSRMLS_DC) 
{
    zo_wxAnyButton* custom_object = (zo_wxAnyButton*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Obviate delete call for wxAnyButton on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n\n");
	#endif

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxAnyButton_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAnyButton_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxAnyButton* custom_object;
    custom_object = (zo_wxAnyButton*) emalloc(sizeof(zo_wxAnyButton));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXANYBUTTON_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxAnyButton_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxAnyButton::wxAnyButton() */
PHP_METHOD(php_wxAnyButton, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnyButton::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnyButton* current_object;
	wxAnyButton_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxAnyButton_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxAnyButton*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxAnyButton::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto wxBitmap wxAnyButton::GetBitmap()
   Return the bitmap shown by the button. */
PHP_METHOD(php_wxAnyButton, GetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnyButton::GetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnyButton* current_object;
	wxphp_object_type current_object_type;
	wxAnyButton_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnyButton*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnyButton::GetBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANYBUTTON_TYPE){
				references = &((wxAnyButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::GetBitmap() to return new object\n\n");
				#endif

				wxBitmap value_to_return0;
				value_to_return0 = ((wxAnyButton_php*)native_object)->GetBitmap();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				((zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmap_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnyButton::GetBitmap\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxAnyButton::GetBitmapCurrent()
   Returns the bitmap used when the mouse is over the button, which may be invalid. */
PHP_METHOD(php_wxAnyButton, GetBitmapCurrent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnyButton::GetBitmapCurrent\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnyButton* current_object;
	wxphp_object_type current_object_type;
	wxAnyButton_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnyButton*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnyButton::GetBitmapCurrent call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANYBUTTON_TYPE){
				references = &((wxAnyButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::GetBitmapCurrent() to return new object\n\n");
				#endif

				wxBitmap value_to_return0;
				value_to_return0 = ((wxAnyButton_php*)native_object)->GetBitmapCurrent();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				((zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmap_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnyButton::GetBitmapCurrent\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxAnyButton::GetBitmapDisabled()
   Returns the bitmap for the disabled state, which may be invalid. */
PHP_METHOD(php_wxAnyButton, GetBitmapDisabled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnyButton::GetBitmapDisabled\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnyButton* current_object;
	wxphp_object_type current_object_type;
	wxAnyButton_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnyButton*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnyButton::GetBitmapDisabled call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANYBUTTON_TYPE){
				references = &((wxAnyButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::GetBitmapDisabled() to return new object\n\n");
				#endif

				wxBitmap value_to_return0;
				value_to_return0 = ((wxAnyButton_php*)native_object)->GetBitmapDisabled();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				((zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmap_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnyButton::GetBitmapDisabled\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxAnyButton::GetBitmapFocus()
   Returns the bitmap for the focused state, which may be invalid. */
PHP_METHOD(php_wxAnyButton, GetBitmapFocus)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnyButton::GetBitmapFocus\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnyButton* current_object;
	wxphp_object_type current_object_type;
	wxAnyButton_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnyButton*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnyButton::GetBitmapFocus call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANYBUTTON_TYPE){
				references = &((wxAnyButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::GetBitmapFocus() to return new object\n\n");
				#endif

				wxBitmap value_to_return0;
				value_to_return0 = ((wxAnyButton_php*)native_object)->GetBitmapFocus();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				((zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmap_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnyButton::GetBitmapFocus\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxAnyButton::GetBitmapLabel()
   Returns the bitmap for the normal state. */
PHP_METHOD(php_wxAnyButton, GetBitmapLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnyButton::GetBitmapLabel\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnyButton* current_object;
	wxphp_object_type current_object_type;
	wxAnyButton_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnyButton*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnyButton::GetBitmapLabel call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANYBUTTON_TYPE){
				references = &((wxAnyButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::GetBitmapLabel() to return new object\n\n");
				#endif

				wxBitmap value_to_return0;
				value_to_return0 = ((wxAnyButton_php*)native_object)->GetBitmapLabel();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				((zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmap_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnyButton::GetBitmapLabel\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxAnyButton::GetBitmapMargins()
   Get the margins between the bitmap and the text of the button. */
PHP_METHOD(php_wxAnyButton, GetBitmapMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnyButton::GetBitmapMargins\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnyButton* current_object;
	wxphp_object_type current_object_type;
	wxAnyButton_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnyButton*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnyButton::GetBitmapMargins call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANYBUTTON_TYPE){
				references = &((wxAnyButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::GetBitmapMargins() to return new object\n\n");
				#endif

				wxSize value_to_return0;
				value_to_return0 = ((wxAnyButton_php*)native_object)->GetBitmapMargins();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				((zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxSize_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnyButton::GetBitmapMargins\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxAnyButton::GetBitmapPressed()
   Returns the bitmap for the pressed state, which may be invalid. */
PHP_METHOD(php_wxAnyButton, GetBitmapPressed)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnyButton::GetBitmapPressed\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnyButton* current_object;
	wxphp_object_type current_object_type;
	wxAnyButton_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnyButton*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnyButton::GetBitmapPressed call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANYBUTTON_TYPE){
				references = &((wxAnyButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::GetBitmapPressed() to return new object\n\n");
				#endif

				wxBitmap value_to_return0;
				value_to_return0 = ((wxAnyButton_php*)native_object)->GetBitmapPressed();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				((zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmap_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnyButton::GetBitmapPressed\n");
	}
}
/* }}} */

/* {{{ proto  wxAnyButton::SetBitmap(wxBitmap bitmap, wxDirection dir)
   Sets the bitmap to display in the button. */
PHP_METHOD(php_wxAnyButton, SetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnyButton::SetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnyButton* current_object;
	wxphp_object_type current_object_type;
	wxAnyButton_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnyButton*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnyButton::SetBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANYBUTTON_TYPE){
				references = &((wxAnyButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	long dir0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&bitmap0, php_wxBitmap_entry, &dir0)\n");
		#endif

		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap0, php_wxBitmap_entry, &dir0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::SetBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif

				((wxAnyButton_php*)native_object)->SetBitmap(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bitmap0, "wxAnyButton::SetBitmap at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::SetBitmap(*(wxBitmap*) object_pointer0_0, (wxDirection) dir0)\n\n");
				#endif

				((wxAnyButton_php*)native_object)->SetBitmap(*(wxBitmap*) object_pointer0_0, (wxDirection) dir0);

				references->AddReference(bitmap0, "wxAnyButton::SetBitmap at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnyButton::SetBitmap\n");
	}
}
/* }}} */

/* {{{ proto  wxAnyButton::SetBitmapCurrent(wxBitmap bitmap)
   Sets the bitmap to be shown when the mouse is over the button. */
PHP_METHOD(php_wxAnyButton, SetBitmapCurrent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnyButton::SetBitmapCurrent\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnyButton* current_object;
	wxphp_object_type current_object_type;
	wxAnyButton_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnyButton*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnyButton::SetBitmapCurrent call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANYBUTTON_TYPE){
				references = &((wxAnyButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bitmap0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::SetBitmapCurrent(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif

				((wxAnyButton_php*)native_object)->SetBitmapCurrent(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bitmap0, "wxAnyButton::SetBitmapCurrent at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnyButton::SetBitmapCurrent\n");
	}
}
/* }}} */

/* {{{ proto  wxAnyButton::SetBitmapDisabled(wxBitmap bitmap)
   Sets the bitmap for the disabled button appearance. */
PHP_METHOD(php_wxAnyButton, SetBitmapDisabled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnyButton::SetBitmapDisabled\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnyButton* current_object;
	wxphp_object_type current_object_type;
	wxAnyButton_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnyButton*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnyButton::SetBitmapDisabled call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANYBUTTON_TYPE){
				references = &((wxAnyButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bitmap0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::SetBitmapDisabled(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif

				((wxAnyButton_php*)native_object)->SetBitmapDisabled(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bitmap0, "wxAnyButton::SetBitmapDisabled at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnyButton::SetBitmapDisabled\n");
	}
}
/* }}} */

/* {{{ proto  wxAnyButton::SetBitmapFocus(wxBitmap bitmap)
   Sets the bitmap for the button appearance when it has the keyboard focus. */
PHP_METHOD(php_wxAnyButton, SetBitmapFocus)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnyButton::SetBitmapFocus\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnyButton* current_object;
	wxphp_object_type current_object_type;
	wxAnyButton_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnyButton*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnyButton::SetBitmapFocus call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANYBUTTON_TYPE){
				references = &((wxAnyButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bitmap0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::SetBitmapFocus(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif

				((wxAnyButton_php*)native_object)->SetBitmapFocus(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bitmap0, "wxAnyButton::SetBitmapFocus at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnyButton::SetBitmapFocus\n");
	}
}
/* }}} */

/* {{{ proto  wxAnyButton::SetBitmapLabel(wxBitmap bitmap)
   Sets the bitmap label for the button. */
PHP_METHOD(php_wxAnyButton, SetBitmapLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnyButton::SetBitmapLabel\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnyButton* current_object;
	wxphp_object_type current_object_type;
	wxAnyButton_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnyButton*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnyButton::SetBitmapLabel call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANYBUTTON_TYPE){
				references = &((wxAnyButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bitmap0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::SetBitmapLabel(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif

				((wxAnyButton_php*)native_object)->SetBitmapLabel(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bitmap0, "wxAnyButton::SetBitmapLabel at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnyButton::SetBitmapLabel\n");
	}
}
/* }}} */

/* {{{ proto  wxAnyButton::SetBitmapMargins(wxSize sz)
   Set the margins between the bitmap and the text of the button. */
PHP_METHOD(php_wxAnyButton, SetBitmapMargins)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnyButton::SetBitmapMargins\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnyButton* current_object;
	wxphp_object_type current_object_type;
	wxAnyButton_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnyButton*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnyButton::SetBitmapMargins call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANYBUTTON_TYPE){
				references = &((wxAnyButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* sz0 = 0;
	wxSize* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	long x1;
	long y1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&sz0, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &sz0, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(sz0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(sz0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(sz0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxSize*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(sz0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x1, &y1)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x1, &y1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::SetBitmapMargins(*(wxSize*) object_pointer0_0)\n\n");
				#endif

				((wxAnyButton_php*)native_object)->SetBitmapMargins(*(wxSize*) object_pointer0_0);

				references->AddReference(sz0, "wxAnyButton::SetBitmapMargins at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::SetBitmapMargins((wxCoord) x1, (wxCoord) y1)\n\n");
				#endif

				((wxAnyButton_php*)native_object)->SetBitmapMargins((wxCoord) x1, (wxCoord) y1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnyButton::SetBitmapMargins\n");
	}
}
/* }}} */

/* {{{ proto  wxAnyButton::SetBitmapPosition(wxDirection dir)
   Set the position at which the bitmap is displayed. */
PHP_METHOD(php_wxAnyButton, SetBitmapPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnyButton::SetBitmapPosition\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnyButton* current_object;
	wxphp_object_type current_object_type;
	wxAnyButton_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnyButton*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnyButton::SetBitmapPosition call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANYBUTTON_TYPE){
				references = &((wxAnyButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long dir0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&dir0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dir0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::SetBitmapPosition((wxDirection) dir0)\n\n");
				#endif

				((wxAnyButton_php*)native_object)->SetBitmapPosition((wxDirection) dir0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnyButton::SetBitmapPosition\n");
	}
}
/* }}} */

/* {{{ proto  wxAnyButton::SetBitmapPressed(wxBitmap bitmap)
   Sets the bitmap for the selected (depressed) button appearance. */
PHP_METHOD(php_wxAnyButton, SetBitmapPressed)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnyButton::SetBitmapPressed\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnyButton* current_object;
	wxphp_object_type current_object_type;
	wxAnyButton_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnyButton*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnyButton::SetBitmapPressed call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANYBUTTON_TYPE){
				references = &((wxAnyButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBITMAPTOGGLEBUTTON_TYPE) && (!reference_type_found)){
				references = &((wxBitmapToggleButton_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bitmap0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnyButton::SetBitmapPressed(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif

				((wxAnyButton_php*)native_object)->SetBitmapPressed(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bitmap0, "wxAnyButton::SetBitmapPressed at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnyButton::SetBitmapPressed\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxWithImages_free(void *object TSRMLS_DC) 
{
    zo_wxWithImages* custom_object = (zo_wxWithImages*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxWithImages_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxWithImages done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxWithImages_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxWithImages_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxWithImages* custom_object;
    custom_object = (zo_wxWithImages*) emalloc(sizeof(zo_wxWithImages));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXWITHIMAGES_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxWithImages_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxWithImages::wxWithImages() */
PHP_METHOD(php_wxWithImages, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWithImages::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxWithImages* current_object;
	wxWithImages_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxWithImages_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxWithImages*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxWithImages::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxWithImages::SetImageList(wxImageList &imageList)
   Sets the image list to use. */
PHP_METHOD(php_wxWithImages, SetImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWithImages::SetImageList\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxWithImages* current_object;
	wxphp_object_type current_object_type;
	wxWithImages_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxWithImages*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxWithImages::SetImageList call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXWITHIMAGES_TYPE){
				references = &((wxWithImages_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBOOKCTRLBASE_TYPE) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXAUINOTEBOOK_TYPE) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXLISTBOOK_TYPE) && (!reference_type_found)){
				references = &((wxListbook_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXCHOICEBOOK_TYPE) && (!reference_type_found)){
				references = &((wxChoicebook_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXNOTEBOOK_TYPE) && (!reference_type_found)){
				references = &((wxNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTREEBOOK_TYPE) && (!reference_type_found)){
				references = &((wxTreebook_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOOLBOOK_TYPE) && (!reference_type_found)){
				references = &((wxToolbook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	wxImageList* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&imageList0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxImageList*) zend_object_store_get_object(imageList0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxImageList*) zend_object_store_get_object(imageList0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxImageList*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXIMAGELIST_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'imageList' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'imageList' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWithImages::SetImageList((wxImageList*) object_pointer0_0)\n\n");
				#endif

				((wxWithImages_php*)native_object)->SetImageList((wxImageList*) object_pointer0_0);

				references->AddReference(imageList0, "wxWithImages::SetImageList at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWithImages::SetImageList\n");
	}
}
/* }}} */

/* {{{ proto wxImageList wxWithImages::GetImageList()
   Returns the associated image list, may be NULL. */
PHP_METHOD(php_wxWithImages, GetImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWithImages::GetImageList\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxWithImages* current_object;
	wxphp_object_type current_object_type;
	wxWithImages_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxWithImages*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxWithImages::GetImageList call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXWITHIMAGES_TYPE){
				references = &((wxWithImages_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBOOKCTRLBASE_TYPE) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXAUINOTEBOOK_TYPE) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXLISTBOOK_TYPE) && (!reference_type_found)){
				references = &((wxListbook_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXCHOICEBOOK_TYPE) && (!reference_type_found)){
				references = &((wxChoicebook_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXNOTEBOOK_TYPE) && (!reference_type_found)){
				references = &((wxNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTREEBOOK_TYPE) && (!reference_type_found)){
				references = &((wxTreebook_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOOLBOOK_TYPE) && (!reference_type_found)){
				references = &((wxToolbook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWithImages::GetImageList() to return object pointer\n\n");
				#endif

				wxImageList_php* value_to_return0;
				value_to_return0 = (wxImageList_php*) ((wxWithImages_php*)native_object)->GetImageList();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxImageList_entry);
					((zo_wxImageList*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxImageList_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxWithImages::GetImageList at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWithImages::GetImageList\n");
	}
}
/* }}} */

/* {{{ proto  wxWithImages::AssignImageList(wxImageList &imageList)
   Sets the image list for the page control and takes ownership of the list. */
PHP_METHOD(php_wxWithImages, AssignImageList)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWithImages::AssignImageList\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxWithImages* current_object;
	wxphp_object_type current_object_type;
	wxWithImages_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxWithImages*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxWithImages::AssignImageList call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXWITHIMAGES_TYPE){
				references = &((wxWithImages_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXBOOKCTRLBASE_TYPE) && (!reference_type_found)){
				references = &((wxBookCtrlBase_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXAUINOTEBOOK_TYPE) && (!reference_type_found)){
				references = &((wxAuiNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXLISTBOOK_TYPE) && (!reference_type_found)){
				references = &((wxListbook_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXCHOICEBOOK_TYPE) && (!reference_type_found)){
				references = &((wxChoicebook_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXNOTEBOOK_TYPE) && (!reference_type_found)){
				references = &((wxNotebook_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTREEBOOK_TYPE) && (!reference_type_found)){
				references = &((wxTreebook_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXTOOLBOOK_TYPE) && (!reference_type_found)){
				references = &((wxToolbook_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* imageList0 = 0;
	wxImageList* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&imageList0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageList0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(imageList0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxImageList*) zend_object_store_get_object(imageList0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxImageList*) zend_object_store_get_object(imageList0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxImageList*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXIMAGELIST_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'imageList' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(imageList0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'imageList' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWithImages::AssignImageList((wxImageList*) object_pointer0_0)\n\n");
				#endif

				((wxWithImages_php*)native_object)->AssignImageList((wxImageList*) object_pointer0_0);

				references->AddReference(imageList0, "wxWithImages::AssignImageList at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWithImages::AssignImageList\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxTextCompleter_free(void *object TSRMLS_DC) 
{
    zo_wxTextCompleter* custom_object = (zo_wxTextCompleter*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTextCompleter_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxTextCompleter done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxTextCompleter_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTextCompleter_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxTextCompleter* custom_object;
    custom_object = (zo_wxTextCompleter*) emalloc(sizeof(zo_wxTextCompleter));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXTEXTCOMPLETER_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxTextCompleter_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto string wxTextCompleter::GetNext()
   Called to retrieve the next completion. */
wxString wxTextCompleter_php::GetNext()
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxTextCompleter::GetNext\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval* arguments[1];
	arguments[0] = NULL;
	params[0] = NULL;

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetNext", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
		

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetNext", 7, &return_value, 0, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxTextCompleter::GetNext'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return wxString(Z_STRVAL_P(return_value), wxConvUTF8);
	
}
/* }}} */

/* {{{ proto bool wxTextCompleter::Start(string prefix)
   Function called to start iteration over the completions for the given prefix. */
bool wxTextCompleter_php::Start(const wxString& prefix)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxTextCompleter::Start\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "Start", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	temp_string = (char*)malloc(sizeof(wxChar)*(prefix.size()+1));
	strcpy(temp_string, (const char *) prefix.char_str());
	ZVAL_STRING(arguments[0], temp_string, 1);
	free(temp_string);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "Start", 5, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxTextCompleter::Start'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return Z_BVAL_P(return_value);
	
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxWindowModalDialogEvent_free(void *object TSRMLS_DC) 
{
    zo_wxWindowModalDialogEvent* custom_object = (zo_wxWindowModalDialogEvent*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxWindowModalDialogEvent_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxWindowModalDialogEvent done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxWindowModalDialogEvent_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxWindowModalDialogEvent_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxWindowModalDialogEvent* custom_object;
    custom_object = (zo_wxWindowModalDialogEvent*) emalloc(sizeof(zo_wxWindowModalDialogEvent));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXWINDOWMODALDIALOGEVENT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxWindowModalDialogEvent_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto wxEvent wxWindowModalDialogEvent::Clone()
   Returns a copy of the event. */
PHP_METHOD(php_wxWindowModalDialogEvent, CloneMethod)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWindowModalDialogEvent::Clone\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxWindowModalDialogEvent* current_object;
	wxphp_object_type current_object_type;
	wxWindowModalDialogEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxWindowModalDialogEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxWindowModalDialogEvent::Clone call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXWINDOWMODALDIALOGEVENT_TYPE){
				references = &((wxWindowModalDialogEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWindowModalDialogEvent::Clone() to return object pointer\n\n");
				#endif

				wxEvent_php* value_to_return0;
				value_to_return0 = (wxEvent_php*) ((wxWindowModalDialogEvent_php*)native_object)->Clone();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxEvent_entry);
					((zo_wxEvent*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxEvent_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxWindowModalDialogEvent::Clone at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWindowModalDialogEvent::Clone\n");
	}
}
/* }}} */

/* {{{ proto wxDialog wxWindowModalDialogEvent::GetDialog() */
PHP_METHOD(php_wxWindowModalDialogEvent, GetDialog)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWindowModalDialogEvent::GetDialog\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxWindowModalDialogEvent* current_object;
	wxphp_object_type current_object_type;
	wxWindowModalDialogEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxWindowModalDialogEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxWindowModalDialogEvent::GetDialog call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXWINDOWMODALDIALOGEVENT_TYPE){
				references = &((wxWindowModalDialogEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxWindowModalDialogEvent::GetDialog() to return object pointer\n\n");
				#endif

				wxDialog_php* value_to_return0;
				value_to_return0 = (wxDialog_php*) ((wxWindowModalDialogEvent_php*)native_object)->GetDialog();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxDialog_entry);
					((zo_wxDialog*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxDialog_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxWindowModalDialogEvent::GetDialog at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWindowModalDialogEvent::GetDialog\n");
	}
}
/* }}} */

/* {{{ proto int wxWindowModalDialogEvent::GetReturnCode() */
PHP_METHOD(php_wxWindowModalDialogEvent, GetReturnCode)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWindowModalDialogEvent::GetReturnCode\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxWindowModalDialogEvent* current_object;
	wxphp_object_type current_object_type;
	wxWindowModalDialogEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxWindowModalDialogEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxWindowModalDialogEvent::GetReturnCode call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXWINDOWMODALDIALOGEVENT_TYPE){
				references = &((wxWindowModalDialogEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxWindowModalDialogEvent::GetReturnCode())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxWindowModalDialogEvent_php*)native_object)->GetReturnCode());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxWindowModalDialogEvent::GetReturnCode\n");
	}
}
/* }}} */

/* {{{ proto  wxWindowModalDialogEvent::wxWindowModalDialogEvent(int commandType, int id) */
PHP_METHOD(php_wxWindowModalDialogEvent, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxWindowModalDialogEvent::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxWindowModalDialogEvent* current_object;
	wxWindowModalDialogEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	long commandType0;
	long id0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|ll' (&commandType0, &id0)\n");
		#endif

		char parse_parameters_string[] = "|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &commandType0, &id0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxWindowModalDialogEvent_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxEventType) commandType0)\n");
				#endif

				native_object = new wxWindowModalDialogEvent_php((wxEventType) commandType0);

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxEventType) commandType0, (int) id0)\n");
				#endif

				native_object = new wxWindowModalDialogEvent_php((wxEventType) commandType0, (int) id0);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxWindowModalDialogEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxWindowModalDialogEvent::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPoint2DDouble_free(void *object TSRMLS_DC) 
{
    zo_wxPoint2DDouble* custom_object = (zo_wxPoint2DDouble*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPoint2DDouble_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxPoint2DDouble done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxPoint2DDouble_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPoint2DDouble_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxPoint2DDouble* custom_object;
    custom_object = (zo_wxPoint2DDouble*) emalloc(sizeof(zo_wxPoint2DDouble));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPOINT2DDOUBLE_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxPoint2DDouble_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxPoint2DDouble::wxPoint2DDouble() */
PHP_METHOD(php_wxPoint2DDouble, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DDouble::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DDouble* current_object;
	wxPoint2DDouble_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	double x1;
	double y1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* pt2 = 0;
	wxPoint2DDouble* object_pointer2_0 = 0;
	bool overload2_called = false;
	//Parameters for overload 3
	zval* pt3 = 0;
	wxPoint2DInt* object_pointer3_0 = 0;
	bool overload3_called = false;
	//Parameters for overload 4
	zval* pt4 = 0;
	wxPoint* object_pointer4_0 = 0;
	bool overload4_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'dd' (&x1, &y1)\n");
		#endif

		char parse_parameters_string[] = "dd";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x1, &y1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt2, php_wxPoint2DDouble_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt2, php_wxPoint2DDouble_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint2DDouble*) zend_object_store_get_object(pt2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint2DDouble*) zend_object_store_get_object(pt2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxPoint2DDouble*) argument_native_object;
					if (!object_pointer2_0 )
					{
						goto overload3;
					}
				}
				else if(Z_TYPE_P(pt2) != IS_NULL)
				{
					goto overload3;
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt3, php_wxPoint2DInt_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt3, php_wxPoint2DInt_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt3) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint2DInt*) zend_object_store_get_object(pt3 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint2DInt*) zend_object_store_get_object(pt3 TSRMLS_CC))->native_object;
					object_pointer3_0 = (wxPoint2DInt*) argument_native_object;
					if (!object_pointer3_0 )
					{
						goto overload4;
					}
				}
				else if(Z_TYPE_P(pt3) != IS_NULL)
				{
					goto overload4;
				}
			}

			overload3_called = true;
			already_called = true;
		}
	}

	//Overload 4
	overload4:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt4, php_wxPoint_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt4, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt4) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pt4 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pt4 TSRMLS_CC))->native_object;
					object_pointer4_0 = (wxPoint*) argument_native_object;
					if (!object_pointer4_0 )
					{
						zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt4) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
				}
			}

			overload4_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxPoint2DDouble_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(x1, y1)\n");
				#endif

				native_object = new wxPoint2DDouble_php(x1, y1);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxPoint2DDouble*) object_pointer2_0)\n");
				#endif

				native_object = new wxPoint2DDouble_php(*(wxPoint2DDouble*) object_pointer2_0);

				native_object->references.Initialize();
				((wxPoint2DDouble_php*) native_object)->references.AddReference(pt2, "wxPoint2DDouble::wxPoint2DDouble at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxPoint2DInt*) object_pointer3_0)\n");
				#endif

				native_object = new wxPoint2DDouble_php(*(wxPoint2DInt*) object_pointer3_0);

				native_object->references.Initialize();
				((wxPoint2DDouble_php*) native_object)->references.AddReference(pt3, "wxPoint2DDouble::wxPoint2DDouble at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload4_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxPoint*) object_pointer4_0)\n");
				#endif

				native_object = new wxPoint2DDouble_php(*(wxPoint*) object_pointer4_0);

				native_object->references.Initialize();
				((wxPoint2DDouble_php*) native_object)->references.AddReference(pt4, "wxPoint2DDouble::wxPoint2DDouble at call with 1 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxPoint2DDouble*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxPoint2DDouble::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

PHP_METHOD(php_wxPoint2DDouble, __get)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DDouble::__get\n");
	php_printf("===========================================\n");
	#endif
	
	int arguments_received = ZEND_NUM_ARGS();
	zo_wxPoint2DDouble* current_object;
	wxPoint2DDouble_php* native_object;
	
	char* name;
	int name_len;
	
	//Get native object of the php object that called the method
	if (getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DDouble*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DDouble::wxPoint2DDouble call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
		}
	}
	else
	{
		zend_error(E_ERROR, "Could not process __get call as static\n");
	}
	
	char parse_parameters_string[] = "s";
	
	if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name, &name_len ) == FAILURE)
	{
		RETVAL_NULL();
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Property to get: %s\n", name);
	php_printf("===========================================\n\n");
	#endif
	
	if(false){}
	else if(strcmp("m_x", name) == 0)
	{
		RETVAL_DOUBLE(*((wxDouble*) native_object->properties[0]));
	}
	else if(strcmp("m_y", name) == 0)
	{
		RETVAL_DOUBLE(*((wxDouble*) native_object->properties[1]));
	}
	else
	{
		RETVAL_NULL();
	}
}
/* {{{ proto  wxPoint2DDouble::SetVectorLength(float length) */
PHP_METHOD(php_wxPoint2DDouble, SetVectorLength)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DDouble::SetVectorLength\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DDouble* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DDouble_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DDouble*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DDouble::SetVectorLength call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
				references = &((wxPoint2DDouble_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	double length0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'd' (&length0)\n");
		#endif

		char parse_parameters_string[] = "d";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &length0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPoint2DDouble::SetVectorLength(length0)\n\n");
				#endif

				((wxPoint2DDouble_php*)native_object)->SetVectorLength(length0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DDouble::SetVectorLength\n");
	}
}
/* }}} */

/* {{{ proto  wxPoint2DDouble::SetVectorAngle(float degrees) */
PHP_METHOD(php_wxPoint2DDouble, SetVectorAngle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DDouble::SetVectorAngle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DDouble* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DDouble_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DDouble*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DDouble::SetVectorAngle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
				references = &((wxPoint2DDouble_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	double degrees0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'd' (&degrees0)\n");
		#endif

		char parse_parameters_string[] = "d";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &degrees0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPoint2DDouble::SetVectorAngle(degrees0)\n\n");
				#endif

				((wxPoint2DDouble_php*)native_object)->SetVectorAngle(degrees0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DDouble::SetVectorAngle\n");
	}
}
/* }}} */

/* {{{ proto  wxPoint2DDouble::Normalize() */
PHP_METHOD(php_wxPoint2DDouble, Normalize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DDouble::Normalize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DDouble* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DDouble_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DDouble*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DDouble::Normalize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
				references = &((wxPoint2DDouble_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPoint2DDouble::Normalize()\n\n");
				#endif

				((wxPoint2DDouble_php*)native_object)->Normalize();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DDouble::Normalize\n");
	}
}
/* }}} */

/* {{{ proto float wxPoint2DDouble::GetVectorLength() */
PHP_METHOD(php_wxPoint2DDouble, GetVectorLength)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DDouble::GetVectorLength\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DDouble* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DDouble_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DDouble*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DDouble::GetVectorLength call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
				references = &((wxPoint2DDouble_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPoint2DDouble::GetVectorLength())\n\n");
				#endif

				ZVAL_DOUBLE(return_value, ((wxPoint2DDouble_php*)native_object)->GetVectorLength());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DDouble::GetVectorLength\n");
	}
}
/* }}} */

/* {{{ proto float wxPoint2DDouble::GetVectorAngle() */
PHP_METHOD(php_wxPoint2DDouble, GetVectorAngle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DDouble::GetVectorAngle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DDouble* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DDouble_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DDouble*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DDouble::GetVectorAngle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
				references = &((wxPoint2DDouble_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPoint2DDouble::GetVectorAngle())\n\n");
				#endif

				ZVAL_DOUBLE(return_value, ((wxPoint2DDouble_php*)native_object)->GetVectorAngle());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DDouble::GetVectorAngle\n");
	}
}
/* }}} */

/* {{{ proto float wxPoint2DDouble::GetDotProduct(wxPoint2DDouble vec) */
PHP_METHOD(php_wxPoint2DDouble, GetDotProduct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DDouble::GetDotProduct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DDouble* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DDouble_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DDouble*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DDouble::GetDotProduct call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
				references = &((wxPoint2DDouble_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* vec0 = 0;
	wxPoint2DDouble* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&vec0, php_wxPoint2DDouble_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &vec0, php_wxPoint2DDouble_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(vec0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint2DDouble*) zend_object_store_get_object(vec0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint2DDouble*) zend_object_store_get_object(vec0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxPoint2DDouble*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'vec' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(vec0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'vec' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPoint2DDouble::GetDotProduct(*(wxPoint2DDouble*) object_pointer0_0))\n\n");
				#endif

				ZVAL_DOUBLE(return_value, ((wxPoint2DDouble_php*)native_object)->GetDotProduct(*(wxPoint2DDouble*) object_pointer0_0));

				references->AddReference(vec0, "wxPoint2DDouble::GetDotProduct at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DDouble::GetDotProduct\n");
	}
}
/* }}} */

/* {{{ proto float wxPoint2DDouble::GetDistanceSquare(wxPoint2DDouble pt) */
PHP_METHOD(php_wxPoint2DDouble, GetDistanceSquare)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DDouble::GetDistanceSquare\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DDouble* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DDouble_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DDouble*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DDouble::GetDistanceSquare call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
				references = &((wxPoint2DDouble_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* pt0 = 0;
	wxPoint2DDouble* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt0, php_wxPoint2DDouble_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt0, php_wxPoint2DDouble_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint2DDouble*) zend_object_store_get_object(pt0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint2DDouble*) zend_object_store_get_object(pt0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxPoint2DDouble*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPoint2DDouble::GetDistanceSquare(*(wxPoint2DDouble*) object_pointer0_0))\n\n");
				#endif

				ZVAL_DOUBLE(return_value, ((wxPoint2DDouble_php*)native_object)->GetDistanceSquare(*(wxPoint2DDouble*) object_pointer0_0));

				references->AddReference(pt0, "wxPoint2DDouble::GetDistanceSquare at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DDouble::GetDistanceSquare\n");
	}
}
/* }}} */

/* {{{ proto float wxPoint2DDouble::GetDistance(wxPoint2DDouble pt) */
PHP_METHOD(php_wxPoint2DDouble, GetDistance)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DDouble::GetDistance\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DDouble* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DDouble_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DDouble*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DDouble::GetDistance call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
				references = &((wxPoint2DDouble_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* pt0 = 0;
	wxPoint2DDouble* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt0, php_wxPoint2DDouble_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt0, php_wxPoint2DDouble_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint2DDouble*) zend_object_store_get_object(pt0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint2DDouble*) zend_object_store_get_object(pt0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxPoint2DDouble*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPoint2DDouble::GetDistance(*(wxPoint2DDouble*) object_pointer0_0))\n\n");
				#endif

				ZVAL_DOUBLE(return_value, ((wxPoint2DDouble_php*)native_object)->GetDistance(*(wxPoint2DDouble*) object_pointer0_0));

				references->AddReference(pt0, "wxPoint2DDouble::GetDistance at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DDouble::GetDistance\n");
	}
}
/* }}} */

/* {{{ proto float wxPoint2DDouble::GetCrossProduct(wxPoint2DDouble vec) */
PHP_METHOD(php_wxPoint2DDouble, GetCrossProduct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DDouble::GetCrossProduct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DDouble* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DDouble_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DDouble*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DDouble::GetCrossProduct call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
				references = &((wxPoint2DDouble_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* vec0 = 0;
	wxPoint2DDouble* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&vec0, php_wxPoint2DDouble_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &vec0, php_wxPoint2DDouble_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(vec0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint2DDouble*) zend_object_store_get_object(vec0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint2DDouble*) zend_object_store_get_object(vec0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxPoint2DDouble*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'vec' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(vec0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'vec' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPoint2DDouble::GetCrossProduct(*(wxPoint2DDouble*) object_pointer0_0))\n\n");
				#endif

				ZVAL_DOUBLE(return_value, ((wxPoint2DDouble_php*)native_object)->GetCrossProduct(*(wxPoint2DDouble*) object_pointer0_0));

				references->AddReference(vec0, "wxPoint2DDouble::GetCrossProduct at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DDouble::GetCrossProduct\n");
	}
}
/* }}} */

/* {{{ proto  wxPoint2DDouble::GetFloor(int x, int y) */
PHP_METHOD(php_wxPoint2DDouble, GetFloor)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DDouble::GetFloor\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DDouble* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DDouble_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DDouble*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DDouble::GetFloor call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
				references = &((wxPoint2DDouble_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPoint2DDouble::GetFloor((wxInt32*) x0, (wxInt32*) y0)\n\n");
				#endif

				((wxPoint2DDouble_php*)native_object)->GetFloor((wxInt32*) x0, (wxInt32*) y0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DDouble::GetFloor\n");
	}
}
/* }}} */

/* {{{ proto  wxPoint2DDouble::GetRounded(int x, int y) */
PHP_METHOD(php_wxPoint2DDouble, GetRounded)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DDouble::GetRounded\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DDouble* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DDouble_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DDouble*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DDouble::GetRounded call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DDOUBLE_TYPE){
				references = &((wxPoint2DDouble_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPoint2DDouble::GetRounded((wxInt32*) x0, (wxInt32*) y0)\n\n");
				#endif

				((wxPoint2DDouble_php*)native_object)->GetRounded((wxInt32*) x0, (wxInt32*) y0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DDouble::GetRounded\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPoint2DInt_free(void *object TSRMLS_DC) 
{
    zo_wxPoint2DInt* custom_object = (zo_wxPoint2DInt*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPoint2DInt_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxPoint2DInt done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxPoint2DInt_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPoint2DInt_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxPoint2DInt* custom_object;
    custom_object = (zo_wxPoint2DInt*) emalloc(sizeof(zo_wxPoint2DInt));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPOINT2DINT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxPoint2DInt_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto int wxPoint2DInt::GetCrossProduct(wxPoint2DInt vec) */
PHP_METHOD(php_wxPoint2DInt, GetCrossProduct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DInt::GetCrossProduct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DInt* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DInt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DInt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DInt::GetCrossProduct call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DINT_TYPE){
				references = &((wxPoint2DInt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* vec0 = 0;
	wxPoint2DInt* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&vec0, php_wxPoint2DInt_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &vec0, php_wxPoint2DInt_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(vec0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint2DInt*) zend_object_store_get_object(vec0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint2DInt*) zend_object_store_get_object(vec0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxPoint2DInt*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'vec' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(vec0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'vec' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPoint2DInt::GetCrossProduct(*(wxPoint2DInt*) object_pointer0_0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPoint2DInt_php*)native_object)->GetCrossProduct(*(wxPoint2DInt*) object_pointer0_0));

				references->AddReference(vec0, "wxPoint2DInt::GetCrossProduct at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DInt::GetCrossProduct\n");
	}
}
/* }}} */

/* {{{ proto float wxPoint2DInt::GetDistance(wxPoint2DInt pt) */
PHP_METHOD(php_wxPoint2DInt, GetDistance)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DInt::GetDistance\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DInt* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DInt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DInt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DInt::GetDistance call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DINT_TYPE){
				references = &((wxPoint2DInt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* pt0 = 0;
	wxPoint2DInt* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt0, php_wxPoint2DInt_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt0, php_wxPoint2DInt_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint2DInt*) zend_object_store_get_object(pt0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint2DInt*) zend_object_store_get_object(pt0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxPoint2DInt*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPoint2DInt::GetDistance(*(wxPoint2DInt*) object_pointer0_0))\n\n");
				#endif

				ZVAL_DOUBLE(return_value, ((wxPoint2DInt_php*)native_object)->GetDistance(*(wxPoint2DInt*) object_pointer0_0));

				references->AddReference(pt0, "wxPoint2DInt::GetDistance at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DInt::GetDistance\n");
	}
}
/* }}} */

/* {{{ proto float wxPoint2DInt::GetDistanceSquare(wxPoint2DInt pt) */
PHP_METHOD(php_wxPoint2DInt, GetDistanceSquare)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DInt::GetDistanceSquare\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DInt* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DInt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DInt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DInt::GetDistanceSquare call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DINT_TYPE){
				references = &((wxPoint2DInt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* pt0 = 0;
	wxPoint2DInt* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt0, php_wxPoint2DInt_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt0, php_wxPoint2DInt_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint2DInt*) zend_object_store_get_object(pt0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint2DInt*) zend_object_store_get_object(pt0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxPoint2DInt*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPoint2DInt::GetDistanceSquare(*(wxPoint2DInt*) object_pointer0_0))\n\n");
				#endif

				ZVAL_DOUBLE(return_value, ((wxPoint2DInt_php*)native_object)->GetDistanceSquare(*(wxPoint2DInt*) object_pointer0_0));

				references->AddReference(pt0, "wxPoint2DInt::GetDistanceSquare at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DInt::GetDistanceSquare\n");
	}
}
/* }}} */

/* {{{ proto int wxPoint2DInt::GetDotProduct(wxPoint2DInt vec) */
PHP_METHOD(php_wxPoint2DInt, GetDotProduct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DInt::GetDotProduct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DInt* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DInt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DInt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DInt::GetDotProduct call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DINT_TYPE){
				references = &((wxPoint2DInt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* vec0 = 0;
	wxPoint2DInt* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&vec0, php_wxPoint2DInt_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &vec0, php_wxPoint2DInt_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(vec0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint2DInt*) zend_object_store_get_object(vec0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint2DInt*) zend_object_store_get_object(vec0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxPoint2DInt*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'vec' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(vec0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'vec' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPoint2DInt::GetDotProduct(*(wxPoint2DInt*) object_pointer0_0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPoint2DInt_php*)native_object)->GetDotProduct(*(wxPoint2DInt*) object_pointer0_0));

				references->AddReference(vec0, "wxPoint2DInt::GetDotProduct at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DInt::GetDotProduct\n");
	}
}
/* }}} */

/* {{{ proto float wxPoint2DInt::GetVectorAngle() */
PHP_METHOD(php_wxPoint2DInt, GetVectorAngle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DInt::GetVectorAngle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DInt* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DInt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DInt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DInt::GetVectorAngle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DINT_TYPE){
				references = &((wxPoint2DInt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPoint2DInt::GetVectorAngle())\n\n");
				#endif

				ZVAL_DOUBLE(return_value, ((wxPoint2DInt_php*)native_object)->GetVectorAngle());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DInt::GetVectorAngle\n");
	}
}
/* }}} */

/* {{{ proto float wxPoint2DInt::GetVectorLength() */
PHP_METHOD(php_wxPoint2DInt, GetVectorLength)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DInt::GetVectorLength\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DInt* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DInt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DInt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DInt::GetVectorLength call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DINT_TYPE){
				references = &((wxPoint2DInt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPoint2DInt::GetVectorLength())\n\n");
				#endif

				ZVAL_DOUBLE(return_value, ((wxPoint2DInt_php*)native_object)->GetVectorLength());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DInt::GetVectorLength\n");
	}
}
/* }}} */

/* {{{ proto  wxPoint2DInt::Normalize() */
PHP_METHOD(php_wxPoint2DInt, Normalize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DInt::Normalize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DInt* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DInt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DInt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DInt::Normalize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DINT_TYPE){
				references = &((wxPoint2DInt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPoint2DInt::Normalize()\n\n");
				#endif

				((wxPoint2DInt_php*)native_object)->Normalize();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DInt::Normalize\n");
	}
}
/* }}} */

/* {{{ proto  wxPoint2DInt::SetVectorAngle(float degrees) */
PHP_METHOD(php_wxPoint2DInt, SetVectorAngle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DInt::SetVectorAngle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DInt* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DInt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DInt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DInt::SetVectorAngle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DINT_TYPE){
				references = &((wxPoint2DInt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	double degrees0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'd' (&degrees0)\n");
		#endif

		char parse_parameters_string[] = "d";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &degrees0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPoint2DInt::SetVectorAngle(degrees0)\n\n");
				#endif

				((wxPoint2DInt_php*)native_object)->SetVectorAngle(degrees0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DInt::SetVectorAngle\n");
	}
}
/* }}} */

/* {{{ proto  wxPoint2DInt::SetVectorLength(float length) */
PHP_METHOD(php_wxPoint2DInt, SetVectorLength)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DInt::SetVectorLength\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DInt* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DInt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DInt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DInt::SetVectorLength call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DINT_TYPE){
				references = &((wxPoint2DInt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	double length0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'd' (&length0)\n");
		#endif

		char parse_parameters_string[] = "d";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &length0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPoint2DInt::SetVectorLength(length0)\n\n");
				#endif

				((wxPoint2DInt_php*)native_object)->SetVectorLength(length0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DInt::SetVectorLength\n");
	}
}
/* }}} */

/* {{{ proto  wxPoint2DInt::wxPoint2DInt() */
PHP_METHOD(php_wxPoint2DInt, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DInt::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DInt* current_object;
	wxPoint2DInt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	long x1;
	long y1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* pt2 = 0;
	wxPoint2DInt* object_pointer2_0 = 0;
	bool overload2_called = false;
	//Parameters for overload 3
	zval* pt3 = 0;
	wxPoint* object_pointer3_0 = 0;
	bool overload3_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x1, &y1)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x1, &y1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt2, php_wxPoint2DInt_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt2, php_wxPoint2DInt_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint2DInt*) zend_object_store_get_object(pt2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint2DInt*) zend_object_store_get_object(pt2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxPoint2DInt*) argument_native_object;
					if (!object_pointer2_0 )
					{
						goto overload3;
					}
				}
				else if(Z_TYPE_P(pt2) != IS_NULL)
				{
					goto overload3;
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pt3, php_wxPoint_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pt3, php_wxPoint_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pt3) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pt3 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pt3 TSRMLS_CC))->native_object;
					object_pointer3_0 = (wxPoint*) argument_native_object;
					if (!object_pointer3_0 )
					{
						zend_error(E_ERROR, "Parameter 'pt' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pt3) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pt' not null, could not be retreived correctly.");
				}
			}

			overload3_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxPoint2DInt_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxInt32) x1, (wxInt32) y1)\n");
				#endif

				native_object = new wxPoint2DInt_php((wxInt32) x1, (wxInt32) y1);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxPoint2DInt*) object_pointer2_0)\n");
				#endif

				native_object = new wxPoint2DInt_php(*(wxPoint2DInt*) object_pointer2_0);

				native_object->references.Initialize();
				((wxPoint2DInt_php*) native_object)->references.AddReference(pt2, "wxPoint2DInt::wxPoint2DInt at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxPoint*) object_pointer3_0)\n");
				#endif

				native_object = new wxPoint2DInt_php(*(wxPoint*) object_pointer3_0);

				native_object->references.Initialize();
				((wxPoint2DInt_php*) native_object)->references.AddReference(pt3, "wxPoint2DInt::wxPoint2DInt at call with 1 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxPoint2DInt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxPoint2DInt::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

PHP_METHOD(php_wxPoint2DInt, __get)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DInt::__get\n");
	php_printf("===========================================\n");
	#endif
	
	int arguments_received = ZEND_NUM_ARGS();
	zo_wxPoint2DInt* current_object;
	wxPoint2DInt_php* native_object;
	
	char* name;
	int name_len;
	
	//Get native object of the php object that called the method
	if (getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DInt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DInt::wxPoint2DInt call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
		}
	}
	else
	{
		zend_error(E_ERROR, "Could not process __get call as static\n");
	}
	
	char parse_parameters_string[] = "s";
	
	if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name, &name_len ) == FAILURE)
	{
		RETVAL_NULL();
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Property to get: %s\n", name);
	php_printf("===========================================\n\n");
	#endif
	
	if(false){}
	else if(strcmp("m_x", name) == 0)
	{
		RETVAL_LONG(*((wxInt32*) native_object->properties[0]));
	}
	else if(strcmp("m_y", name) == 0)
	{
		RETVAL_LONG(*((wxInt32*) native_object->properties[1]));
	}
	else
	{
		RETVAL_NULL();
	}
}
/* {{{ proto  wxPoint2DInt::GetFloor(int x, int y) */
PHP_METHOD(php_wxPoint2DInt, GetFloor)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DInt::GetFloor\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DInt* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DInt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DInt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DInt::GetFloor call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DINT_TYPE){
				references = &((wxPoint2DInt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPoint2DInt::GetFloor((wxInt32*) x0, (wxInt32*) y0)\n\n");
				#endif

				((wxPoint2DInt_php*)native_object)->GetFloor((wxInt32*) x0, (wxInt32*) y0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DInt::GetFloor\n");
	}
}
/* }}} */

/* {{{ proto  wxPoint2DInt::GetRounded(int x, int y) */
PHP_METHOD(php_wxPoint2DInt, GetRounded)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPoint2DInt::GetRounded\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPoint2DInt* current_object;
	wxphp_object_type current_object_type;
	wxPoint2DInt_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPoint2DInt*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPoint2DInt::GetRounded call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPOINT2DINT_TYPE){
				references = &((wxPoint2DInt_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPoint2DInt::GetRounded((wxInt32*) x0, (wxInt32*) y0)\n\n");
				#endif

				((wxPoint2DInt_php*)native_object)->GetRounded((wxInt32*) x0, (wxInt32*) y0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPoint2DInt::GetRounded\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxProgressDialog_free(void *object TSRMLS_DC) 
{
    zo_wxProgressDialog* custom_object = (zo_wxProgressDialog*) object;
    //delete custom_object->native_object;
    
	/*zend_error(E_WARNING, "Object of class wxProgressDialog went out of scope. Remember to always call Destroy() to prevent memory leaks.");*/

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxProgressDialog_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxProgressDialog_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxProgressDialog* custom_object;
    custom_object = (zo_wxProgressDialog*) emalloc(sizeof(zo_wxProgressDialog));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPROGRESSDIALOG_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxProgressDialog_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxProgressDialog::wxProgressDialog(string title, string message, int maximum, wxWindow &parent, int style) */
PHP_METHOD(php_wxProgressDialog, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxProgressDialog::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxProgressDialog* current_object;
	wxProgressDialog_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	char* title0;
	long title_len0;
	char* message0;
	long message_len0;
	long maximum0;
	zval* parent0 = 0;
	wxWindow* object_pointer0_3 = 0;
	long style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ss|lzl' (&title0, &title_len0, &message0, &message_len0, &maximum0, &parent0, &style0)\n");
		#endif

		char parse_parameters_string[] = "ss|lzl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &title0, &title_len0, &message0, &message_len0, &maximum0, &parent0, &style0 ) == SUCCESS)
		{
			if(arguments_received >= 4){
				if(Z_TYPE_P(parent0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(parent0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(parent0 TSRMLS_CC))->native_object;
					object_pointer0_3 = (wxWindow*) argument_native_object;
					if (!object_pointer0_3 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXPAGESETUPDIALOG_TYPE && argument_type != PHP_WXPRINTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'parent' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(parent0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'parent' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(title0, wxConvUTF8), wxString(message0, wxConvUTF8))\n");
				#endif

				native_object = new wxProgressDialog_php(wxString(title0, wxConvUTF8), wxString(message0, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(title0, wxConvUTF8), wxString(message0, wxConvUTF8), (int) maximum0)\n");
				#endif

				native_object = new wxProgressDialog_php(wxString(title0, wxConvUTF8), wxString(message0, wxConvUTF8), (int) maximum0);

				native_object->references.Initialize();
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(title0, wxConvUTF8), wxString(message0, wxConvUTF8), (int) maximum0, (wxWindow*) object_pointer0_3)\n");
				#endif

				native_object = new wxProgressDialog_php(wxString(title0, wxConvUTF8), wxString(message0, wxConvUTF8), (int) maximum0, (wxWindow*) object_pointer0_3);

				native_object->references.Initialize();
				((wxProgressDialog_php*) native_object)->references.AddReference(parent0, "wxProgressDialog::wxProgressDialog at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(title0, wxConvUTF8), wxString(message0, wxConvUTF8), (int) maximum0, (wxWindow*) object_pointer0_3, (int) style0)\n");
				#endif

				native_object = new wxProgressDialog_php(wxString(title0, wxConvUTF8), wxString(message0, wxConvUTF8), (int) maximum0, (wxWindow*) object_pointer0_3, (int) style0);

				native_object->references.Initialize();
				((wxProgressDialog_php*) native_object)->references.AddReference(parent0, "wxProgressDialog::wxProgressDialog at call with 5 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxProgressDialog*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxProgressDialog::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxLayoutConstraints_free(void *object TSRMLS_DC) 
{
    zo_wxLayoutConstraints* custom_object = (zo_wxLayoutConstraints*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxLayoutConstraints_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxLayoutConstraints done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxLayoutConstraints_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxLayoutConstraints_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxLayoutConstraints* custom_object;
    custom_object = (zo_wxLayoutConstraints*) emalloc(sizeof(zo_wxLayoutConstraints));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXLAYOUTCONSTRAINTS_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxLayoutConstraints_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto bool wxLayoutConstraints::AreSatisfied() */
PHP_METHOD(php_wxLayoutConstraints, AreSatisfied)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLayoutConstraints::AreSatisfied\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxLayoutConstraints* current_object;
	wxphp_object_type current_object_type;
	wxLayoutConstraints_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxLayoutConstraints*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxLayoutConstraints::AreSatisfied call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLAYOUTCONSTRAINTS_TYPE){
				references = &((wxLayoutConstraints_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxLayoutConstraints::AreSatisfied())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxLayoutConstraints_php*)native_object)->AreSatisfied());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxLayoutConstraints::AreSatisfied\n");
	}
}
/* }}} */

/* {{{ proto  wxLayoutConstraints::wxLayoutConstraints() */
PHP_METHOD(php_wxLayoutConstraints, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLayoutConstraints::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxLayoutConstraints* current_object;
	wxLayoutConstraints_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxLayoutConstraints_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxLayoutConstraints*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxLayoutConstraints::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

PHP_METHOD(php_wxLayoutConstraints, __get)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLayoutConstraints::__get\n");
	php_printf("===========================================\n");
	#endif
	
	int arguments_received = ZEND_NUM_ARGS();
	zo_wxLayoutConstraints* current_object;
	wxLayoutConstraints_php* native_object;
	
	char* name;
	int name_len;
	
	//Get native object of the php object that called the method
	if (getThis() != NULL) 
	{
		current_object = (zo_wxLayoutConstraints*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxLayoutConstraints::wxLayoutConstraints call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
		}
	}
	else
	{
		zend_error(E_ERROR, "Could not process __get call as static\n");
	}
	
	char parse_parameters_string[] = "s";
	
	if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name, &name_len ) == FAILURE)
	{
		RETVAL_NULL();
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Property to get: %s\n", name);
	php_printf("===========================================\n\n");
	#endif
	
	if(false){}
	else if(strcmp("left", name) == 0)
	{
	}
	else if(strcmp("top", name) == 0)
	{
	}
	else if(strcmp("right", name) == 0)
	{
	}
	else if(strcmp("bottom", name) == 0)
	{
	}
	else if(strcmp("width", name) == 0)
	{
	}
	else if(strcmp("height", name) == 0)
	{
	}
	else if(strcmp("centreX", name) == 0)
	{
	}
	else if(strcmp("centreY", name) == 0)
	{
	}
	else
	{
		RETVAL_NULL();
	}
}
/* {{{ proto bool wxLayoutConstraints::SatisfyConstraints(wxWindow &win, int &noChanges) */
PHP_METHOD(php_wxLayoutConstraints, SatisfyConstraints)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxLayoutConstraints::SatisfyConstraints\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxLayoutConstraints* current_object;
	wxphp_object_type current_object_type;
	wxLayoutConstraints_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxLayoutConstraints*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxLayoutConstraints::SatisfyConstraints call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXLAYOUTCONSTRAINTS_TYPE){
				references = &((wxLayoutConstraints_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* win0 = 0;
	wxWindow* object_pointer0_0 = 0;
	long* noChanges0;
	zval* noChanges0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl' (&win0, noChanges0)\n");
		#endif

		char parse_parameters_string[] = "zl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &win0, noChanges0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(win0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(win0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(win0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxWindow*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXPAGESETUPDIALOG_TYPE && argument_type != PHP_WXPRINTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'win' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(win0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'win' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &noChanges0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxLayoutConstraints::SatisfyConstraints((wxWindow*) object_pointer0_0, (int*) noChanges0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxLayoutConstraints_php*)native_object)->SatisfyConstraints((wxWindow*) object_pointer0_0, (int*) noChanges0));

				references->AddReference(win0, "wxLayoutConstraints::SatisfyConstraints at call with 2 argument(s)");
				size_t elements_returned0_1 = sizeof(noChanges0)/sizeof(*noChanges0);
				array_init(noChanges0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(noChanges0_ref, noChanges0[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxLayoutConstraints::SatisfyConstraints\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCellAttrProvider_free(void *object TSRMLS_DC) 
{
    zo_wxGridCellAttrProvider* custom_object = (zo_wxGridCellAttrProvider*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellAttrProvider_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCellAttrProvider done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCellAttrProvider_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCellAttrProvider_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCellAttrProvider* custom_object;
    custom_object = (zo_wxGridCellAttrProvider*) emalloc(sizeof(zo_wxGridCellAttrProvider));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCELLATTRPROVIDER_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCellAttrProvider_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto wxGridCellAttr wxGridCellAttrProvider::GetAttr(int row, int col, wxGridCellAttr::wxAttrKind kind)
   Get the attribute to use for the specified cell. */
PHP_METHOD(php_wxGridCellAttrProvider, GetAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttrProvider::GetAttr\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttrProvider* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttrProvider_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttrProvider*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttrProvider::GetAttr call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTRPROVIDER_TYPE){
				references = &((wxGridCellAttrProvider_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	long col0;
	long kind0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&row0, &col0, &kind0)\n");
		#endif

		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0, &col0, &kind0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttrProvider::GetAttr((int) row0, (int) col0, (wxGridCellAttr::wxAttrKind) kind0) to return object pointer\n\n");
				#endif

				wxGridCellAttr_php* value_to_return3;
				value_to_return3 = (wxGridCellAttr_php*) ((wxGridCellAttrProvider_php*)native_object)->GetAttr((int) row0, (int) col0, (wxGridCellAttr::wxAttrKind) kind0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxGridCellAttr_entry);
					((zo_wxGridCellAttr*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridCellAttr_php*) value_to_return3;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return3 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxGridCellAttrProvider::GetAttr at call with 3 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttrProvider::GetAttr\n");
	}
}
/* }}} */

/* {{{ proto wxGridColumnHeaderRenderer wxGridCellAttrProvider::GetColumnHeaderRenderer(int col)
   Getting header renderers. */
PHP_METHOD(php_wxGridCellAttrProvider, GetColumnHeaderRenderer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttrProvider::GetColumnHeaderRenderer\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttrProvider* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttrProvider_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttrProvider*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttrProvider::GetColumnHeaderRenderer call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTRPROVIDER_TYPE){
				references = &((wxGridCellAttrProvider_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&col0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttrProvider::GetColumnHeaderRenderer((int) col0) to return object reference\n\n");
				#endif

				wxGridColumnHeaderRenderer_php* value_to_return1;
				value_to_return1 = (wxGridColumnHeaderRenderer_php*) &((wxGridCellAttrProvider_php*)native_object)->GetColumnHeaderRenderer((int) col0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxGridColumnHeaderRenderer_entry);
					((zo_wxGridColumnHeaderRenderer*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridColumnHeaderRenderer_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxGridCellAttrProvider::GetColumnHeaderRenderer at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttrProvider::GetColumnHeaderRenderer\n");
	}
}
/* }}} */

/* {{{ proto wxGridCornerHeaderRenderer wxGridCellAttrProvider::GetCornerRenderer()
   Return the renderer used for drawing the corner window. */
PHP_METHOD(php_wxGridCellAttrProvider, GetCornerRenderer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttrProvider::GetCornerRenderer\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttrProvider* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttrProvider_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttrProvider*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttrProvider::GetCornerRenderer call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTRPROVIDER_TYPE){
				references = &((wxGridCellAttrProvider_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttrProvider::GetCornerRenderer() to return object reference\n\n");
				#endif

				wxGridCornerHeaderRenderer_php* value_to_return0;
				value_to_return0 = (wxGridCornerHeaderRenderer_php*) &((wxGridCellAttrProvider_php*)native_object)->GetCornerRenderer();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxGridCornerHeaderRenderer_entry);
					((zo_wxGridCornerHeaderRenderer*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridCornerHeaderRenderer_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxGridCellAttrProvider::GetCornerRenderer at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttrProvider::GetCornerRenderer\n");
	}
}
/* }}} */

/* {{{ proto wxGridRowHeaderRenderer wxGridCellAttrProvider::GetRowHeaderRenderer(int row)
   Return the renderer used for drawing row headers. */
PHP_METHOD(php_wxGridCellAttrProvider, GetRowHeaderRenderer)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttrProvider::GetRowHeaderRenderer\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttrProvider* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttrProvider_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttrProvider*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttrProvider::GetRowHeaderRenderer call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTRPROVIDER_TYPE){
				references = &((wxGridCellAttrProvider_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&row0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &row0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttrProvider::GetRowHeaderRenderer((int) row0) to return object reference\n\n");
				#endif

				wxGridRowHeaderRenderer_php* value_to_return1;
				value_to_return1 = (wxGridRowHeaderRenderer_php*) &((wxGridCellAttrProvider_php*)native_object)->GetRowHeaderRenderer((int) row0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxGridRowHeaderRenderer_entry);
					((zo_wxGridRowHeaderRenderer*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxGridRowHeaderRenderer_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxGridCellAttrProvider::GetRowHeaderRenderer at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttrProvider::GetRowHeaderRenderer\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttrProvider::SetAttr(wxGridCellAttr &attr, int row, int col)
   Setting attributes. */
PHP_METHOD(php_wxGridCellAttrProvider, SetAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttrProvider::SetAttr\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttrProvider* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttrProvider_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttrProvider*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttrProvider::SetAttr call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTRPROVIDER_TYPE){
				references = &((wxGridCellAttrProvider_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* attr0 = 0;
	wxGridCellAttr* object_pointer0_0 = 0;
	long row0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zll' (&attr0, &row0, &col0)\n");
		#endif

		char parse_parameters_string[] = "zll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &attr0, &row0, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(attr0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGridCellAttr*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRIDCELLATTR_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'attr' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(attr0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'attr' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttrProvider::SetAttr((wxGridCellAttr*) object_pointer0_0, (int) row0, (int) col0)\n\n");
				#endif

				((wxGridCellAttrProvider_php*)native_object)->SetAttr((wxGridCellAttr*) object_pointer0_0, (int) row0, (int) col0);

				references->AddReference(attr0, "wxGridCellAttrProvider::SetAttr at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttrProvider::SetAttr\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttrProvider::SetColAttr(wxGridCellAttr &attr, int col)
   Set attribute for the specified column. */
PHP_METHOD(php_wxGridCellAttrProvider, SetColAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttrProvider::SetColAttr\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttrProvider* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttrProvider_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttrProvider*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttrProvider::SetColAttr call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTRPROVIDER_TYPE){
				references = &((wxGridCellAttrProvider_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* attr0 = 0;
	wxGridCellAttr* object_pointer0_0 = 0;
	long col0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl' (&attr0, &col0)\n");
		#endif

		char parse_parameters_string[] = "zl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &attr0, &col0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(attr0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGridCellAttr*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRIDCELLATTR_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'attr' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(attr0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'attr' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttrProvider::SetColAttr((wxGridCellAttr*) object_pointer0_0, (int) col0)\n\n");
				#endif

				((wxGridCellAttrProvider_php*)native_object)->SetColAttr((wxGridCellAttr*) object_pointer0_0, (int) col0);

				references->AddReference(attr0, "wxGridCellAttrProvider::SetColAttr at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttrProvider::SetColAttr\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttrProvider::SetRowAttr(wxGridCellAttr &attr, int row)
   Set attribute for the specified row. */
PHP_METHOD(php_wxGridCellAttrProvider, SetRowAttr)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttrProvider::SetRowAttr\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttrProvider* current_object;
	wxphp_object_type current_object_type;
	wxGridCellAttrProvider_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCellAttrProvider*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCellAttrProvider::SetRowAttr call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCELLATTRPROVIDER_TYPE){
				references = &((wxGridCellAttrProvider_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* attr0 = 0;
	wxGridCellAttr* object_pointer0_0 = 0;
	long row0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zl' (&attr0, &row0)\n");
		#endif

		char parse_parameters_string[] = "zl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &attr0, &row0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(attr0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGridCellAttr*) zend_object_store_get_object(attr0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGridCellAttr*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXGRIDCELLATTR_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'attr' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(attr0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'attr' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCellAttrProvider::SetRowAttr((wxGridCellAttr*) object_pointer0_0, (int) row0)\n\n");
				#endif

				((wxGridCellAttrProvider_php*)native_object)->SetRowAttr((wxGridCellAttr*) object_pointer0_0, (int) row0);

				references->AddReference(attr0, "wxGridCellAttrProvider::SetRowAttr at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCellAttrProvider::SetRowAttr\n");
	}
}
/* }}} */

/* {{{ proto  wxGridCellAttrProvider::wxGridCellAttrProvider()
   Trivial default constructor. */
PHP_METHOD(php_wxGridCellAttrProvider, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCellAttrProvider::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCellAttrProvider* current_object;
	wxGridCellAttrProvider_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGridCellAttrProvider_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxGridCellAttrProvider*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGridCellAttrProvider::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridColumnHeaderRenderer_free(void *object TSRMLS_DC) 
{
    zo_wxGridColumnHeaderRenderer* custom_object = (zo_wxGridColumnHeaderRenderer*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridColumnHeaderRenderer_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridColumnHeaderRenderer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridColumnHeaderRenderer_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridColumnHeaderRenderer_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridColumnHeaderRenderer* custom_object;
    custom_object = (zo_wxGridColumnHeaderRenderer*) emalloc(sizeof(zo_wxGridColumnHeaderRenderer));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCOLUMNHEADERRENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridColumnHeaderRenderer_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxGridColumnHeaderRendererDefault_free(void *object TSRMLS_DC) 
{
    zo_wxGridColumnHeaderRendererDefault* custom_object = (zo_wxGridColumnHeaderRendererDefault*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridColumnHeaderRendererDefault_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridColumnHeaderRendererDefault done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridColumnHeaderRendererDefault_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridColumnHeaderRendererDefault_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridColumnHeaderRendererDefault* custom_object;
    custom_object = (zo_wxGridColumnHeaderRendererDefault*) emalloc(sizeof(zo_wxGridColumnHeaderRendererDefault));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCOLUMNHEADERRENDERERDEFAULT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridColumnHeaderRendererDefault_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridColumnHeaderRendererDefault::DrawBorder(wxGrid grid, wxDC &dc, wxRect &rect)
   Implement border drawing for the column labels. */
PHP_METHOD(php_wxGridColumnHeaderRendererDefault, DrawBorder)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridColumnHeaderRendererDefault::DrawBorder\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridColumnHeaderRendererDefault* current_object;
	wxphp_object_type current_object_type;
	wxGridColumnHeaderRendererDefault_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridColumnHeaderRendererDefault*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridColumnHeaderRendererDefault::DrawBorder call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCOLUMNHEADERRENDERERDEFAULT_TYPE){
				references = &((wxGridColumnHeaderRendererDefault_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* grid0 = 0;
	wxGrid* object_pointer0_0 = 0;
	zval* dc0 = 0;
	wxDC* object_pointer0_1 = 0;
	zval* rect0 = 0;
	wxRect* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OOO' (&grid0, php_wxGrid_entry, &dc0, php_wxDC_entry, &rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "OOO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &grid0, php_wxGrid_entry, &dc0, php_wxDC_entry, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(grid0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGrid*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'grid' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(grid0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'grid' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(dc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxDC*) argument_native_object;
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxRect*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridColumnHeaderRendererDefault::DrawBorder(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, *(wxRect*) object_pointer0_2)\n\n");
				#endif

				if(current_object_type == PHP_WXGRIDCOLUMNHEADERRENDERERDEFAULT_TYPE)
				{
					((wxGridColumnHeaderRendererDefault_php*)native_object)->DrawBorder(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, *(wxRect*) object_pointer0_2);
				}

				references->AddReference(grid0, "wxGridColumnHeaderRendererDefault::DrawBorder at call with 3 argument(s)");
				references->AddReference(dc0, "wxGridColumnHeaderRendererDefault::DrawBorder at call with 3 argument(s)");
				references->AddReference(rect0, "wxGridColumnHeaderRendererDefault::DrawBorder at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridColumnHeaderRendererDefault::DrawBorder\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCornerHeaderRenderer_free(void *object TSRMLS_DC) 
{
    zo_wxGridCornerHeaderRenderer* custom_object = (zo_wxGridCornerHeaderRenderer*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCornerHeaderRenderer_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCornerHeaderRenderer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCornerHeaderRenderer_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCornerHeaderRenderer_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCornerHeaderRenderer* custom_object;
    custom_object = (zo_wxGridCornerHeaderRenderer*) emalloc(sizeof(zo_wxGridCornerHeaderRenderer));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCORNERHEADERRENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCornerHeaderRenderer_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridCornerHeaderRenderer::DrawBorder(wxGrid grid, wxDC &dc, wxRect &rect)
   Called by the grid to draw the corner window border. */
void wxGridCornerHeaderRenderer_php::DrawBorder(const wxGrid& grid, wxDC& dc, wxRect& rect)const
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxGridCornerHeaderRenderer::DrawBorder\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[3];
	zval *arguments[3];
	
	//Initilize arguments array
	for(int i=0; i<3; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawBorder", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxGrid_entry);
	((zo_wxGrid*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxGrid_php*) &grid;
	object_init_ex(arguments[1], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
		
	for(int i=0; i<3; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawBorder", 10, &return_value, 3, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<3; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxGridCornerHeaderRenderer::DrawBorder'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridCornerHeaderRendererDefault_free(void *object TSRMLS_DC) 
{
    zo_wxGridCornerHeaderRendererDefault* custom_object = (zo_wxGridCornerHeaderRendererDefault*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCornerHeaderRendererDefault_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridCornerHeaderRendererDefault done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridCornerHeaderRendererDefault_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridCornerHeaderRendererDefault_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridCornerHeaderRendererDefault* custom_object;
    custom_object = (zo_wxGridCornerHeaderRendererDefault*) emalloc(sizeof(zo_wxGridCornerHeaderRendererDefault));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDCORNERHEADERRENDERERDEFAULT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridCornerHeaderRendererDefault_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridCornerHeaderRendererDefault::DrawBorder(wxGrid grid, wxDC &dc, wxRect &rect)
   Implement border drawing for the corner window. */
PHP_METHOD(php_wxGridCornerHeaderRendererDefault, DrawBorder)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridCornerHeaderRendererDefault::DrawBorder\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridCornerHeaderRendererDefault* current_object;
	wxphp_object_type current_object_type;
	wxGridCornerHeaderRendererDefault_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridCornerHeaderRendererDefault*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridCornerHeaderRendererDefault::DrawBorder call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDCORNERHEADERRENDERERDEFAULT_TYPE){
				references = &((wxGridCornerHeaderRendererDefault_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* grid0 = 0;
	wxGrid* object_pointer0_0 = 0;
	zval* dc0 = 0;
	wxDC* object_pointer0_1 = 0;
	zval* rect0 = 0;
	wxRect* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OOO' (&grid0, php_wxGrid_entry, &dc0, php_wxDC_entry, &rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "OOO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &grid0, php_wxGrid_entry, &dc0, php_wxDC_entry, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(grid0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGrid*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'grid' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(grid0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'grid' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(dc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxDC*) argument_native_object;
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxRect*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridCornerHeaderRendererDefault::DrawBorder(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, *(wxRect*) object_pointer0_2)\n\n");
				#endif

				if(current_object_type == PHP_WXGRIDCORNERHEADERRENDERERDEFAULT_TYPE)
				{
					((wxGridCornerHeaderRendererDefault_php*)native_object)->DrawBorder(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, *(wxRect*) object_pointer0_2);
				}

				references->AddReference(grid0, "wxGridCornerHeaderRendererDefault::DrawBorder at call with 3 argument(s)");
				references->AddReference(dc0, "wxGridCornerHeaderRendererDefault::DrawBorder at call with 3 argument(s)");
				references->AddReference(rect0, "wxGridCornerHeaderRendererDefault::DrawBorder at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridCornerHeaderRendererDefault::DrawBorder\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridHeaderLabelsRenderer_free(void *object TSRMLS_DC) 
{
    zo_wxGridHeaderLabelsRenderer* custom_object = (zo_wxGridHeaderLabelsRenderer*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridHeaderLabelsRenderer_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridHeaderLabelsRenderer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridHeaderLabelsRenderer_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridHeaderLabelsRenderer_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridHeaderLabelsRenderer* custom_object;
    custom_object = (zo_wxGridHeaderLabelsRenderer*) emalloc(sizeof(zo_wxGridHeaderLabelsRenderer));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDHEADERLABELSRENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridHeaderLabelsRenderer_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridHeaderLabelsRenderer::DrawLabel(wxGrid grid, wxDC &dc, string value, wxRect rect, int horizAlign, int vertAlign, int textOrientation)
   Called by the grid to draw the specified label. */
PHP_METHOD(php_wxGridHeaderLabelsRenderer, DrawLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridHeaderLabelsRenderer::DrawLabel\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridHeaderLabelsRenderer* current_object;
	wxphp_object_type current_object_type;
	wxGridHeaderLabelsRenderer_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridHeaderLabelsRenderer*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridHeaderLabelsRenderer::DrawLabel call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDHEADERLABELSRENDERER_TYPE){
				references = &((wxGridHeaderLabelsRenderer_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCOLUMNHEADERRENDERER_TYPE) && (!reference_type_found)){
				references = &((wxGridColumnHeaderRenderer_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDCOLUMNHEADERRENDERERDEFAULT_TYPE) && (!reference_type_found)){
				references = &((wxGridColumnHeaderRendererDefault_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDROWHEADERRENDERER_TYPE) && (!reference_type_found)){
				references = &((wxGridRowHeaderRenderer_php*)native_object)->references;
				reference_type_found = true;
			}
			if((current_object_type == PHP_WXGRIDROWHEADERRENDERERDEFAULT_TYPE) && (!reference_type_found)){
				references = &((wxGridRowHeaderRendererDefault_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* grid0 = 0;
	wxGrid* object_pointer0_0 = 0;
	zval* dc0 = 0;
	wxDC* object_pointer0_1 = 0;
	char* value0;
	long value_len0;
	zval* rect0 = 0;
	wxRect* object_pointer0_3 = 0;
	long horizAlign0;
	long vertAlign0;
	long textOrientation0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OOsOlll' (&grid0, php_wxGrid_entry, &dc0, php_wxDC_entry, &value0, &value_len0, &rect0, php_wxRect_entry, &horizAlign0, &vertAlign0, &textOrientation0)\n");
		#endif

		char parse_parameters_string[] = "OOsOlll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &grid0, php_wxGrid_entry, &dc0, php_wxDC_entry, &value0, &value_len0, &rect0, php_wxRect_entry, &horizAlign0, &vertAlign0, &textOrientation0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(grid0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGrid*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'grid' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(grid0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'grid' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(dc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxDC*) argument_native_object;
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_3 = (wxRect*) argument_native_object;
					if (!object_pointer0_3 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridHeaderLabelsRenderer::DrawLabel(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, wxString(value0, wxConvUTF8), *(wxRect*) object_pointer0_3, (int) horizAlign0, (int) vertAlign0, (int) textOrientation0)\n\n");
				#endif

				if(current_object_type == PHP_WXGRIDCOLUMNHEADERRENDERER_TYPE)
				{
					((wxGridColumnHeaderRenderer_php*)native_object)->DrawLabel(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, wxString(value0, wxConvUTF8), *(wxRect*) object_pointer0_3, (int) horizAlign0, (int) vertAlign0, (int) textOrientation0);
				}
				else if(current_object_type == PHP_WXGRIDCOLUMNHEADERRENDERERDEFAULT_TYPE)
				{
					((wxGridColumnHeaderRendererDefault_php*)native_object)->DrawLabel(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, wxString(value0, wxConvUTF8), *(wxRect*) object_pointer0_3, (int) horizAlign0, (int) vertAlign0, (int) textOrientation0);
				}
				else if(current_object_type == PHP_WXGRIDROWHEADERRENDERER_TYPE)
				{
					((wxGridRowHeaderRenderer_php*)native_object)->DrawLabel(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, wxString(value0, wxConvUTF8), *(wxRect*) object_pointer0_3, (int) horizAlign0, (int) vertAlign0, (int) textOrientation0);
				}
				else if(current_object_type == PHP_WXGRIDROWHEADERRENDERERDEFAULT_TYPE)
				{
					((wxGridRowHeaderRendererDefault_php*)native_object)->DrawLabel(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, wxString(value0, wxConvUTF8), *(wxRect*) object_pointer0_3, (int) horizAlign0, (int) vertAlign0, (int) textOrientation0);
				}
				else if(current_object_type == PHP_WXGRIDHEADERLABELSRENDERER_TYPE)
				{
					((wxGridHeaderLabelsRenderer_php*)native_object)->DrawLabel(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, wxString(value0, wxConvUTF8), *(wxRect*) object_pointer0_3, (int) horizAlign0, (int) vertAlign0, (int) textOrientation0);
				}

				references->AddReference(grid0, "wxGridHeaderLabelsRenderer::DrawLabel at call with 7 argument(s)");
				references->AddReference(dc0, "wxGridHeaderLabelsRenderer::DrawLabel at call with 7 argument(s)");
				references->AddReference(rect0, "wxGridHeaderLabelsRenderer::DrawLabel at call with 7 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridHeaderLabelsRenderer::DrawLabel\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGridRowHeaderRenderer_free(void *object TSRMLS_DC) 
{
    zo_wxGridRowHeaderRenderer* custom_object = (zo_wxGridRowHeaderRenderer*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridRowHeaderRenderer_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridRowHeaderRenderer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridRowHeaderRenderer_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridRowHeaderRenderer_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridRowHeaderRenderer* custom_object;
    custom_object = (zo_wxGridRowHeaderRenderer*) emalloc(sizeof(zo_wxGridRowHeaderRenderer));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDROWHEADERRENDERER_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridRowHeaderRenderer_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxGridRowHeaderRendererDefault_free(void *object TSRMLS_DC) 
{
    zo_wxGridRowHeaderRendererDefault* custom_object = (zo_wxGridRowHeaderRendererDefault*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridRowHeaderRendererDefault_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGridRowHeaderRendererDefault done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGridRowHeaderRendererDefault_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGridRowHeaderRendererDefault_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGridRowHeaderRendererDefault* custom_object;
    custom_object = (zo_wxGridRowHeaderRendererDefault*) emalloc(sizeof(zo_wxGridRowHeaderRendererDefault));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXGRIDROWHEADERRENDERERDEFAULT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGridRowHeaderRendererDefault_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGridRowHeaderRendererDefault::DrawBorder(wxGrid grid, wxDC &dc, wxRect &rect)
   Implement border drawing for the row labels. */
PHP_METHOD(php_wxGridRowHeaderRendererDefault, DrawBorder)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGridRowHeaderRendererDefault::DrawBorder\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGridRowHeaderRendererDefault* current_object;
	wxphp_object_type current_object_type;
	wxGridRowHeaderRendererDefault_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGridRowHeaderRendererDefault*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGridRowHeaderRendererDefault::DrawBorder call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRIDROWHEADERRENDERERDEFAULT_TYPE){
				references = &((wxGridRowHeaderRendererDefault_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* grid0 = 0;
	wxGrid* object_pointer0_0 = 0;
	zval* dc0 = 0;
	wxDC* object_pointer0_1 = 0;
	zval* rect0 = 0;
	wxRect* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OOO' (&grid0, php_wxGrid_entry, &dc0, php_wxDC_entry, &rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "OOO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &grid0, php_wxGrid_entry, &dc0, php_wxDC_entry, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(grid0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGrid*) zend_object_store_get_object(grid0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGrid*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'grid' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(grid0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'grid' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(dc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxDC*) argument_native_object;
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxRect*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGridRowHeaderRendererDefault::DrawBorder(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, *(wxRect*) object_pointer0_2)\n\n");
				#endif

				if(current_object_type == PHP_WXGRIDROWHEADERRENDERERDEFAULT_TYPE)
				{
					((wxGridRowHeaderRendererDefault_php*)native_object)->DrawBorder(*(wxGrid*) object_pointer0_0, *(wxDC*) object_pointer0_1, *(wxRect*) object_pointer0_2);
				}

				references->AddReference(grid0, "wxGridRowHeaderRendererDefault::DrawBorder at call with 3 argument(s)");
				references->AddReference(dc0, "wxGridRowHeaderRendererDefault::DrawBorder at call with 3 argument(s)");
				references->AddReference(rect0, "wxGridRowHeaderRendererDefault::DrawBorder at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGridRowHeaderRendererDefault::DrawBorder\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPaletteChangedEvent_free(void *object TSRMLS_DC) 
{
    zo_wxPaletteChangedEvent* custom_object = (zo_wxPaletteChangedEvent*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPaletteChangedEvent_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxPaletteChangedEvent done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxPaletteChangedEvent_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPaletteChangedEvent_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxPaletteChangedEvent* custom_object;
    custom_object = (zo_wxPaletteChangedEvent*) emalloc(sizeof(zo_wxPaletteChangedEvent));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXPALETTECHANGEDEVENT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxPaletteChangedEvent_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto wxWindow wxPaletteChangedEvent::GetChangedWindow() */
PHP_METHOD(php_wxPaletteChangedEvent, GetChangedWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPaletteChangedEvent::GetChangedWindow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPaletteChangedEvent* current_object;
	wxphp_object_type current_object_type;
	wxPaletteChangedEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPaletteChangedEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPaletteChangedEvent::GetChangedWindow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPALETTECHANGEDEVENT_TYPE){
				references = &((wxPaletteChangedEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPaletteChangedEvent::GetChangedWindow() to return object pointer\n\n");
				#endif

				wxWindow_php* value_to_return0;
				value_to_return0 = (wxWindow_php*) ((wxPaletteChangedEvent_php*)native_object)->GetChangedWindow();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxWindow_entry);
					((zo_wxWindow*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxWindow_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxPaletteChangedEvent::GetChangedWindow at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPaletteChangedEvent::GetChangedWindow\n");
	}
}
/* }}} */

/* {{{ proto  wxPaletteChangedEvent::SetChangedWindow(wxWindow &win) */
PHP_METHOD(php_wxPaletteChangedEvent, SetChangedWindow)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPaletteChangedEvent::SetChangedWindow\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPaletteChangedEvent* current_object;
	wxphp_object_type current_object_type;
	wxPaletteChangedEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPaletteChangedEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPaletteChangedEvent::SetChangedWindow call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPALETTECHANGEDEVENT_TYPE){
				references = &((wxPaletteChangedEvent_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* win0 = 0;
	wxWindow* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&win0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &win0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(win0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxWindow*) zend_object_store_get_object(win0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxWindow*) zend_object_store_get_object(win0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxWindow*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXPAGESETUPDIALOG_TYPE && argument_type != PHP_WXPRINTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'win' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(win0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'win' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPaletteChangedEvent::SetChangedWindow((wxWindow*) object_pointer0_0)\n\n");
				#endif

				((wxPaletteChangedEvent_php*)native_object)->SetChangedWindow((wxWindow*) object_pointer0_0);

				references->AddReference(win0, "wxPaletteChangedEvent::SetChangedWindow at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPaletteChangedEvent::SetChangedWindow\n");
	}
}
/* }}} */

/* {{{ proto  wxPaletteChangedEvent::wxPaletteChangedEvent(int winid) */
PHP_METHOD(php_wxPaletteChangedEvent, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPaletteChangedEvent::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPaletteChangedEvent* current_object;
	wxPaletteChangedEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	long winid0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&winid0)\n");
		#endif

		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &winid0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxPaletteChangedEvent_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((wxWindowID) winid0)\n");
				#endif

				native_object = new wxPaletteChangedEvent_php((wxWindowID) winid0);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxPaletteChangedEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxPaletteChangedEvent::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFileTypeInfo_free(void *object TSRMLS_DC) 
{
    zo_wxFileTypeInfo* custom_object = (zo_wxFileTypeInfo*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFileTypeInfo_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxFileTypeInfo done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxFileTypeInfo_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFileTypeInfo_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxFileTypeInfo* custom_object;
    custom_object = (zo_wxFileTypeInfo*) emalloc(sizeof(zo_wxFileTypeInfo));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXFILETYPEINFO_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxFileTypeInfo_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxFileTypeInfo::AddExtension(string ext)
   Add another extension associated with this file type. */
PHP_METHOD(php_wxFileTypeInfo, AddExtension)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileTypeInfo::AddExtension\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileTypeInfo* current_object;
	wxphp_object_type current_object_type;
	wxFileTypeInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileTypeInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileTypeInfo::AddExtension call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILETYPEINFO_TYPE){
				references = &((wxFileTypeInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* ext0;
	long ext_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&ext0, &ext_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &ext0, &ext_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileTypeInfo::AddExtension(wxString(ext0, wxConvUTF8))\n\n");
				#endif

				((wxFileTypeInfo_php*)native_object)->AddExtension(wxString(ext0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileTypeInfo::AddExtension\n");
	}
}
/* }}} */

/* {{{ proto  wxFileTypeInfo::SetDescription(string description)
   Set the file type description. */
PHP_METHOD(php_wxFileTypeInfo, SetDescription)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileTypeInfo::SetDescription\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileTypeInfo* current_object;
	wxphp_object_type current_object_type;
	wxFileTypeInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileTypeInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileTypeInfo::SetDescription call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILETYPEINFO_TYPE){
				references = &((wxFileTypeInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* description0;
	long description_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&description0, &description_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &description0, &description_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileTypeInfo::SetDescription(wxString(description0, wxConvUTF8))\n\n");
				#endif

				((wxFileTypeInfo_php*)native_object)->SetDescription(wxString(description0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileTypeInfo::SetDescription\n");
	}
}
/* }}} */

/* {{{ proto  wxFileTypeInfo::SetOpenCommand(string command)
   Set the command to be used for opening files of this type. */
PHP_METHOD(php_wxFileTypeInfo, SetOpenCommand)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileTypeInfo::SetOpenCommand\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileTypeInfo* current_object;
	wxphp_object_type current_object_type;
	wxFileTypeInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileTypeInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileTypeInfo::SetOpenCommand call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILETYPEINFO_TYPE){
				references = &((wxFileTypeInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* command0;
	long command_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&command0, &command_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &command0, &command_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileTypeInfo::SetOpenCommand(wxString(command0, wxConvUTF8))\n\n");
				#endif

				((wxFileTypeInfo_php*)native_object)->SetOpenCommand(wxString(command0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileTypeInfo::SetOpenCommand\n");
	}
}
/* }}} */

/* {{{ proto  wxFileTypeInfo::SetPrintCommand(string command)
   Set the command to be used for printing files of this type. */
PHP_METHOD(php_wxFileTypeInfo, SetPrintCommand)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileTypeInfo::SetPrintCommand\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileTypeInfo* current_object;
	wxphp_object_type current_object_type;
	wxFileTypeInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileTypeInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileTypeInfo::SetPrintCommand call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILETYPEINFO_TYPE){
				references = &((wxFileTypeInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* command0;
	long command_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&command0, &command_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &command0, &command_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileTypeInfo::SetPrintCommand(wxString(command0, wxConvUTF8))\n\n");
				#endif

				((wxFileTypeInfo_php*)native_object)->SetPrintCommand(wxString(command0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileTypeInfo::SetPrintCommand\n");
	}
}
/* }}} */

/* {{{ proto  wxFileTypeInfo::SetShortDesc(string shortDesc)
   Set the short description for the files of this type. */
PHP_METHOD(php_wxFileTypeInfo, SetShortDesc)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileTypeInfo::SetShortDesc\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileTypeInfo* current_object;
	wxphp_object_type current_object_type;
	wxFileTypeInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFileTypeInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFileTypeInfo::SetShortDesc call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFILETYPEINFO_TYPE){
				references = &((wxFileTypeInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* shortDesc0;
	long shortDesc_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&shortDesc0, &shortDesc_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &shortDesc0, &shortDesc_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFileTypeInfo::SetShortDesc(wxString(shortDesc0, wxConvUTF8))\n\n");
				#endif

				((wxFileTypeInfo_php*)native_object)->SetShortDesc(wxString(shortDesc0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFileTypeInfo::SetShortDesc\n");
	}
}
/* }}} */

/* {{{ proto  wxFileTypeInfo::wxFileTypeInfo()
   Default constructor creates an invalid file type info object. */
PHP_METHOD(php_wxFileTypeInfo, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFileTypeInfo::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFileTypeInfo* current_object;
	wxFileTypeInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	char* mimeType1;
	long mimeType_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&mimeType1, &mimeType_len1)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &mimeType1, &mimeType_len1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxFileTypeInfo_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(mimeType1, wxConvUTF8))\n");
				#endif

				native_object = new wxFileTypeInfo_php(wxString(mimeType1, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxFileTypeInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxFileTypeInfo::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxDisplayChangedEvent_free(void *object TSRMLS_DC) 
{
    zo_wxDisplayChangedEvent* custom_object = (zo_wxDisplayChangedEvent*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxDisplayChangedEvent_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxDisplayChangedEvent done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxDisplayChangedEvent_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxDisplayChangedEvent_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxDisplayChangedEvent* custom_object;
    custom_object = (zo_wxDisplayChangedEvent*) emalloc(sizeof(zo_wxDisplayChangedEvent));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXDISPLAYCHANGEDEVENT_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxDisplayChangedEvent_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxDisplayChangedEvent::wxDisplayChangedEvent() */
PHP_METHOD(php_wxDisplayChangedEvent, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDisplayChangedEvent::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDisplayChangedEvent* current_object;
	wxDisplayChangedEvent_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxDisplayChangedEvent_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxDisplayChangedEvent*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxDisplayChangedEvent::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxTimerRunner_free(void *object TSRMLS_DC) 
{
    zo_wxTimerRunner* custom_object = (zo_wxTimerRunner*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTimerRunner_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxTimerRunner done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxTimerRunner_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTimerRunner_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxTimerRunner* custom_object;
    custom_object = (zo_wxTimerRunner*) emalloc(sizeof(zo_wxTimerRunner));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXTIMERRUNNER_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxTimerRunner_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxTimerRunner::Start(int milli, bool oneShot) */
PHP_METHOD(php_wxTimerRunner, Start)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTimerRunner::Start\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTimerRunner* current_object;
	wxphp_object_type current_object_type;
	wxTimerRunner_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxTimerRunner*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxTimerRunner::Start call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTIMERRUNNER_TYPE){
				references = &((wxTimerRunner_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long milli0;
	bool oneShot0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (&milli0, &oneShot0)\n");
		#endif

		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &milli0, &oneShot0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTimerRunner::Start((int) milli0)\n\n");
				#endif

				((wxTimerRunner_php*)native_object)->Start((int) milli0);


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxTimerRunner::Start((int) milli0, oneShot0)\n\n");
				#endif

				((wxTimerRunner_php*)native_object)->Start((int) milli0, oneShot0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxTimerRunner::Start\n");
	}
}
/* }}} */

/* {{{ proto  wxTimerRunner::wxTimerRunner(wxTimer &timer) */
PHP_METHOD(php_wxTimerRunner, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxTimerRunner::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxTimerRunner* current_object;
	wxTimerRunner_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* timer0 = 0;
	wxTimer* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* timer1 = 0;
	wxTimer* object_pointer1_0 = 0;
	long milli1;
	bool oneShot1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&timer0, php_wxTimer_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &timer0, php_wxTimer_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(timer0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxTimer*) zend_object_store_get_object(timer0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxTimer*) zend_object_store_get_object(timer0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxTimer*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(timer0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|b' (&timer1, php_wxTimer_entry, &milli1, &oneShot1)\n");
		#endif

		char parse_parameters_string[] = "Ol|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &timer1, php_wxTimer_entry, &milli1, &oneShot1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(timer1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxTimer*) zend_object_store_get_object(timer1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxTimer*) zend_object_store_get_object(timer1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxTimer*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'timer' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(timer1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'timer' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxTimer*) object_pointer0_0)\n");
				#endif

				native_object = new wxTimerRunner_php(*(wxTimer*) object_pointer0_0);

				native_object->references.Initialize();
				((wxTimerRunner_php*) native_object)->references.AddReference(timer0, "wxTimerRunner::wxTimerRunner at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxTimer*) object_pointer1_0, (int) milli1)\n");
				#endif

				native_object = new wxTimerRunner_php(*(wxTimer*) object_pointer1_0, (int) milli1);

				native_object->references.Initialize();
				((wxTimerRunner_php*) native_object)->references.AddReference(timer1, "wxTimerRunner::wxTimerRunner at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxTimer*) object_pointer1_0, (int) milli1, oneShot1)\n");
				#endif

				native_object = new wxTimerRunner_php(*(wxTimer*) object_pointer1_0, (int) milli1, oneShot1);

				native_object->references.Initialize();
				((wxTimerRunner_php*) native_object)->references.AddReference(timer1, "wxTimerRunner::wxTimerRunner at call with 3 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		
		native_object->InitProperties();
		
		current_object = (zo_wxTimerRunner*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxTimerRunner::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxToolBarToolBase_free(void *object TSRMLS_DC) 
{
    zo_wxToolBarToolBase* custom_object = (zo_wxToolBarToolBase*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxToolBarToolBase_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxToolBarToolBase done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxToolBarToolBase_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxToolBarToolBase_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxToolBarToolBase* custom_object;
    custom_object = (zo_wxToolBarToolBase*) emalloc(sizeof(zo_wxToolBarToolBase));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXTOOLBARTOOLBASE_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxToolBarToolBase_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxToolBarToolBase::Detach() */
PHP_METHOD(php_wxToolBarToolBase, Detach)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::Detach\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::Detach call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxToolBarToolBase::Detach()\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					((wxToolBarToolBase_php*)native_object)->Detach();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::Detach\n");
	}
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::CanBeToggled() */
PHP_METHOD(php_wxToolBarToolBase, CanBeToggled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::CanBeToggled\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::CanBeToggled call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToolBarToolBase::CanBeToggled())\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxToolBarToolBase_php*)native_object)->CanBeToggled());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::CanBeToggled\n");
	}
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::Enable(bool enable) */
PHP_METHOD(php_wxToolBarToolBase, Enable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::Enable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::Enable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool enable0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&enable0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &enable0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToolBarToolBase::Enable(enable0))\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxToolBarToolBase_php*)native_object)->Enable(enable0));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::Enable\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxToolBarToolBase::GetBitmap() */
PHP_METHOD(php_wxToolBarToolBase, GetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::GetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::GetBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxToolBarToolBase::GetBitmap() to return object reference\n\n");
				#endif

				wxBitmap_php* value_to_return0;
				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					value_to_return0 = (wxBitmap_php*) &((wxToolBarToolBase_php*)native_object)->GetBitmap();

				}
				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					((zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmap_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxToolBarToolBase::GetBitmap at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::GetBitmap\n");
	}
}
/* }}} */

/* {{{ proto wxObject wxToolBarToolBase::GetClientData() */
PHP_METHOD(php_wxToolBarToolBase, GetClientData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::GetClientData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::GetClientData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxToolBarToolBase::GetClientData() to return object pointer\n\n");
				#endif

				wxObject_php* value_to_return0;
				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					value_to_return0 = (wxObject_php*) ((wxToolBarToolBase_php*)native_object)->GetClientData();

				}
				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxObject_entry);
					((zo_wxObject*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxObject_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxToolBarToolBase::GetClientData at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::GetClientData\n");
	}
}
/* }}} */

/* {{{ proto wxControl wxToolBarToolBase::GetControl() */
PHP_METHOD(php_wxToolBarToolBase, GetControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::GetControl\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::GetControl call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxToolBarToolBase::GetControl() to return object pointer\n\n");
				#endif

				wxControl_php* value_to_return0;
				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					value_to_return0 = (wxControl_php*) ((wxToolBarToolBase_php*)native_object)->GetControl();

				}
				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxControl_entry);
					((zo_wxControl*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxControl_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxToolBarToolBase::GetControl at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::GetControl\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxToolBarToolBase::GetDisabledBitmap() */
PHP_METHOD(php_wxToolBarToolBase, GetDisabledBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::GetDisabledBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::GetDisabledBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxToolBarToolBase::GetDisabledBitmap() to return object reference\n\n");
				#endif

				wxBitmap_php* value_to_return0;
				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					value_to_return0 = (wxBitmap_php*) &((wxToolBarToolBase_php*)native_object)->GetDisabledBitmap();

				}
				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					((zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmap_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxToolBarToolBase::GetDisabledBitmap at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::GetDisabledBitmap\n");
	}
}
/* }}} */

/* {{{ proto wxMenu wxToolBarToolBase::GetDropdownMenu() */
PHP_METHOD(php_wxToolBarToolBase, GetDropdownMenu)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::GetDropdownMenu\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::GetDropdownMenu call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxToolBarToolBase::GetDropdownMenu() to return object pointer\n\n");
				#endif

				wxMenu_php* value_to_return0;
				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					value_to_return0 = (wxMenu_php*) ((wxToolBarToolBase_php*)native_object)->GetDropdownMenu();

				}
				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxMenu_entry);
					((zo_wxMenu*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxMenu_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxToolBarToolBase::GetDropdownMenu at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::GetDropdownMenu\n");
	}
}
/* }}} */

/* {{{ proto int wxToolBarToolBase::GetId() */
PHP_METHOD(php_wxToolBarToolBase, GetId)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::GetId\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::GetId call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxToolBarToolBase::GetId())\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					ZVAL_LONG(return_value, ((wxToolBarToolBase_php*)native_object)->GetId());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::GetId\n");
	}
}
/* }}} */

/* {{{ proto wxItemKind wxToolBarToolBase::GetKind() */
PHP_METHOD(php_wxToolBarToolBase, GetKind)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::GetKind\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::GetKind call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxToolBarToolBase::GetKind())\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					ZVAL_LONG(return_value, ((wxToolBarToolBase_php*)native_object)->GetKind());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::GetKind\n");
	}
}
/* }}} */

/* {{{ proto string wxToolBarToolBase::GetLabel() */
PHP_METHOD(php_wxToolBarToolBase, GetLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::GetLabel\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::GetLabel call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxToolBarToolBase::GetLabel().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					value_to_return0 = ((wxToolBarToolBase_php*)native_object)->GetLabel();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::GetLabel\n");
	}
}
/* }}} */

/* {{{ proto string wxToolBarToolBase::GetLongHelp() */
PHP_METHOD(php_wxToolBarToolBase, GetLongHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::GetLongHelp\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::GetLongHelp call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxToolBarToolBase::GetLongHelp().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					value_to_return0 = ((wxToolBarToolBase_php*)native_object)->GetLongHelp();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::GetLongHelp\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxToolBarToolBase::GetNormalBitmap() */
PHP_METHOD(php_wxToolBarToolBase, GetNormalBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::GetNormalBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::GetNormalBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxToolBarToolBase::GetNormalBitmap() to return object reference\n\n");
				#endif

				wxBitmap_php* value_to_return0;
				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					value_to_return0 = (wxBitmap_php*) &((wxToolBarToolBase_php*)native_object)->GetNormalBitmap();

				}
				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxBitmap_entry);
					((zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmap_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxToolBarToolBase::GetNormalBitmap at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::GetNormalBitmap\n");
	}
}
/* }}} */

/* {{{ proto string wxToolBarToolBase::GetShortHelp() */
PHP_METHOD(php_wxToolBarToolBase, GetShortHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::GetShortHelp\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::GetShortHelp call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxToolBarToolBase::GetShortHelp().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					value_to_return0 = ((wxToolBarToolBase_php*)native_object)->GetShortHelp();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::GetShortHelp\n");
	}
}
/* }}} */

/* {{{ proto int wxToolBarToolBase::GetStyle() */
PHP_METHOD(php_wxToolBarToolBase, GetStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::GetStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::GetStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxToolBarToolBase::GetStyle())\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					ZVAL_LONG(return_value, ((wxToolBarToolBase_php*)native_object)->GetStyle());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::GetStyle\n");
	}
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::IsButton() */
PHP_METHOD(php_wxToolBarToolBase, IsButton)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::IsButton\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::IsButton call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToolBarToolBase::IsButton())\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxToolBarToolBase_php*)native_object)->IsButton());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::IsButton\n");
	}
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::IsControl() */
PHP_METHOD(php_wxToolBarToolBase, IsControl)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::IsControl\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::IsControl call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToolBarToolBase::IsControl())\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxToolBarToolBase_php*)native_object)->IsControl());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::IsControl\n");
	}
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::IsEnabled() */
PHP_METHOD(php_wxToolBarToolBase, IsEnabled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::IsEnabled\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::IsEnabled call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToolBarToolBase::IsEnabled())\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxToolBarToolBase_php*)native_object)->IsEnabled());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::IsEnabled\n");
	}
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::IsSeparator() */
PHP_METHOD(php_wxToolBarToolBase, IsSeparator)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::IsSeparator\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::IsSeparator call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToolBarToolBase::IsSeparator())\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxToolBarToolBase_php*)native_object)->IsSeparator());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::IsSeparator\n");
	}
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::IsStretchable() */
PHP_METHOD(php_wxToolBarToolBase, IsStretchable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::IsStretchable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::IsStretchable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToolBarToolBase::IsStretchable())\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxToolBarToolBase_php*)native_object)->IsStretchable());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::IsStretchable\n");
	}
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::IsStretchableSpace() */
PHP_METHOD(php_wxToolBarToolBase, IsStretchableSpace)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::IsStretchableSpace\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::IsStretchableSpace call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToolBarToolBase::IsStretchableSpace())\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxToolBarToolBase_php*)native_object)->IsStretchableSpace());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::IsStretchableSpace\n");
	}
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::IsToggled() */
PHP_METHOD(php_wxToolBarToolBase, IsToggled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::IsToggled\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::IsToggled call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToolBarToolBase::IsToggled())\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxToolBarToolBase_php*)native_object)->IsToggled());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::IsToggled\n");
	}
}
/* }}} */

/* {{{ proto  wxToolBarToolBase::MakeStretchable() */
PHP_METHOD(php_wxToolBarToolBase, MakeStretchable)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::MakeStretchable\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::MakeStretchable call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxToolBarToolBase::MakeStretchable()\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					((wxToolBarToolBase_php*)native_object)->MakeStretchable();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::MakeStretchable\n");
	}
}
/* }}} */

/* {{{ proto  wxToolBarToolBase::SetDropdownMenu(wxMenu &menu) */
PHP_METHOD(php_wxToolBarToolBase, SetDropdownMenu)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::SetDropdownMenu\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::SetDropdownMenu call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* menu0 = 0;
	wxMenu* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&menu0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &menu0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(menu0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxMenu*) zend_object_store_get_object(menu0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxMenu*) zend_object_store_get_object(menu0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxMenu*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXMENU_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'menu' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(menu0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'menu' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxToolBarToolBase::SetDropdownMenu((wxMenu*) object_pointer0_0)\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					((wxToolBarToolBase_php*)native_object)->SetDropdownMenu((wxMenu*) object_pointer0_0);
				}

				references->AddReference(menu0, "wxToolBarToolBase::SetDropdownMenu at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::SetDropdownMenu\n");
	}
}
/* }}} */

/* {{{ proto  wxToolBarToolBase::SetLabel(string label) */
PHP_METHOD(php_wxToolBarToolBase, SetLabel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::SetLabel\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::SetLabel call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* label0;
	long label_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&label0, &label_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &label0, &label_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxToolBarToolBase::SetLabel(wxString(label0, wxConvUTF8))\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					((wxToolBarToolBase_php*)native_object)->SetLabel(wxString(label0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::SetLabel\n");
	}
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::SetLongHelp(string help) */
PHP_METHOD(php_wxToolBarToolBase, SetLongHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::SetLongHelp\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::SetLongHelp call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* help0;
	long help_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&help0, &help_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &help0, &help_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToolBarToolBase::SetLongHelp(wxString(help0, wxConvUTF8)))\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxToolBarToolBase_php*)native_object)->SetLongHelp(wxString(help0, wxConvUTF8)));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::SetLongHelp\n");
	}
}
/* }}} */

/* {{{ proto  wxToolBarToolBase::SetNormalBitmap(wxBitmap bmp) */
PHP_METHOD(php_wxToolBarToolBase, SetNormalBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::SetNormalBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::SetNormalBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bmp0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bmp0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmp0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmp0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bmp0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bmp0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'bmp' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmp0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bmp' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxToolBarToolBase::SetNormalBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					((wxToolBarToolBase_php*)native_object)->SetNormalBitmap(*(wxBitmap*) object_pointer0_0);
				}

				references->AddReference(bmp0, "wxToolBarToolBase::SetNormalBitmap at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::SetNormalBitmap\n");
	}
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::SetShortHelp(string help) */
PHP_METHOD(php_wxToolBarToolBase, SetShortHelp)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::SetShortHelp\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::SetShortHelp call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* help0;
	long help_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&help0, &help_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &help0, &help_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToolBarToolBase::SetShortHelp(wxString(help0, wxConvUTF8)))\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxToolBarToolBase_php*)native_object)->SetShortHelp(wxString(help0, wxConvUTF8)));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::SetShortHelp\n");
	}
}
/* }}} */

/* {{{ proto bool wxToolBarToolBase::SetToggle(bool toggle) */
PHP_METHOD(php_wxToolBarToolBase, SetToggle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::SetToggle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::SetToggle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool toggle0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&toggle0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &toggle0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxToolBarToolBase::SetToggle(toggle0))\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxToolBarToolBase_php*)native_object)->SetToggle(toggle0));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::SetToggle\n");
	}
}
/* }}} */

/* {{{ proto  wxToolBarToolBase::Toggle() */
PHP_METHOD(php_wxToolBarToolBase, Toggle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::Toggle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::Toggle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxToolBarToolBase::Toggle()\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					((wxToolBarToolBase_php*)native_object)->Toggle();
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::Toggle\n");
	}
}
/* }}} */

/* {{{ proto  wxToolBarToolBase::SetDisabledBitmap(wxBitmap bmp) */
PHP_METHOD(php_wxToolBarToolBase, SetDisabledBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::SetDisabledBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::SetDisabledBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bmp0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bmp0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmp0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmp0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bmp0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bmp0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'bmp' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmp0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bmp' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxToolBarToolBase::SetDisabledBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					((wxToolBarToolBase_php*)native_object)->SetDisabledBitmap(*(wxBitmap*) object_pointer0_0);
				}

				references->AddReference(bmp0, "wxToolBarToolBase::SetDisabledBitmap at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::SetDisabledBitmap\n");
	}
}
/* }}} */

/* {{{ proto  wxToolBarToolBase::SetClientData(wxObject &clientData) */
PHP_METHOD(php_wxToolBarToolBase, SetClientData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxToolBarToolBase::SetClientData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxToolBarToolBase* current_object;
	wxphp_object_type current_object_type;
	wxToolBarToolBase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxToolBarToolBase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxToolBarToolBase::SetClientData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE){
				references = &((wxToolBarToolBase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* clientData0 = 0;
	wxObject* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&clientData0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &clientData0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(clientData0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxObject*) zend_object_store_get_object(clientData0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxObject*) zend_object_store_get_object(clientData0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxObject*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXOBJECT_TYPE && argument_type != PHP_WXEVTHANDLER_TYPE && argument_type != PHP_WXWINDOW_TYPE && argument_type != PHP_WXNONOWNEDWINDOW_TYPE && argument_type != PHP_WXTOPLEVELWINDOW_TYPE && argument_type != PHP_WXFRAME_TYPE && argument_type != PHP_WXSPLASHSCREEN_TYPE && argument_type != PHP_WXMDICHILDFRAME_TYPE && argument_type != PHP_WXMDIPARENTFRAME_TYPE && argument_type != PHP_WXMINIFRAME_TYPE && argument_type != PHP_WXPREVIEWFRAME_TYPE && argument_type != PHP_WXHTMLHELPDIALOG_TYPE && argument_type != PHP_WXHTMLHELPFRAME_TYPE && argument_type != PHP_WXDIALOG_TYPE && argument_type != PHP_WXTEXTENTRYDIALOG_TYPE && argument_type != PHP_WXPASSWORDENTRYDIALOG_TYPE && argument_type != PHP_WXMESSAGEDIALOG_TYPE && argument_type != PHP_WXFINDREPLACEDIALOG_TYPE && argument_type != PHP_WXDIRDIALOG_TYPE && argument_type != PHP_WXSYMBOLPICKERDIALOG_TYPE && argument_type != PHP_WXPROPERTYSHEETDIALOG_TYPE && argument_type != PHP_WXWIZARD_TYPE && argument_type != PHP_WXPROGRESSDIALOG_TYPE && argument_type != PHP_WXCOLOURDIALOG_TYPE && argument_type != PHP_WXFILEDIALOG_TYPE && argument_type != PHP_WXFONTDIALOG_TYPE && argument_type != PHP_WXPAGESETUPDIALOG_TYPE && argument_type != PHP_WXPRINTDIALOG_TYPE && argument_type != PHP_WXSINGLECHOICEDIALOG_TYPE && argument_type != PHP_WXGENERICPROGRESSDIALOG_TYPE && argument_type != PHP_WXPOPUPWINDOW_TYPE && argument_type != PHP_WXPOPUPTRANSIENTWINDOW_TYPE && argument_type != PHP_WXCONTROL_TYPE && argument_type != PHP_WXSTATUSBAR_TYPE && argument_type != PHP_WXANYBUTTON_TYPE && argument_type != PHP_WXBUTTON_TYPE && argument_type != PHP_WXBITMAPBUTTON_TYPE && argument_type != PHP_WXTOGGLEBUTTON_TYPE && argument_type != PHP_WXBITMAPTOGGLEBUTTON_TYPE && argument_type != PHP_WXTREECTRL_TYPE && argument_type != PHP_WXCONTROLWITHITEMS_TYPE && argument_type != PHP_WXLISTBOX_TYPE && argument_type != PHP_WXCHECKLISTBOX_TYPE && argument_type != PHP_WXREARRANGELIST_TYPE && argument_type != PHP_WXCHOICE_TYPE && argument_type != PHP_WXBOOKCTRLBASE_TYPE && argument_type != PHP_WXAUINOTEBOOK_TYPE && argument_type != PHP_WXLISTBOOK_TYPE && argument_type != PHP_WXCHOICEBOOK_TYPE && argument_type != PHP_WXNOTEBOOK_TYPE && argument_type != PHP_WXTREEBOOK_TYPE && argument_type != PHP_WXTOOLBOOK_TYPE && argument_type != PHP_WXANIMATIONCTRL_TYPE && argument_type != PHP_WXSTYLEDTEXTCTRL_TYPE && argument_type != PHP_WXSCROLLBAR_TYPE && argument_type != PHP_WXSTATICTEXT_TYPE && argument_type != PHP_WXSTATICLINE_TYPE && argument_type != PHP_WXSTATICBOX_TYPE && argument_type != PHP_WXSTATICBITMAP_TYPE && argument_type != PHP_WXCHECKBOX_TYPE && argument_type != PHP_WXTEXTCTRL_TYPE && argument_type != PHP_WXSEARCHCTRL_TYPE && argument_type != PHP_WXCOMBOBOX_TYPE && argument_type != PHP_WXBITMAPCOMBOBOX_TYPE && argument_type != PHP_WXAUITOOLBAR_TYPE && argument_type != PHP_WXLISTCTRL_TYPE && argument_type != PHP_WXLISTVIEW_TYPE && argument_type != PHP_WXRADIOBOX_TYPE && argument_type != PHP_WXRADIOBUTTON_TYPE && argument_type != PHP_WXSLIDER_TYPE && argument_type != PHP_WXSPINCTRL_TYPE && argument_type != PHP_WXSPINBUTTON_TYPE && argument_type != PHP_WXGAUGE_TYPE && argument_type != PHP_WXHYPERLINKCTRL_TYPE && argument_type != PHP_WXSPINCTRLDOUBLE_TYPE && argument_type != PHP_WXGENERICDIRCTRL_TYPE && argument_type != PHP_WXCALENDARCTRL_TYPE && argument_type != PHP_WXPICKERBASE_TYPE && argument_type != PHP_WXCOLOURPICKERCTRL_TYPE && argument_type != PHP_WXFONTPICKERCTRL_TYPE && argument_type != PHP_WXFILEPICKERCTRL_TYPE && argument_type != PHP_WXDIRPICKERCTRL_TYPE && argument_type != PHP_WXTIMEPICKERCTRL_TYPE && argument_type != PHP_WXTOOLBAR_TYPE && argument_type != PHP_WXDATEPICKERCTRL_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANE_TYPE && argument_type != PHP_WXCOMBOCTRL_TYPE && argument_type != PHP_WXDATAVIEWCTRL_TYPE && argument_type != PHP_WXDATAVIEWLISTCTRL_TYPE && argument_type != PHP_WXDATAVIEWTREECTRL_TYPE && argument_type != PHP_WXHEADERCTRL_TYPE && argument_type != PHP_WXHEADERCTRLSIMPLE_TYPE && argument_type != PHP_WXFILECTRL_TYPE && argument_type != PHP_WXINFOBAR_TYPE && argument_type != PHP_WXRIBBONCONTROL_TYPE && argument_type != PHP_WXRIBBONBAR_TYPE && argument_type != PHP_WXRIBBONBUTTONBAR_TYPE && argument_type != PHP_WXRIBBONGALLERY_TYPE && argument_type != PHP_WXRIBBONPAGE_TYPE && argument_type != PHP_WXRIBBONPANEL_TYPE && argument_type != PHP_WXRIBBONTOOLBAR_TYPE && argument_type != PHP_WXWEBVIEW_TYPE && argument_type != PHP_WXSPLITTERWINDOW_TYPE && argument_type != PHP_WXPANEL_TYPE && argument_type != PHP_WXSCROLLEDWINDOW_TYPE && argument_type != PHP_WXHTMLWINDOW_TYPE && argument_type != PHP_WXGRID_TYPE && argument_type != PHP_WXPREVIEWCANVAS_TYPE && argument_type != PHP_WXWIZARDPAGE_TYPE && argument_type != PHP_WXWIZARDPAGESIMPLE_TYPE && argument_type != PHP_WXEDITABLELISTBOX_TYPE && argument_type != PHP_WXHSCROLLEDWINDOW_TYPE && argument_type != PHP_WXPREVIEWCONTROLBAR_TYPE && argument_type != PHP_WXMENUBAR_TYPE && argument_type != PHP_WXBANNERWINDOW_TYPE && argument_type != PHP_WXMDICLIENTWINDOW_TYPE && argument_type != PHP_WXTREELISTCTRL_TYPE && argument_type != PHP_WXSASHWINDOW_TYPE && argument_type != PHP_WXSASHLAYOUTWINDOW_TYPE && argument_type != PHP_WXHTMLHELPWINDOW_TYPE && argument_type != PHP_WXVALIDATOR_TYPE && argument_type != PHP_WXTEXTVALIDATOR_TYPE && argument_type != PHP_WXGENERICVALIDATOR_TYPE && argument_type != PHP_WXMENU_TYPE && argument_type != PHP_WXAUIMANAGER_TYPE && argument_type != PHP_WXMOUSEEVENTSMANAGER_TYPE && argument_type != PHP_WXTIMER_TYPE && argument_type != PHP_WXEVENTBLOCKER_TYPE && argument_type != PHP_WXPROCESS_TYPE && argument_type != PHP_WXFILESYSTEMWATCHER_TYPE && argument_type != PHP_WXTASKBARICON_TYPE && argument_type != PHP_WXNOTIFICATIONMESSAGE_TYPE && argument_type != PHP_WXBITMAPHANDLER_TYPE && argument_type != PHP_WXIMAGE_TYPE && argument_type != PHP_WXSIZER_TYPE && argument_type != PHP_WXBOXSIZER_TYPE && argument_type != PHP_WXSTATICBOXSIZER_TYPE && argument_type != PHP_WXWRAPSIZER_TYPE && argument_type != PHP_WXSTDDIALOGBUTTONSIZER_TYPE && argument_type != PHP_WXGRIDSIZER_TYPE && argument_type != PHP_WXFLEXGRIDSIZER_TYPE && argument_type != PHP_WXGRIDBAGSIZER_TYPE && argument_type != PHP_WXSIZERITEM_TYPE && argument_type != PHP_WXGBSIZERITEM_TYPE && argument_type != PHP_WXIMAGELIST_TYPE && argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE && argument_type != PHP_WXCOLOUR_TYPE && argument_type != PHP_WXMENUITEM_TYPE && argument_type != PHP_WXEVENT_TYPE && argument_type != PHP_WXMENUEVENT_TYPE && argument_type != PHP_WXKEYEVENT_TYPE && argument_type != PHP_WXCOMMANDEVENT_TYPE && argument_type != PHP_WXNOTIFYEVENT_TYPE && argument_type != PHP_WXTREEEVENT_TYPE && argument_type != PHP_WXBOOKCTRLEVENT_TYPE && argument_type != PHP_WXAUINOTEBOOKEVENT_TYPE && argument_type != PHP_WXAUITOOLBAREVENT_TYPE && argument_type != PHP_WXLISTEVENT_TYPE && argument_type != PHP_WXSPINEVENT_TYPE && argument_type != PHP_WXSPLITTEREVENT_TYPE && argument_type != PHP_WXSPINDOUBLEEVENT_TYPE && argument_type != PHP_WXGRIDSIZEEVENT_TYPE && argument_type != PHP_WXWIZARDEVENT_TYPE && argument_type != PHP_WXGRIDEVENT_TYPE && argument_type != PHP_WXGRIDRANGESELECTEVENT_TYPE && argument_type != PHP_WXDATAVIEWEVENT_TYPE && argument_type != PHP_WXHEADERCTRLEVENT_TYPE && argument_type != PHP_WXRIBBONBAREVENT_TYPE && argument_type != PHP_WXWEBVIEWEVENT_TYPE && argument_type != PHP_WXSTYLEDTEXTEVENT_TYPE && argument_type != PHP_WXCHILDFOCUSEVENT_TYPE && argument_type != PHP_WXHTMLCELLEVENT_TYPE && argument_type != PHP_WXHTMLLINKEVENT_TYPE && argument_type != PHP_WXHYPERLINKEVENT_TYPE && argument_type != PHP_WXCOLOURPICKEREVENT_TYPE && argument_type != PHP_WXFONTPICKEREVENT_TYPE && argument_type != PHP_WXSCROLLEVENT_TYPE && argument_type != PHP_WXWINDOWMODALDIALOGEVENT_TYPE && argument_type != PHP_WXDATEEVENT_TYPE && argument_type != PHP_WXCALENDAREVENT_TYPE && argument_type != PHP_WXWINDOWCREATEEVENT_TYPE && argument_type != PHP_WXWINDOWDESTROYEVENT_TYPE && argument_type != PHP_WXUPDATEUIEVENT_TYPE && argument_type != PHP_WXHELPEVENT_TYPE && argument_type != PHP_WXGRIDEDITORCREATEDEVENT_TYPE && argument_type != PHP_WXCOLLAPSIBLEPANEEVENT_TYPE && argument_type != PHP_WXCLIPBOARDTEXTEVENT_TYPE && argument_type != PHP_WXFILECTRLEVENT_TYPE && argument_type != PHP_WXSASHEVENT_TYPE && argument_type != PHP_WXFILEDIRPICKEREVENT_TYPE && argument_type != PHP_WXCONTEXTMENUEVENT_TYPE && argument_type != PHP_WXRIBBONBUTTONBAREVENT_TYPE && argument_type != PHP_WXRIBBONGALLERYEVENT_TYPE && argument_type != PHP_WXCLOSEEVENT_TYPE && argument_type != PHP_WXACTIVATEEVENT_TYPE && argument_type != PHP_WXAUIMANAGEREVENT_TYPE && argument_type != PHP_WXSIZEEVENT_TYPE && argument_type != PHP_WXMOUSEEVENT_TYPE && argument_type != PHP_WXMOVEEVENT_TYPE && argument_type != PHP_WXTIMEREVENT_TYPE && argument_type != PHP_WXTHREADEVENT_TYPE && argument_type != PHP_WXSCROLLWINEVENT_TYPE && argument_type != PHP_WXSYSCOLOURCHANGEDEVENT_TYPE && argument_type != PHP_WXPROCESSEVENT_TYPE && argument_type != PHP_WXERASEEVENT_TYPE && argument_type != PHP_WXSETCURSOREVENT_TYPE && argument_type != PHP_WXIDLEEVENT_TYPE && argument_type != PHP_WXPAINTEVENT_TYPE && argument_type != PHP_WXPALETTECHANGEDEVENT_TYPE && argument_type != PHP_WXINITDIALOGEVENT_TYPE && argument_type != PHP_WXMAXIMIZEEVENT_TYPE && argument_type != PHP_WXNAVIGATIONKEYEVENT_TYPE && argument_type != PHP_WXFOCUSEVENT_TYPE && argument_type != PHP_WXFILESYSTEMWATCHEREVENT_TYPE && argument_type != PHP_WXDISPLAYCHANGEDEVENT_TYPE && argument_type != PHP_WXCALCULATELAYOUTEVENT_TYPE && argument_type != PHP_WXQUERYLAYOUTINFOEVENT_TYPE && argument_type != PHP_WXTASKBARICONEVENT_TYPE && argument_type != PHP_WXACCELERATORTABLE_TYPE && argument_type != PHP_WXGDIOBJECT_TYPE && argument_type != PHP_WXBITMAP_TYPE && argument_type != PHP_WXPALETTE_TYPE && argument_type != PHP_WXICON_TYPE && argument_type != PHP_WXFONT_TYPE && argument_type != PHP_WXANIMATION_TYPE && argument_type != PHP_WXICONBUNDLE_TYPE && argument_type != PHP_WXCURSOR_TYPE && argument_type != PHP_WXREGION_TYPE && argument_type != PHP_WXPEN_TYPE && argument_type != PHP_WXBRUSH_TYPE && argument_type != PHP_WXARTPROVIDER_TYPE && argument_type != PHP_WXHTMLCELL_TYPE && argument_type != PHP_WXHTMLCONTAINERCELL_TYPE && argument_type != PHP_WXHTMLCOLOURCELL_TYPE && argument_type != PHP_WXHTMLWIDGETCELL_TYPE && argument_type != PHP_WXHTMLEASYPRINTING_TYPE && argument_type != PHP_WXHTMLLINKINFO_TYPE && argument_type != PHP_WXFINDREPLACEDATA_TYPE && argument_type != PHP_WXSOUND_TYPE && argument_type != PHP_WXFILESYSTEM_TYPE && argument_type != PHP_WXFILESYSTEMHANDLER_TYPE && argument_type != PHP_WXMASK_TYPE && argument_type != PHP_WXTOOLTIP_TYPE && argument_type != PHP_WXGRAPHICSRENDERER_TYPE && argument_type != PHP_WXLAYOUTCONSTRAINTS_TYPE && argument_type != PHP_WXFSFILE_TYPE && argument_type != PHP_WXCOLOURDATA_TYPE && argument_type != PHP_WXFONTDATA_TYPE && argument_type != PHP_WXGRIDTABLEBASE_TYPE && argument_type != PHP_WXDATAVIEWRENDERER_TYPE && argument_type != PHP_WXDATAVIEWBITMAPRENDERER_TYPE && argument_type != PHP_WXDATAVIEWCHOICERENDERER_TYPE && argument_type != PHP_WXDATAVIEWCUSTOMRENDERER_TYPE && argument_type != PHP_WXDATAVIEWSPINRENDERER_TYPE && argument_type != PHP_WXDATAVIEWDATERENDERER_TYPE && argument_type != PHP_WXDATAVIEWICONTEXTRENDERER_TYPE && argument_type != PHP_WXDATAVIEWPROGRESSRENDERER_TYPE && argument_type != PHP_WXDATAVIEWTEXTRENDERER_TYPE && argument_type != PHP_WXDATAVIEWTOGGLERENDERER_TYPE && argument_type != PHP_WXDATAVIEWICONTEXT_TYPE && argument_type != PHP_WXVARIANT_TYPE && argument_type != PHP_WXCLIPBOARD_TYPE && argument_type != PHP_WXCONFIGBASE_TYPE && argument_type != PHP_WXFILECONFIG_TYPE && argument_type != PHP_WXXMLRESOURCE_TYPE && argument_type != PHP_WXPAGESETUPDIALOGDATA_TYPE && argument_type != PHP_WXPRINTDIALOGDATA_TYPE && argument_type != PHP_WXPRINTDATA_TYPE && argument_type != PHP_WXPRINTPREVIEW_TYPE && argument_type != PHP_WXPRINTER_TYPE && argument_type != PHP_WXPRINTOUT_TYPE && argument_type != PHP_WXHTMLPRINTOUT_TYPE && argument_type != PHP_WXHTMLDCRENDERER_TYPE && argument_type != PHP_WXHTMLFILTER_TYPE && argument_type != PHP_WXHTMLHELPDATA_TYPE && argument_type != PHP_WXHTMLTAGHANDLER_TYPE && argument_type != PHP_WXHTMLWINTAGHANDLER_TYPE && argument_type != PHP_WXMODULE_TYPE && argument_type != PHP_WXHTMLTAGSMODULE_TYPE && argument_type != PHP_WXIMAGEHANDLER_TYPE && argument_type != PHP_WXXMLRESOURCEHANDLER_TYPE && argument_type != PHP_WXXMLDOCUMENT_TYPE && argument_type != PHP_WXLAYOUTALGORITHM_TYPE && argument_type != PHP_WXFILEHISTORY_TYPE && argument_type != PHP_WXTOOLBARTOOLBASE_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'clientData' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(clientData0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'clientData' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxToolBarToolBase::SetClientData((wxObject*) object_pointer0_0)\n\n");
				#endif

				if(current_object_type == PHP_WXTOOLBARTOOLBASE_TYPE)
				{
					((wxToolBarToolBase_php*)native_object)->SetClientData((wxObject*) object_pointer0_0);
				}

				references->AddReference(clientData0, "wxToolBarToolBase::SetClientData at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxToolBarToolBase::SetClientData\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxTextCompleterSimple_free(void *object TSRMLS_DC) 
{
    zo_wxTextCompleterSimple* custom_object = (zo_wxTextCompleterSimple*) object;
    //delete custom_object->native_object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTextCompleterSimple_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
			delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxTextCompleterSimple done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxTextCompleterSimple_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxTextCompleterSimple_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxTextCompleterSimple* custom_object;
    custom_object = (zo_wxTextCompleterSimple*) emalloc(sizeof(zo_wxTextCompleterSimple));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

    custom_object->native_object = NULL;
    custom_object->object_type = PHP_WXTEXTCOMPLETERSIMPLE_TYPE;
    custom_object->is_user_initialized = 0;

    retval.handle = zend_objects_store_put(custom_object, NULL, php_wxTextCompleterSimple_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxTextCompleterSimple::GetCompletions(string prefix, array &res)
   Pure virtual method returning all possible completions for the given prefix. */
void wxTextCompleterSimple_php::GetCompletions(const wxString& prefix, wxArrayString& res)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxTextCompleterSimple::GetCompletions\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		MAKE_STD_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetCompletions", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	temp_string = (char*)malloc(sizeof(wxChar)*(prefix.size()+1));
	strcpy(temp_string, (const char *) prefix.char_str());
	ZVAL_STRING(arguments[0], temp_string, 1);
	free(temp_string);
	array_init(arguments[1]);
	for(int i=0; i<res.GetCount(); i++)
	{
		temp_string = (char*)malloc(sizeof(wxChar)*(res[i].size()+1));
		strcpy(temp_string, (const char *) res[i].char_str());
		add_next_index_string(arguments[1], temp_string, 1);
		free(temp_string);
	}
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetCompletions", 14, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		efree(arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxTextCompleterSimple::GetCompletions'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

