/*
 * @author Mário Soares
 * @contributors Jefferson González
 * 
 * @license 
 * This file is part of wxPHP check the LICENSE file for information.
 * 
 * @note
 * This file was auto-generated by the wxPHP source maker
*/

#include "php_wxwidgets.h"
#include "appmanagement.h"
#include "aui.h"
#include "bookctrl.h"
#include "cfg.h"
#include "cmndlg.h"
#include "containers.h"
#include "ctrl.h"
#include "data.h"
#include "dc.h"
#include "dnd.h"
#include "docview.h"
#include "dvc.h"
#include "events.h"
#include "file.h"
#include "gdi.h"
#include "grid.h"
#include "help.h"
#include "html.h"
#include "logging.h"
#include "managedwnd.h"
#include "media.h"
#include "menus.h"
#include "misc.h"
#include "miscwnd.h"
#include "net.h"
#include "pickers.h"
#include "printing.h"
#include "ribbon.h"
#include "richtext.h"
#include "rtti.h"
#include "stc.h"
#include "streams.h"
#include "threading.h"
#include "validator.h"
#include "vfs.h"
#include "webview.h"
#include "winlayout.h"
#include "xml.h"
#include "xrc.h"
#include "others.h"


BEGIN_EXTERN_C()
void php_wxGraphicsGradientStop_free(void *object TSRMLS_DC) 
{
    zo_wxGraphicsGradientStop* custom_object = (zo_wxGraphicsGradientStop*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGraphicsGradientStop_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGraphicsGradientStop done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGraphicsGradientStop_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGraphicsGradientStop_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGraphicsGradientStop* custom_object;
    custom_object = (zo_wxGraphicsGradientStop*) emalloc(sizeof(zo_wxGraphicsGradientStop));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGraphicsGradientStop_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXGRAPHICSGRADIENTSTOP_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto wxColour wxGraphicsGradientStop::GetColour()
   Return the stop colour. */
PHP_METHOD(php_wxGraphicsGradientStop, GetColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGraphicsGradientStop::GetColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGraphicsGradientStop* current_object;
	wxphp_object_type current_object_type;
	wxGraphicsGradientStop_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGraphicsGradientStop*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGraphicsGradientStop::GetColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOP_TYPE){
				references = &((wxGraphicsGradientStop_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGraphicsGradientStop::GetColour() to return object reference\n\n");
				#endif

				wxColour_php* value_to_return0;
				value_to_return0 = (wxColour_php*) &((wxGraphicsGradientStop_php*)native_object)->GetColour();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxColour_entry);
					((zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxColour_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxGraphicsGradientStop::GetColour at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGraphicsGradientStop::GetColour\n");
	}
}
/* }}} */

/* {{{ proto float wxGraphicsGradientStop::GetPosition()
   Return the stop position. */
PHP_METHOD(php_wxGraphicsGradientStop, GetPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGraphicsGradientStop::GetPosition\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGraphicsGradientStop* current_object;
	wxphp_object_type current_object_type;
	wxGraphicsGradientStop_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGraphicsGradientStop*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGraphicsGradientStop::GetPosition call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOP_TYPE){
				references = &((wxGraphicsGradientStop_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGraphicsGradientStop::GetPosition())\n\n");
				#endif

				ZVAL_DOUBLE(return_value, ((wxGraphicsGradientStop_php*)native_object)->GetPosition());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGraphicsGradientStop::GetPosition\n");
	}
}
/* }}} */

/* {{{ proto  wxGraphicsGradientStop::SetColour(wxColour col)
   Change the stop colour. */
PHP_METHOD(php_wxGraphicsGradientStop, SetColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGraphicsGradientStop::SetColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGraphicsGradientStop* current_object;
	wxphp_object_type current_object_type;
	wxGraphicsGradientStop_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGraphicsGradientStop*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGraphicsGradientStop::SetColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOP_TYPE){
				references = &((wxGraphicsGradientStop_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* col0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&col0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(col0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(col0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'col' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'col' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGraphicsGradientStop::SetColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxGraphicsGradientStop_php*)native_object)->SetColour(*(wxColour*) object_pointer0_0);

				references->AddReference(col0, "wxGraphicsGradientStop::SetColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGraphicsGradientStop::SetColour\n");
	}
}
/* }}} */

/* {{{ proto  wxGraphicsGradientStop::SetPosition(float pos)
   Change the stop position. */
PHP_METHOD(php_wxGraphicsGradientStop, SetPosition)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGraphicsGradientStop::SetPosition\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGraphicsGradientStop* current_object;
	wxphp_object_type current_object_type;
	wxGraphicsGradientStop_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGraphicsGradientStop*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGraphicsGradientStop::SetPosition call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOP_TYPE){
				references = &((wxGraphicsGradientStop_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	double pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'd' (&pos0)\n");
		#endif

		char parse_parameters_string[] = "d";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pos0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGraphicsGradientStop::SetPosition(pos0)\n\n");
				#endif

				((wxGraphicsGradientStop_php*)native_object)->SetPosition(pos0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGraphicsGradientStop::SetPosition\n");
	}
}
/* }}} */

/* {{{ proto  wxGraphicsGradientStop::wxGraphicsGradientStop(wxColour col, float pos)
   Creates a stop with the given colour and position. */
PHP_METHOD(php_wxGraphicsGradientStop, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGraphicsGradientStop::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGraphicsGradientStop* current_object;
	wxGraphicsGradientStop_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* col0 = 0;
	wxColour* object_pointer0_0 = 0;
	double pos0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|Od' (&col0, php_wxColour_entry, &pos0)\n");
		#endif

		char parse_parameters_string[] = "|Od";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, php_wxColour_entry, &pos0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(col0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(col0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'col' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'col' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGraphicsGradientStop_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer0_0)\n");
				#endif

				native_object = new wxGraphicsGradientStop_php(*(wxColour*) object_pointer0_0);

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer0_0, pos0)\n");
				#endif

				native_object = new wxGraphicsGradientStop_php(*(wxColour*) object_pointer0_0, pos0);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxGraphicsGradientStop*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGraphicsGradientStop::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGraphicsGradientStops_free(void *object TSRMLS_DC) 
{
    zo_wxGraphicsGradientStops* custom_object = (zo_wxGraphicsGradientStops*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGraphicsGradientStops_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGraphicsGradientStops done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGraphicsGradientStops_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGraphicsGradientStops_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGraphicsGradientStops* custom_object;
    custom_object = (zo_wxGraphicsGradientStops*) emalloc(sizeof(zo_wxGraphicsGradientStops));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGraphicsGradientStops_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXGRAPHICSGRADIENTSTOPS_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxGraphicsGradientStops::Add(wxGraphicsGradientStop stop)
   Add a new stop. */
PHP_METHOD(php_wxGraphicsGradientStops, Add)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGraphicsGradientStops::Add\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGraphicsGradientStops* current_object;
	wxphp_object_type current_object_type;
	wxGraphicsGradientStops_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGraphicsGradientStops*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGraphicsGradientStops::Add call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOPS_TYPE){
				references = &((wxGraphicsGradientStops_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* stop0 = 0;
	wxGraphicsGradientStop* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* col1 = 0;
	wxColour* object_pointer1_0 = 0;
	double pos1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&stop0, php_wxGraphicsGradientStop_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stop0, php_wxGraphicsGradientStop_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stop0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxGraphicsGradientStop*) zend_object_store_get_object(stop0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxGraphicsGradientStop*) zend_object_store_get_object(stop0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxGraphicsGradientStop*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(stop0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Od' (&col1, php_wxColour_entry, &pos1)\n");
		#endif

		char parse_parameters_string[] = "Od";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col1, php_wxColour_entry, &pos1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(col1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(col1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxColour*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'col' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'col' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGraphicsGradientStops::Add(*(wxGraphicsGradientStop*) object_pointer0_0)\n\n");
				#endif

				((wxGraphicsGradientStops_php*)native_object)->Add(*(wxGraphicsGradientStop*) object_pointer0_0);

				references->AddReference(stop0, "wxGraphicsGradientStops::Add at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGraphicsGradientStops::Add(*(wxColour*) object_pointer1_0, pos1)\n\n");
				#endif

				((wxGraphicsGradientStops_php*)native_object)->Add(*(wxColour*) object_pointer1_0, pos1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGraphicsGradientStops::Add\n");
	}
}
/* }}} */

/* {{{ proto int wxGraphicsGradientStops::GetCount()
   Returns the number of stops. */
PHP_METHOD(php_wxGraphicsGradientStops, GetCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGraphicsGradientStops::GetCount\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGraphicsGradientStops* current_object;
	wxphp_object_type current_object_type;
	wxGraphicsGradientStops_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGraphicsGradientStops*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGraphicsGradientStops::GetCount call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOPS_TYPE){
				references = &((wxGraphicsGradientStops_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxGraphicsGradientStops::GetCount())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxGraphicsGradientStops_php*)native_object)->GetCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGraphicsGradientStops::GetCount\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxGraphicsGradientStops::GetEndColour()
   Returns the end colour. */
PHP_METHOD(php_wxGraphicsGradientStops, GetEndColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGraphicsGradientStops::GetEndColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGraphicsGradientStops* current_object;
	wxphp_object_type current_object_type;
	wxGraphicsGradientStops_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGraphicsGradientStops*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGraphicsGradientStops::GetEndColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOPS_TYPE){
				references = &((wxGraphicsGradientStops_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGraphicsGradientStops::GetEndColour() to return new object\n\n");
				#endif

				wxColour value_to_return0;
				value_to_return0 = ((wxGraphicsGradientStops_php*)native_object)->GetEndColour();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				((wxColour_php*)ptr)->phpObj = return_value;
				zo_wxColour* zo0 = (zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxColour_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGraphicsGradientStops::GetEndColour\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxGraphicsGradientStops::GetStartColour()
   Returns the start colour. */
PHP_METHOD(php_wxGraphicsGradientStops, GetStartColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGraphicsGradientStops::GetStartColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGraphicsGradientStops* current_object;
	wxphp_object_type current_object_type;
	wxGraphicsGradientStops_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGraphicsGradientStops*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGraphicsGradientStops::GetStartColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOPS_TYPE){
				references = &((wxGraphicsGradientStops_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGraphicsGradientStops::GetStartColour() to return new object\n\n");
				#endif

				wxColour value_to_return0;
				value_to_return0 = ((wxGraphicsGradientStops_php*)native_object)->GetStartColour();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				((wxColour_php*)ptr)->phpObj = return_value;
				zo_wxColour* zo0 = (zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxColour_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGraphicsGradientStops::GetStartColour\n");
	}
}
/* }}} */

/* {{{ proto wxGraphicsGradientStop wxGraphicsGradientStops::Item(int n)
   Returns the stop at the given index. */
PHP_METHOD(php_wxGraphicsGradientStops, Item)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGraphicsGradientStops::Item\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGraphicsGradientStops* current_object;
	wxphp_object_type current_object_type;
	wxGraphicsGradientStops_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGraphicsGradientStops*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGraphicsGradientStops::Item call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOPS_TYPE){
				references = &((wxGraphicsGradientStops_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGraphicsGradientStops::Item((unsigned) n0) to return new object\n\n");
				#endif

				wxGraphicsGradientStop value_to_return1;
				value_to_return1 = ((wxGraphicsGradientStops_php*)native_object)->Item((unsigned) n0);
				void* ptr = safe_emalloc(1, sizeof(wxGraphicsGradientStop_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxGraphicsGradientStop));
				object_init_ex(return_value, php_wxGraphicsGradientStop_entry);
				((wxGraphicsGradientStop_php*)ptr)->phpObj = return_value;
				zo_wxGraphicsGradientStop* zo1 = (zo_wxGraphicsGradientStop*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxGraphicsGradientStop_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGraphicsGradientStops::Item\n");
	}
}
/* }}} */

/* {{{ proto  wxGraphicsGradientStops::SetEndColour(wxColour col)
   Set the end colour to col. */
PHP_METHOD(php_wxGraphicsGradientStops, SetEndColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGraphicsGradientStops::SetEndColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGraphicsGradientStops* current_object;
	wxphp_object_type current_object_type;
	wxGraphicsGradientStops_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGraphicsGradientStops*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGraphicsGradientStops::SetEndColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOPS_TYPE){
				references = &((wxGraphicsGradientStops_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* col0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&col0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(col0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(col0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'col' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'col' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGraphicsGradientStops::SetEndColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxGraphicsGradientStops_php*)native_object)->SetEndColour(*(wxColour*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGraphicsGradientStops::SetEndColour\n");
	}
}
/* }}} */

/* {{{ proto  wxGraphicsGradientStops::SetStartColour(wxColour col)
   Set the start colour to col. */
PHP_METHOD(php_wxGraphicsGradientStops, SetStartColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGraphicsGradientStops::SetStartColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGraphicsGradientStops* current_object;
	wxphp_object_type current_object_type;
	wxGraphicsGradientStops_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxGraphicsGradientStops*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxGraphicsGradientStops::SetStartColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXGRAPHICSGRADIENTSTOPS_TYPE){
				references = &((wxGraphicsGradientStops_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* col0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&col0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &col0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(col0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(col0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(col0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'col' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(col0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'col' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxGraphicsGradientStops::SetStartColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxGraphicsGradientStops_php*)native_object)->SetStartColour(*(wxColour*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxGraphicsGradientStops::SetStartColour\n");
	}
}
/* }}} */

/* {{{ proto  wxGraphicsGradientStops::wxGraphicsGradientStops(wxColour startCol, wxColour endCol)
   Initializes the gradient stops with the given boundary colours. */
PHP_METHOD(php_wxGraphicsGradientStops, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxGraphicsGradientStops::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxGraphicsGradientStops* current_object;
	wxGraphicsGradientStops_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* startCol0 = 0;
	wxColour* object_pointer0_0 = 0;
	zval* endCol0 = 0;
	wxColour* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|OO' (&startCol0, php_wxColour_entry, &endCol0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "|OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &startCol0, php_wxColour_entry, &endCol0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(startCol0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(startCol0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(startCol0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'startCol' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(startCol0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'startCol' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(endCol0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(endCol0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(endCol0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxColour*) argument_native_object;
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter 'endCol' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(endCol0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'endCol' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxGraphicsGradientStops_php();

				native_object->references.Initialize();
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer0_0)\n");
				#endif

				native_object = new wxGraphicsGradientStops_php(*(wxColour*) object_pointer0_0);

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer0_0, *(wxColour*) object_pointer0_1)\n");
				#endif

				native_object = new wxGraphicsGradientStops_php(*(wxColour*) object_pointer0_0, *(wxColour*) object_pointer0_1);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxGraphicsGradientStops*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxGraphicsGradientStops::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxAnimation_free(void *object TSRMLS_DC) 
{
    zo_wxAnimation* custom_object = (zo_wxAnimation*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAnimation_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxAnimation done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxAnimation_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxAnimation_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxAnimation* custom_object;
    custom_object = (zo_wxAnimation*) emalloc(sizeof(zo_wxAnimation));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxAnimation_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXANIMATION_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto int wxAnimation::GetDelay(int i)
   Returns the delay for the i-th frame in milliseconds. */
PHP_METHOD(php_wxAnimation, GetDelay)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimation::GetDelay\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnimation* current_object;
	wxphp_object_type current_object_type;
	wxAnimation_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnimation*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnimation::GetDelay call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANIMATION_TYPE){
				references = &((wxAnimation_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long i0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&i0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &i0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAnimation::GetDelay((unsigned int) i0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAnimation_php*)native_object)->GetDelay((unsigned int) i0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimation::GetDelay\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxAnimation::GetFrame(int i)
   Returns the i-th frame as a wxImage. */
PHP_METHOD(php_wxAnimation, GetFrame)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimation::GetFrame\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnimation* current_object;
	wxphp_object_type current_object_type;
	wxAnimation_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnimation*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnimation::GetFrame call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANIMATION_TYPE){
				references = &((wxAnimation_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long i0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&i0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &i0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnimation::GetFrame((unsigned int) i0) to return new object\n\n");
				#endif

				wxImage value_to_return1;
				value_to_return1 = ((wxAnimation_php*)native_object)->GetFrame((unsigned int) i0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo1 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimation::GetFrame\n");
	}
}
/* }}} */

/* {{{ proto int wxAnimation::GetFrameCount()
   Returns the number of frames for this animation. */
PHP_METHOD(php_wxAnimation, GetFrameCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimation::GetFrameCount\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnimation* current_object;
	wxphp_object_type current_object_type;
	wxAnimation_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnimation*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnimation::GetFrameCount call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANIMATION_TYPE){
				references = &((wxAnimation_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxAnimation::GetFrameCount())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxAnimation_php*)native_object)->GetFrameCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimation::GetFrameCount\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxAnimation::GetSize()
   Returns the size of the animation. */
PHP_METHOD(php_wxAnimation, GetSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimation::GetSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnimation* current_object;
	wxphp_object_type current_object_type;
	wxAnimation_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnimation*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnimation::GetSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANIMATION_TYPE){
				references = &((wxAnimation_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxAnimation::GetSize() to return new object\n\n");
				#endif

				wxSize value_to_return0;
				value_to_return0 = ((wxAnimation_php*)native_object)->GetSize();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				((wxSize_php*)ptr)->phpObj = return_value;
				zo_wxSize* zo0 = (zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxSize_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimation::GetSize\n");
	}
}
/* }}} */

/* {{{ proto bool wxAnimation::IsOk()
   Returns true if animation data is present. */
PHP_METHOD(php_wxAnimation, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimation::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnimation* current_object;
	wxphp_object_type current_object_type;
	wxAnimation_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnimation*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnimation::IsOk call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANIMATION_TYPE){
				references = &((wxAnimation_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimation::IsOk())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAnimation_php*)native_object)->IsOk());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimation::IsOk\n");
	}
}
/* }}} */

/* {{{ proto bool wxAnimation::LoadFile(string name, wxAnimationType type)
   Loads an animation from a file. */
PHP_METHOD(php_wxAnimation, LoadFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimation::LoadFile\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnimation* current_object;
	wxphp_object_type current_object_type;
	wxAnimation_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnimation*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnimation::LoadFile call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANIMATION_TYPE){
				references = &((wxAnimation_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	long type0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|l' (&name0, &name_len0, &type0)\n");
		#endif

		char parse_parameters_string[] = "s|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0, &type0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimation::LoadFile(wxString(name0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAnimation_php*)native_object)->LoadFile(wxString(name0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimation::LoadFile(wxString(name0, wxConvUTF8), (wxAnimationType) type0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAnimation_php*)native_object)->LoadFile(wxString(name0, wxConvUTF8), (wxAnimationType) type0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimation::LoadFile\n");
	}
}
/* }}} */

/* {{{ proto  wxAnimation::wxAnimation(wxAnimation anim)
   Copy ctor. */
PHP_METHOD(php_wxAnimation, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimation::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnimation* current_object;
	wxAnimation_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* anim0 = 0;
	wxAnimation* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* name1;
	long name_len1;
	long type1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&anim0, php_wxAnimation_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &anim0, php_wxAnimation_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(anim0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxAnimation*) zend_object_store_get_object(anim0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxAnimation*) zend_object_store_get_object(anim0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxAnimation*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(anim0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|l' (&name1, &name_len1, &type1)\n");
		#endif

		char parse_parameters_string[] = "s|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name1, &name_len1, &type1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxAnimation*) object_pointer0_0)\n");
				#endif

				native_object = new wxAnimation_php(*(wxAnimation*) object_pointer0_0);

				native_object->references.Initialize();
				((wxAnimation_php*) native_object)->references.AddReference(anim0, "wxAnimation::wxAnimation at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name1, wxConvUTF8))\n");
				#endif

				native_object = new wxAnimation_php(wxString(name1, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name1, wxConvUTF8), (wxAnimationType) type1)\n");
				#endif

				native_object = new wxAnimation_php(wxString(name1, wxConvUTF8), (wxAnimationType) type1);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxAnimation*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxAnimation::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto bool wxAnimation::Load(wxInputStream &stream, wxAnimationType type)
   Loads an animation from the given stream. */
PHP_METHOD(php_wxAnimation, Load)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxAnimation::Load\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxAnimation* current_object;
	wxphp_object_type current_object_type;
	wxAnimation_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxAnimation*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxAnimation::Load call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXANIMATION_TYPE){
				references = &((wxAnimation_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* stream0 = 0;
	wxInputStream* object_pointer0_0 = 0;
	long type0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'o|l' (&stream0, &type0)\n");
		#endif

		char parse_parameters_string[] = "o|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stream0, &type0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stream0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxInputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxInputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxInputStream*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'stream' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(stream0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'stream' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimation::Load(*(wxInputStream*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAnimation_php*)native_object)->Load(*(wxInputStream*) object_pointer0_0));

				references->AddReference(stream0, "wxAnimation::Load at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxAnimation::Load(*(wxInputStream*) object_pointer0_0, (wxAnimationType) type0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxAnimation_php*)native_object)->Load(*(wxInputStream*) object_pointer0_0, (wxAnimationType) type0));

				references->AddReference(stream0, "wxAnimation::Load at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxAnimation::Load\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxBitmapHandler_free(void *object TSRMLS_DC) 
{
    zo_wxBitmapHandler* custom_object = (zo_wxBitmapHandler*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxBitmapHandler_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxBitmapHandler done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxBitmapHandler_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxBitmapHandler_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxBitmapHandler* custom_object;
    custom_object = (zo_wxBitmapHandler*) emalloc(sizeof(zo_wxBitmapHandler));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxBitmapHandler_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXBITMAPHANDLER_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxBitmapHandler::wxBitmapHandler()
   Default constructor. */
PHP_METHOD(php_wxBitmapHandler, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapHandler::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmapHandler* current_object;
	wxBitmapHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxBitmapHandler_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxBitmapHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxBitmapHandler::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxBitmapHandler::SetType(wxBitmapType type)
   Sets the handler type. */
PHP_METHOD(php_wxBitmapHandler, SetType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapHandler::SetType\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmapHandler* current_object;
	wxphp_object_type current_object_type;
	wxBitmapHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmapHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmapHandler::SetType call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
				references = &((wxBitmapHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long type0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&type0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &type0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmapHandler::SetType((wxBitmapType) type0)\n\n");
				#endif

				((wxBitmapHandler_php*)native_object)->SetType((wxBitmapType) type0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapHandler::SetType\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmapHandler::SetName(string name)
   Sets the handler name. */
PHP_METHOD(php_wxBitmapHandler, SetName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapHandler::SetName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmapHandler* current_object;
	wxphp_object_type current_object_type;
	wxBitmapHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmapHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmapHandler::SetName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
				references = &((wxBitmapHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmapHandler::SetName(wxString(name0, wxConvUTF8))\n\n");
				#endif

				((wxBitmapHandler_php*)native_object)->SetName(wxString(name0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapHandler::SetName\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmapHandler::SetExtension(string extension)
   Sets the handler extension. */
PHP_METHOD(php_wxBitmapHandler, SetExtension)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapHandler::SetExtension\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmapHandler* current_object;
	wxphp_object_type current_object_type;
	wxBitmapHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmapHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmapHandler::SetExtension call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
				references = &((wxBitmapHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* extension0;
	long extension_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&extension0, &extension_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &extension0, &extension_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmapHandler::SetExtension(wxString(extension0, wxConvUTF8))\n\n");
				#endif

				((wxBitmapHandler_php*)native_object)->SetExtension(wxString(extension0, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapHandler::SetExtension\n");
	}
}
/* }}} */

/* {{{ proto bool wxBitmapHandler::LoadFile(wxBitmap &bitmap, string name, wxBitmapType type, int desiredWidth, int desiredHeight)
   Loads a bitmap from a file or resource, putting the resulting data into bitmap. */
PHP_METHOD(php_wxBitmapHandler, LoadFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapHandler::LoadFile\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmapHandler* current_object;
	wxphp_object_type current_object_type;
	wxBitmapHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmapHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmapHandler::LoadFile call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
				references = &((wxBitmapHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	char* name0;
	long name_len0;
	long type0;
	long desiredWidth0;
	long desiredHeight0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zslll' (&bitmap0, &name0, &name_len0, &type0, &desiredWidth0, &desiredHeight0)\n");
		#endif

		char parse_parameters_string[] = "zslll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap0, &name0, &name_len0, &type0, &desiredWidth0, &desiredHeight0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXBITMAP_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapHandler::LoadFile((wxBitmap*) object_pointer0_0, wxString(name0, wxConvUTF8), (wxBitmapType) type0, (int) desiredWidth0, (int) desiredHeight0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBitmapHandler_php*)native_object)->LoadFile((wxBitmap*) object_pointer0_0, wxString(name0, wxConvUTF8), (wxBitmapType) type0, (int) desiredWidth0, (int) desiredHeight0));

				references->AddReference(bitmap0, "wxBitmapHandler::LoadFile at call with 5 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapHandler::LoadFile\n");
	}
}
/* }}} */

/* {{{ proto wxBitmapType wxBitmapHandler::GetType()
   Gets the bitmap type associated with this handler. */
PHP_METHOD(php_wxBitmapHandler, GetType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapHandler::GetType\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmapHandler* current_object;
	wxphp_object_type current_object_type;
	wxBitmapHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmapHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmapHandler::GetType call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
				references = &((wxBitmapHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxBitmapHandler::GetType())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxBitmapHandler_php*)native_object)->GetType());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapHandler::GetType\n");
	}
}
/* }}} */

/* {{{ proto string wxBitmapHandler::GetName()
   Gets the name of this handler. */
PHP_METHOD(php_wxBitmapHandler, GetName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapHandler::GetName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmapHandler* current_object;
	wxphp_object_type current_object_type;
	wxBitmapHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmapHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmapHandler::GetName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
				references = &((wxBitmapHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxBitmapHandler::GetName().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxBitmapHandler_php*)native_object)->GetName();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapHandler::GetName\n");
	}
}
/* }}} */

/* {{{ proto string wxBitmapHandler::GetExtension()
   Gets the file extension associated with this handler. */
PHP_METHOD(php_wxBitmapHandler, GetExtension)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapHandler::GetExtension\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmapHandler* current_object;
	wxphp_object_type current_object_type;
	wxBitmapHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmapHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmapHandler::GetExtension call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
				references = &((wxBitmapHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxBitmapHandler::GetExtension().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxBitmapHandler_php*)native_object)->GetExtension();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapHandler::GetExtension\n");
	}
}
/* }}} */

/* {{{ proto bool wxBitmapHandler::SaveFile(wxBitmap bitmap, string name, wxBitmapType type, wxPalette palette)
   Saves a bitmap in the named file. */
PHP_METHOD(php_wxBitmapHandler, SaveFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapHandler::SaveFile\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmapHandler* current_object;
	wxphp_object_type current_object_type;
	wxBitmapHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmapHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmapHandler::SaveFile call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
				references = &((wxBitmapHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	char* name0;
	long name_len0;
	long type0;
	zval* palette0 = 0;
	wxPalette* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zsl|z' (&bitmap0, &name0, &name_len0, &type0, &palette0)\n");
		#endif

		char parse_parameters_string[] = "zsl|z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap0, &name0, &name_len0, &type0, &palette0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXBITMAP_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(palette0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPalette*) zend_object_store_get_object(palette0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPalette*) zend_object_store_get_object(palette0 TSRMLS_CC))->native_object;
					object_pointer0_3 = (wxPalette*) argument_native_object;
					if (!object_pointer0_3 || (argument_type != PHP_WXPALETTE_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'palette' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(palette0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'palette' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapHandler::SaveFile((const wxBitmap*) object_pointer0_0, wxString(name0, wxConvUTF8), (wxBitmapType) type0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBitmapHandler_php*)native_object)->SaveFile((const wxBitmap*) object_pointer0_0, wxString(name0, wxConvUTF8), (wxBitmapType) type0));

				references->AddReference(bitmap0, "wxBitmapHandler::SaveFile at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapHandler::SaveFile((const wxBitmap*) object_pointer0_0, wxString(name0, wxConvUTF8), (wxBitmapType) type0, (const wxPalette*) object_pointer0_3))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBitmapHandler_php*)native_object)->SaveFile((const wxBitmap*) object_pointer0_0, wxString(name0, wxConvUTF8), (wxBitmapType) type0, (const wxPalette*) object_pointer0_3));

				references->AddReference(bitmap0, "wxBitmapHandler::SaveFile at call with 4 argument(s)");
				references->AddReference(palette0, "wxBitmapHandler::SaveFile at call with 4 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapHandler::SaveFile\n");
	}
}
/* }}} */

/* {{{ proto bool wxBitmapHandler::Create(wxBitmap &bitmap, void data, wxBitmapType type, int width, int height, int depth)
   Creates a bitmap from the given data, which can be of arbitrary type. */
PHP_METHOD(php_wxBitmapHandler, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmapHandler::Create\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmapHandler* current_object;
	wxphp_object_type current_object_type;
	wxBitmapHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmapHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmapHandler::Create call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAPHANDLER_TYPE){
				references = &((wxBitmapHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	char* data0;
	long data_len0;
	long type0;
	long width0;
	long height0;
	long depth0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 5  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zslll|l' (&bitmap0, &data0, &data_len0, &type0, &width0, &height0, &depth0)\n");
		#endif

		char parse_parameters_string[] = "zslll|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap0, &data0, &data_len0, &type0, &width0, &height0, &depth0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXBITMAP_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapHandler::Create((wxBitmap*) object_pointer0_0, (const void*) data0, (wxBitmapType) type0, (int) width0, (int) height0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBitmapHandler_php*)native_object)->Create((wxBitmap*) object_pointer0_0, (const void*) data0, (wxBitmapType) type0, (int) width0, (int) height0));

				references->AddReference(bitmap0, "wxBitmapHandler::Create at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmapHandler::Create((wxBitmap*) object_pointer0_0, (const void*) data0, (wxBitmapType) type0, (int) width0, (int) height0, (int) depth0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBitmapHandler_php*)native_object)->Create((wxBitmap*) object_pointer0_0, (const void*) data0, (wxBitmapType) type0, (int) width0, (int) height0, (int) depth0));

				references->AddReference(bitmap0, "wxBitmapHandler::Create at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmapHandler::Create\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxBitmap_free(void *object TSRMLS_DC) 
{
    zo_wxBitmap* custom_object = (zo_wxBitmap*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxBitmap_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxBitmap done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxBitmap_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxBitmap_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxBitmap* custom_object;
    custom_object = (zo_wxBitmap*) emalloc(sizeof(zo_wxBitmap));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxBitmap_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXBITMAP_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxBitmap::AddHandler(wxBitmapHandler &handler)
   Adds a handler to the end of the static list of format handlers. */
PHP_METHOD(php_wxBitmap, AddHandler)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::AddHandler\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::AddHandler call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* handler0 = 0;
	wxBitmapHandler* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&handler0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &handler0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(handler0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmapHandler*) zend_object_store_get_object(handler0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmapHandler*) zend_object_store_get_object(handler0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmapHandler*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXBITMAPHANDLER_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'handler' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(handler0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'handler' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxBitmap::AddHandler((wxBitmapHandler*) object_pointer0_0)\n\n");
				#endif

				wxBitmap::AddHandler((wxBitmapHandler*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::AddHandler\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmap::CleanUpHandlers()
   Deletes all bitmap handlers. */
PHP_METHOD(php_wxBitmap, CleanUpHandlers)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::CleanUpHandlers\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::CleanUpHandlers call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxBitmap::CleanUpHandlers()\n\n");
				#endif

				wxBitmap::CleanUpHandlers();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::CleanUpHandlers\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxBitmap::ConvertToDisabled(int brightness)
   Returns disabled (dimmed) version of the bitmap. */
PHP_METHOD(php_wxBitmap, ConvertToDisabled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::ConvertToDisabled\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::ConvertToDisabled call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long brightness0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&brightness0)\n");
		#endif

		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &brightness0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmap::ConvertToDisabled() to return new object\n\n");
				#endif

				wxBitmap value_to_return0;
				value_to_return0 = ((wxBitmap_php*)native_object)->ConvertToDisabled();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				((wxBitmap_php*)ptr)->phpObj = return_value;
				zo_wxBitmap* zo0 = (zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxBitmap_php*) ptr;


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmap::ConvertToDisabled((unsigned char) brightness0) to return new object\n\n");
				#endif

				wxBitmap value_to_return1;
				value_to_return1 = ((wxBitmap_php*)native_object)->ConvertToDisabled((unsigned char) brightness0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				((wxBitmap_php*)ptr)->phpObj = return_value;
				zo_wxBitmap* zo1 = (zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxBitmap_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::ConvertToDisabled\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmap::wxBitmap()
   Default constructor. */
PHP_METHOD(php_wxBitmap, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* bitmap1 = 0;
	wxBitmap* object_pointer1_0 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	long width2;
	long height2;
	long depth2;
	bool overload2_called = false;
	//Parameters for overload 3
	zval* sz3 = 0;
	wxSize* object_pointer3_0 = 0;
	long depth3;
	bool overload3_called = false;
	//Parameters for overload 4
	char* name4;
	long name_len4;
	long type4;
	bool overload4_called = false;
	//Parameters for overload 5
	zval* img5 = 0;
	wxImage* object_pointer5_0 = 0;
	long depth5;
	bool overload5_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bitmap1, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap1, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(bitmap1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll|l' (&width2, &height2, &depth2)\n");
		#endif

		char parse_parameters_string[] = "ll|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width2, &height2, &depth2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&sz3, php_wxSize_entry, &depth3)\n");
		#endif

		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &sz3, php_wxSize_entry, &depth3 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(sz3) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(sz3 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(sz3 TSRMLS_CC))->native_object;
					object_pointer3_0 = (wxSize*) argument_native_object;
					if (!object_pointer3_0 )
					{
						goto overload4;
					}
				}
				else if(Z_TYPE_P(sz3) != IS_NULL)
				{
					goto overload4;
				}
			}

			overload3_called = true;
			already_called = true;
		}
	}

	//Overload 4
	overload4:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|l' (&name4, &name_len4, &type4)\n");
		#endif

		char parse_parameters_string[] = "s|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name4, &name_len4, &type4 ) == SUCCESS)
		{
			overload4_called = true;
			already_called = true;
		}
	}

	//Overload 5
	overload5:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&img5, php_wxImage_entry, &depth5)\n");
		#endif

		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &img5, php_wxImage_entry, &depth5 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(img5) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxImage*) zend_object_store_get_object(img5 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxImage*) zend_object_store_get_object(img5 TSRMLS_CC))->native_object;
					object_pointer5_0 = (wxImage*) argument_native_object;
					if (!object_pointer5_0 )
					{
						zend_error(E_ERROR, "Parameter 'img' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(img5) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'img' not null, could not be retreived correctly.");
				}
			}

			overload5_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxBitmap_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer1_0)\n");
				#endif

				native_object = new wxBitmap_php(*(wxBitmap*) object_pointer1_0);

				native_object->references.Initialize();
				((wxBitmap_php*) native_object)->references.AddReference(bitmap1, "wxBitmap::wxBitmap at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width2, (int) height2)\n");
				#endif

				native_object = new wxBitmap_php((int) width2, (int) height2);

				native_object->references.Initialize();
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width2, (int) height2, (int) depth2)\n");
				#endif

				native_object = new wxBitmap_php((int) width2, (int) height2, (int) depth2);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxSize*) object_pointer3_0)\n");
				#endif

				native_object = new wxBitmap_php(*(wxSize*) object_pointer3_0);

				native_object->references.Initialize();
				((wxBitmap_php*) native_object)->references.AddReference(sz3, "wxBitmap::wxBitmap at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxSize*) object_pointer3_0, (int) depth3)\n");
				#endif

				native_object = new wxBitmap_php(*(wxSize*) object_pointer3_0, (int) depth3);

				native_object->references.Initialize();
				((wxBitmap_php*) native_object)->references.AddReference(sz3, "wxBitmap::wxBitmap at call with 2 argument(s)");
				break;
			}
		}
	}

	if(overload4_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name4, wxConvUTF8))\n");
				#endif

				native_object = new wxBitmap_php(wxString(name4, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name4, wxConvUTF8), (wxBitmapType) type4)\n");
				#endif

				native_object = new wxBitmap_php(wxString(name4, wxConvUTF8), (wxBitmapType) type4);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload5_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxImage*) object_pointer5_0)\n");
				#endif

				native_object = new wxBitmap_php(*(wxImage*) object_pointer5_0);

				native_object->references.Initialize();
				((wxBitmap_php*) native_object)->references.AddReference(img5, "wxBitmap::wxBitmap at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxImage*) object_pointer5_0, (int) depth5)\n");
				#endif

				native_object = new wxBitmap_php(*(wxImage*) object_pointer5_0, (int) depth5);

				native_object->references.Initialize();
				((wxBitmap_php*) native_object)->references.AddReference(img5, "wxBitmap::wxBitmap at call with 2 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxBitmap::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto bool wxBitmap::LoadFile(string name, wxBitmapType type)
   Loads a bitmap from a file or resource. */
PHP_METHOD(php_wxBitmap, LoadFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::LoadFile\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::LoadFile call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	long type0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|l' (&name0, &name_len0, &type0)\n");
		#endif

		char parse_parameters_string[] = "s|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0, &type0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmap::LoadFile(wxString(name0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBitmap_php*)native_object)->LoadFile(wxString(name0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmap::LoadFile(wxString(name0, wxConvUTF8), (wxBitmapType) type0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBitmap_php*)native_object)->LoadFile(wxString(name0, wxConvUTF8), (wxBitmapType) type0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::LoadFile\n");
	}
}
/* }}} */

/* {{{ proto bool wxBitmap::RemoveHandler(string name)
   Finds the handler with the given name, and removes it. */
PHP_METHOD(php_wxBitmap, RemoveHandler)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::RemoveHandler\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::RemoveHandler call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_BOOL(wxBitmap::RemoveHandler(wxString(name0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, wxBitmap::RemoveHandler(wxString(name0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::RemoveHandler\n");
	}
}
/* }}} */

/* {{{ proto bool wxBitmap::SaveFile(string name, wxBitmapType type, wxPalette palette)
   Saves a bitmap in the named file. */
PHP_METHOD(php_wxBitmap, SaveFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::SaveFile\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::SaveFile call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	long type0;
	zval* palette0 = 0;
	wxPalette* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl|z' (&name0, &name_len0, &type0, &palette0)\n");
		#endif

		char parse_parameters_string[] = "sl|z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0, &type0, &palette0 ) == SUCCESS)
		{
			if(arguments_received >= 3){
				if(Z_TYPE_P(palette0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPalette*) zend_object_store_get_object(palette0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPalette*) zend_object_store_get_object(palette0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxPalette*) argument_native_object;
					if (!object_pointer0_2 || (argument_type != PHP_WXPALETTE_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'palette' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(palette0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'palette' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmap::SaveFile(wxString(name0, wxConvUTF8), (wxBitmapType) type0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBitmap_php*)native_object)->SaveFile(wxString(name0, wxConvUTF8), (wxBitmapType) type0));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmap::SaveFile(wxString(name0, wxConvUTF8), (wxBitmapType) type0, (const wxPalette*) object_pointer0_2))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBitmap_php*)native_object)->SaveFile(wxString(name0, wxConvUTF8), (wxBitmapType) type0, (const wxPalette*) object_pointer0_2));

				references->AddReference(palette0, "wxBitmap::SaveFile at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::SaveFile\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmap::SetDepth(int depth)
   Sets the depth member (does not affect the bitmap data). */
PHP_METHOD(php_wxBitmap, SetDepth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::SetDepth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::SetDepth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long depth0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&depth0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &depth0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmap::SetDepth((int) depth0)\n\n");
				#endif

				((wxBitmap_php*)native_object)->SetDepth((int) depth0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::SetDepth\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmap::SetHeight(int height)
   Sets the height member (does not affect the bitmap data). */
PHP_METHOD(php_wxBitmap, SetHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::SetHeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::SetHeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long height0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&height0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmap::SetHeight((int) height0)\n\n");
				#endif

				((wxBitmap_php*)native_object)->SetHeight((int) height0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::SetHeight\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmap::SetWidth(int width)
   Sets the width member (does not affect the bitmap data). */
PHP_METHOD(php_wxBitmap, SetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::SetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::SetWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmap::SetWidth((int) width0)\n\n");
				#endif

				((wxBitmap_php*)native_object)->SetWidth((int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::SetWidth\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxBitmap::ConvertToImage()
   Creates an image from a platform-dependent bitmap. */
PHP_METHOD(php_wxBitmap, ConvertToImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::ConvertToImage\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::ConvertToImage call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmap::ConvertToImage() to return new object\n\n");
				#endif

				wxImage value_to_return0;
				value_to_return0 = ((wxBitmap_php*)native_object)->ConvertToImage();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo0 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::ConvertToImage\n");
	}
}
/* }}} */

/* {{{ proto bool wxBitmap::CopyFromIcon(wxIcon icon)
   Creates the bitmap from an icon. */
PHP_METHOD(php_wxBitmap, CopyFromIcon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::CopyFromIcon\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::CopyFromIcon call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* icon0 = 0;
	wxIcon* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&icon0, php_wxIcon_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &icon0, php_wxIcon_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(icon0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxIcon*) zend_object_store_get_object(icon0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxIcon*) zend_object_store_get_object(icon0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxIcon*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'icon' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(icon0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'icon' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmap::CopyFromIcon(*(wxIcon*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBitmap_php*)native_object)->CopyFromIcon(*(wxIcon*) object_pointer0_0));

				references->AddReference(icon0, "wxBitmap::CopyFromIcon at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::CopyFromIcon\n");
	}
}
/* }}} */

/* {{{ proto bool wxBitmap::Create(int width, int height, int depth)
   Creates a fresh bitmap. */
PHP_METHOD(php_wxBitmap, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::Create\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::Create call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	long height0;
	long depth0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* sz1 = 0;
	wxSize* object_pointer1_0 = 0;
	long depth1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll|l' (&width0, &height0, &depth0)\n");
		#endif

		char parse_parameters_string[] = "ll|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0, &height0, &depth0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&sz1, php_wxSize_entry, &depth1)\n");
		#endif

		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &sz1, php_wxSize_entry, &depth1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(sz1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(sz1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(sz1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxSize*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'sz' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(sz1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'sz' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmap::Create((int) width0, (int) height0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBitmap_php*)native_object)->Create((int) width0, (int) height0));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmap::Create((int) width0, (int) height0, (int) depth0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBitmap_php*)native_object)->Create((int) width0, (int) height0, (int) depth0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmap::Create(*(wxSize*) object_pointer1_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBitmap_php*)native_object)->Create(*(wxSize*) object_pointer1_0));

				references->AddReference(sz1, "wxBitmap::Create at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmap::Create(*(wxSize*) object_pointer1_0, (int) depth1))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBitmap_php*)native_object)->Create(*(wxSize*) object_pointer1_0, (int) depth1));

				references->AddReference(sz1, "wxBitmap::Create at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::Create\n");
	}
}
/* }}} */

/* {{{ proto wxBitmapHandler wxBitmap::FindHandler(string name)
   Finds the handler with the given name. */
PHP_METHOD(php_wxBitmap, FindHandler)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::FindHandler\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::FindHandler call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* extension1;
	long extension_len1;
	long bitmapType1;
	bool overload1_called = false;
	//Parameters for overload 2
	long bitmapType2;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl' (&extension1, &extension_len1, &bitmapType1)\n");
		#endif

		char parse_parameters_string[] = "sl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &extension1, &extension_len1, &bitmapType1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&bitmapType2)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmapType2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxBitmap::FindHandler(wxString(name0, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxBitmapHandler_php* value_to_return1;
				value_to_return1 = (wxBitmapHandler_php*) wxBitmap::FindHandler(wxString(name0, wxConvUTF8));
				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxBitmapHandler_entry);
					((zo_wxBitmapHandler*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmapHandler_php*) value_to_return1;
				}



				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxBitmap::FindHandler(wxString(extension1, wxConvUTF8), (wxBitmapType) bitmapType1) to return object pointer\n\n");
				#endif

				wxBitmapHandler_php* value_to_return2;
				value_to_return2 = (wxBitmapHandler_php*) wxBitmap::FindHandler(wxString(extension1, wxConvUTF8), (wxBitmapType) bitmapType1);
				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxBitmapHandler_entry);
					((zo_wxBitmapHandler*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmapHandler_php*) value_to_return2;
				}



				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxBitmap::FindHandler((wxBitmapType) bitmapType2) to return object pointer\n\n");
				#endif

				wxBitmapHandler_php* value_to_return1;
				value_to_return1 = (wxBitmapHandler_php*) wxBitmap::FindHandler((wxBitmapType) bitmapType2);
				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxBitmapHandler_entry);
					((zo_wxBitmapHandler*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmapHandler_php*) value_to_return1;
				}



				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::FindHandler\n");
	}
}
/* }}} */

/* {{{ proto int wxBitmap::GetDepth()
   Gets the colour depth of the bitmap. */
PHP_METHOD(php_wxBitmap, GetDepth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::GetDepth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::GetDepth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxBitmap::GetDepth())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxBitmap_php*)native_object)->GetDepth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::GetDepth\n");
	}
}
/* }}} */

/* {{{ proto int wxBitmap::GetHeight()
   Gets the height of the bitmap in pixels. */
PHP_METHOD(php_wxBitmap, GetHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::GetHeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::GetHeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxBitmap::GetHeight())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxBitmap_php*)native_object)->GetHeight());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::GetHeight\n");
	}
}
/* }}} */

/* {{{ proto wxMask wxBitmap::GetMask()
   Gets the associated mask (if any) which may have been loaded from a file or set for the bitmap. */
PHP_METHOD(php_wxBitmap, GetMask)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::GetMask\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::GetMask call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmap::GetMask() to return object pointer\n\n");
				#endif

				wxMask_php* value_to_return0;
				value_to_return0 = (wxMask_php*) ((wxBitmap_php*)native_object)->GetMask();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxMask_entry);
					((zo_wxMask*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxMask_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxBitmap::GetMask at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::GetMask\n");
	}
}
/* }}} */

/* {{{ proto wxPalette wxBitmap::GetPalette()
   Gets the associated palette (if any) which may have been loaded from a file or set for the bitmap. */
PHP_METHOD(php_wxBitmap, GetPalette)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::GetPalette\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::GetPalette call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmap::GetPalette() to return object pointer\n\n");
				#endif

				wxPalette_php* value_to_return0;
				value_to_return0 = (wxPalette_php*) ((wxBitmap_php*)native_object)->GetPalette();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxPalette_entry);
					((zo_wxPalette*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPalette_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxBitmap::GetPalette at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::GetPalette\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxBitmap::GetSize()
   Returns the size of the bitmap in pixels. */
PHP_METHOD(php_wxBitmap, GetSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::GetSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::GetSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmap::GetSize() to return new object\n\n");
				#endif

				wxSize value_to_return0;
				value_to_return0 = ((wxBitmap_php*)native_object)->GetSize();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				((wxSize_php*)ptr)->phpObj = return_value;
				zo_wxSize* zo0 = (zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxSize_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::GetSize\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxBitmap::GetSubBitmap(wxRect rect)
   Returns a sub bitmap of the current one as long as the rect belongs entirely to the bitmap. */
PHP_METHOD(php_wxBitmap, GetSubBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::GetSubBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::GetSubBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* rect0 = 0;
	wxRect* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxRect*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmap::GetSubBitmap(*(wxRect*) object_pointer0_0) to return new object\n\n");
				#endif

				wxBitmap value_to_return1;
				value_to_return1 = ((wxBitmap_php*)native_object)->GetSubBitmap(*(wxRect*) object_pointer0_0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				((wxBitmap_php*)ptr)->phpObj = return_value;
				zo_wxBitmap* zo1 = (zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxBitmap_php*) ptr;

				references->AddReference(rect0, "wxBitmap::GetSubBitmap at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::GetSubBitmap\n");
	}
}
/* }}} */

/* {{{ proto int wxBitmap::GetWidth()
   Gets the width of the bitmap in pixels. */
PHP_METHOD(php_wxBitmap, GetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::GetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::GetWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxBitmap::GetWidth())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxBitmap_php*)native_object)->GetWidth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::GetWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmap::InitStandardHandlers()
   Adds the standard bitmap format handlers, which, depending on wxWidgets configuration, can be handlers for Windows bitmap, Windows bitmap resource, and XPM. */
PHP_METHOD(php_wxBitmap, InitStandardHandlers)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::InitStandardHandlers\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::InitStandardHandlers call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxBitmap::InitStandardHandlers()\n\n");
				#endif

				wxBitmap::InitStandardHandlers();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::InitStandardHandlers\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmap::InsertHandler(wxBitmapHandler &handler)
   Adds a handler at the start of the static list of format handlers. */
PHP_METHOD(php_wxBitmap, InsertHandler)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::InsertHandler\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::InsertHandler call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* handler0 = 0;
	wxBitmapHandler* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&handler0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &handler0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(handler0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmapHandler*) zend_object_store_get_object(handler0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmapHandler*) zend_object_store_get_object(handler0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmapHandler*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXBITMAPHANDLER_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'handler' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(handler0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'handler' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxBitmap::InsertHandler((wxBitmapHandler*) object_pointer0_0)\n\n");
				#endif

				wxBitmap::InsertHandler((wxBitmapHandler*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::InsertHandler\n");
	}
}
/* }}} */

/* {{{ proto bool wxBitmap::IsOk()
   Returns true if bitmap data is present. */
PHP_METHOD(php_wxBitmap, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::IsOk call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBitmap::IsOk())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBitmap_php*)native_object)->IsOk());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::IsOk\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmap::SetMask(wxMask &mask)
   Sets the mask for this bitmap. */
PHP_METHOD(php_wxBitmap, SetMask)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::SetMask\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::SetMask call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* mask0 = 0;
	wxMask* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&mask0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &mask0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(mask0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxMask*) zend_object_store_get_object(mask0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxMask*) zend_object_store_get_object(mask0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxMask*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXMASK_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'mask' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(mask0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'mask' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmap::SetMask((wxMask*) object_pointer0_0)\n\n");
				#endif

				((wxBitmap_php*)native_object)->SetMask((wxMask*) object_pointer0_0);

				references->AddReference(mask0, "wxBitmap::SetMask at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::SetMask\n");
	}
}
/* }}} */

/* {{{ proto  wxBitmap::SetPalette(wxPalette palette)
   Sets the associated palette. */
PHP_METHOD(php_wxBitmap, SetPalette)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBitmap::SetPalette\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBitmap* current_object;
	wxphp_object_type current_object_type;
	wxBitmap_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBitmap*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBitmap::SetPalette call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBITMAP_TYPE){
				references = &((wxBitmap_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* palette0 = 0;
	wxPalette* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&palette0, php_wxPalette_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &palette0, php_wxPalette_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(palette0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPalette*) zend_object_store_get_object(palette0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPalette*) zend_object_store_get_object(palette0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxPalette*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'palette' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(palette0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'palette' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBitmap::SetPalette(*(wxPalette*) object_pointer0_0)\n\n");
				#endif

				((wxBitmap_php*)native_object)->SetPalette(*(wxPalette*) object_pointer0_0);

				references->AddReference(palette0, "wxBitmap::SetPalette at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBitmap::SetPalette\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxMask_free(void *object TSRMLS_DC) 
{
    zo_wxMask* custom_object = (zo_wxMask*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxMask_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxMask done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxMask_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxMask_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxMask* custom_object;
    custom_object = (zo_wxMask*) emalloc(sizeof(zo_wxMask));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxMask_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXMASK_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto bool wxMask::Create(wxBitmap bitmap, int index)
   Constructs a mask from a bitmap and a palette index that indicates the background. */
PHP_METHOD(php_wxMask, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxMask::Create\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxMask* current_object;
	wxphp_object_type current_object_type;
	wxMask_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxMask*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxMask::Create call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXMASK_TYPE){
				references = &((wxMask_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	long index0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* bitmap1 = 0;
	wxBitmap* object_pointer1_0 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* bitmap2 = 0;
	wxBitmap* object_pointer2_0 = 0;
	zval* colour2 = 0;
	wxColour* object_pointer2_1 = 0;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol' (&bitmap0, php_wxBitmap_entry, &index0)\n");
		#endif

		char parse_parameters_string[] = "Ol";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap0, php_wxBitmap_entry, &index0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bitmap1, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap1, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(bitmap1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&bitmap2, php_wxBitmap_entry, &colour2, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap2, php_wxBitmap_entry, &colour2, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer2_0 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(colour2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour2 TSRMLS_CC))->native_object;
					object_pointer2_1 = (wxColour*) argument_native_object;
					if (!object_pointer2_1 )
					{
						zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxMask::Create(*(wxBitmap*) object_pointer0_0, (int) index0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxMask_php*)native_object)->Create(*(wxBitmap*) object_pointer0_0, (int) index0));

				references->AddReference(bitmap0, "wxMask::Create at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxMask::Create(*(wxBitmap*) object_pointer1_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxMask_php*)native_object)->Create(*(wxBitmap*) object_pointer1_0));

				references->AddReference(bitmap1, "wxMask::Create at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxMask::Create(*(wxBitmap*) object_pointer2_0, *(wxColour*) object_pointer2_1))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxMask_php*)native_object)->Create(*(wxBitmap*) object_pointer2_0, *(wxColour*) object_pointer2_1));

				references->AddReference(bitmap2, "wxMask::Create at call with 2 argument(s)");
				references->AddReference(colour2, "wxMask::Create at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxMask::Create\n");
	}
}
/* }}} */

/* {{{ proto  wxMask::wxMask()
   Default constructor. */
PHP_METHOD(php_wxMask, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxMask::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxMask* current_object;
	wxMask_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* bitmap1 = 0;
	wxBitmap* object_pointer1_0 = 0;
	long index1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* bitmap2 = 0;
	wxBitmap* object_pointer2_0 = 0;
	bool overload2_called = false;
	//Parameters for overload 3
	zval* bitmap3 = 0;
	wxBitmap* object_pointer3_0 = 0;
	zval* colour3 = 0;
	wxColour* object_pointer3_1 = 0;
	bool overload3_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol' (&bitmap1, php_wxBitmap_entry, &index1)\n");
		#endif

		char parse_parameters_string[] = "Ol";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap1, php_wxBitmap_entry, &index1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(bitmap1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bitmap2, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap2, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer2_0 )
					{
						goto overload3;
					}
				}
				else if(Z_TYPE_P(bitmap2) != IS_NULL)
				{
					goto overload3;
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&bitmap3, php_wxBitmap_entry, &colour3, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap3, php_wxBitmap_entry, &colour3, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap3) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap3 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap3 TSRMLS_CC))->native_object;
					object_pointer3_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer3_0 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap3) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(colour3) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour3 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour3 TSRMLS_CC))->native_object;
					object_pointer3_1 = (wxColour*) argument_native_object;
					if (!object_pointer3_1 )
					{
						zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour3) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
				}
			}

			overload3_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxMask_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer1_0, (int) index1)\n");
				#endif

				native_object = new wxMask_php(*(wxBitmap*) object_pointer1_0, (int) index1);

				native_object->references.Initialize();
				((wxMask_php*) native_object)->references.AddReference(bitmap1, "wxMask::wxMask at call with 2 argument(s)");
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer2_0)\n");
				#endif

				native_object = new wxMask_php(*(wxBitmap*) object_pointer2_0);

				native_object->references.Initialize();
				((wxMask_php*) native_object)->references.AddReference(bitmap2, "wxMask::wxMask at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer3_0, *(wxColour*) object_pointer3_1)\n");
				#endif

				native_object = new wxMask_php(*(wxBitmap*) object_pointer3_0, *(wxColour*) object_pointer3_1);

				native_object->references.Initialize();
				((wxMask_php*) native_object)->references.AddReference(bitmap3, "wxMask::wxMask at call with 2 argument(s)");
				((wxMask_php*) native_object)->references.AddReference(colour3, "wxMask::wxMask at call with 2 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxMask*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxMask::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxBrush_free(void *object TSRMLS_DC) 
{
    zo_wxBrush* custom_object = (zo_wxBrush*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxBrush_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxBrush done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxBrush_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxBrush_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxBrush* custom_object;
    custom_object = (zo_wxBrush*) emalloc(sizeof(zo_wxBrush));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxBrush_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXBRUSH_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto wxColour wxBrush::GetColour()
   Returns a reference to the brush colour. */
PHP_METHOD(php_wxBrush, GetColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBrush::GetColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBrush* current_object;
	wxphp_object_type current_object_type;
	wxBrush_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBrush*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBrush::GetColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBRUSH_TYPE){
				references = &((wxBrush_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBrush::GetColour() to return new object\n\n");
				#endif

				wxColour value_to_return0;
				value_to_return0 = ((wxBrush_php*)native_object)->GetColour();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				((wxColour_php*)ptr)->phpObj = return_value;
				zo_wxColour* zo0 = (zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxColour_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBrush::GetColour\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxBrush::GetStipple()
   Gets a pointer to the stipple bitmap. */
PHP_METHOD(php_wxBrush, GetStipple)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBrush::GetStipple\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBrush* current_object;
	wxphp_object_type current_object_type;
	wxBrush_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBrush*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBrush::GetStipple call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBRUSH_TYPE){
				references = &((wxBrush_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBrush::GetStipple() to return object pointer\n\n");
				#endif

				wxBitmap_php* value_to_return0;
				value_to_return0 = (wxBitmap_php*) ((wxBrush_php*)native_object)->GetStipple();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxBitmap_entry);
					((zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmap_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxBrush::GetStipple at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBrush::GetStipple\n");
	}
}
/* }}} */

/* {{{ proto wxBrushStyle wxBrush::GetStyle()
   Returns the brush style, one of the wxBrushStyle values. */
PHP_METHOD(php_wxBrush, GetStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBrush::GetStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBrush* current_object;
	wxphp_object_type current_object_type;
	wxBrush_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBrush*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBrush::GetStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBRUSH_TYPE){
				references = &((wxBrush_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxBrush::GetStyle())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxBrush_php*)native_object)->GetStyle());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBrush::GetStyle\n");
	}
}
/* }}} */

/* {{{ proto bool wxBrush::IsHatch()
   Returns true if the style of the brush is any of hatched fills. */
PHP_METHOD(php_wxBrush, IsHatch)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBrush::IsHatch\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBrush* current_object;
	wxphp_object_type current_object_type;
	wxBrush_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBrush*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBrush::IsHatch call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBRUSH_TYPE){
				references = &((wxBrush_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBrush::IsHatch())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBrush_php*)native_object)->IsHatch());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBrush::IsHatch\n");
	}
}
/* }}} */

/* {{{ proto bool wxBrush::IsNonTransparent()
   Returns true if the brush is a valid non-transparent brush. */
PHP_METHOD(php_wxBrush, IsNonTransparent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBrush::IsNonTransparent\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBrush* current_object;
	wxphp_object_type current_object_type;
	wxBrush_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBrush*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBrush::IsNonTransparent call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBRUSH_TYPE){
				references = &((wxBrush_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBrush::IsNonTransparent())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBrush_php*)native_object)->IsNonTransparent());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBrush::IsNonTransparent\n");
	}
}
/* }}} */

/* {{{ proto bool wxBrush::IsOk()
   Returns true if the brush is initialised. */
PHP_METHOD(php_wxBrush, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBrush::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBrush* current_object;
	wxphp_object_type current_object_type;
	wxBrush_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBrush*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBrush::IsOk call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBRUSH_TYPE){
				references = &((wxBrush_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBrush::IsOk())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBrush_php*)native_object)->IsOk());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBrush::IsOk\n");
	}
}
/* }}} */

/* {{{ proto bool wxBrush::IsTransparent()
   Returns true if the brush is transparent. */
PHP_METHOD(php_wxBrush, IsTransparent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBrush::IsTransparent\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBrush* current_object;
	wxphp_object_type current_object_type;
	wxBrush_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBrush*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBrush::IsTransparent call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBRUSH_TYPE){
				references = &((wxBrush_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxBrush::IsTransparent())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxBrush_php*)native_object)->IsTransparent());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBrush::IsTransparent\n");
	}
}
/* }}} */

/* {{{ proto  wxBrush::SetColour(wxColour colour)
   Sets the brush colour using red, green and blue values. */
PHP_METHOD(php_wxBrush, SetColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBrush::SetColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBrush* current_object;
	wxphp_object_type current_object_type;
	wxBrush_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBrush*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBrush::SetColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBRUSH_TYPE){
				references = &((wxBrush_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colour0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	long red1;
	long green1;
	long blue1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&red1, &green1, &blue1)\n");
		#endif

		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &red1, &green1, &blue1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBrush::SetColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxBrush_php*)native_object)->SetColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colour0, "wxBrush::SetColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBrush::SetColour((unsigned char) red1, (unsigned char) green1, (unsigned char) blue1)\n\n");
				#endif

				((wxBrush_php*)native_object)->SetColour((unsigned char) red1, (unsigned char) green1, (unsigned char) blue1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBrush::SetColour\n");
	}
}
/* }}} */

/* {{{ proto  wxBrush::SetStipple(wxBitmap bitmap)
   Sets the stipple bitmap. */
PHP_METHOD(php_wxBrush, SetStipple)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBrush::SetStipple\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBrush* current_object;
	wxphp_object_type current_object_type;
	wxBrush_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBrush*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBrush::SetStipple call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBRUSH_TYPE){
				references = &((wxBrush_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bitmap0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBrush::SetStipple(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif

				((wxBrush_php*)native_object)->SetStipple(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bitmap0, "wxBrush::SetStipple at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBrush::SetStipple\n");
	}
}
/* }}} */

/* {{{ proto  wxBrush::SetStyle(wxBrushStyle style)
   Sets the brush style. */
PHP_METHOD(php_wxBrush, SetStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBrush::SetStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBrush* current_object;
	wxphp_object_type current_object_type;
	wxBrush_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxBrush*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxBrush::SetStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXBRUSH_TYPE){
				references = &((wxBrush_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&style0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxBrush::SetStyle((wxBrushStyle) style0)\n\n");
				#endif

				((wxBrush_php*)native_object)->SetStyle((wxBrushStyle) style0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxBrush::SetStyle\n");
	}
}
/* }}} */

/* {{{ proto  wxBrush::wxBrush()
   Default constructor. */
PHP_METHOD(php_wxBrush, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxBrush::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxBrush* current_object;
	wxBrush_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* colour1 = 0;
	wxColour* object_pointer1_0 = 0;
	long style1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* stippleBitmap2 = 0;
	wxBitmap* object_pointer2_0 = 0;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&colour1, php_wxColour_entry, &style1)\n");
		#endif

		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour1, php_wxColour_entry, &style1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxColour*) argument_native_object;
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(colour1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&stippleBitmap2, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stippleBitmap2, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stippleBitmap2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(stippleBitmap2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(stippleBitmap2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer2_0 )
					{
						zend_error(E_ERROR, "Parameter 'stippleBitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(stippleBitmap2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'stippleBitmap' not null, could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxBrush_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer1_0)\n");
				#endif

				native_object = new wxBrush_php(*(wxColour*) object_pointer1_0);

				native_object->references.Initialize();
				((wxBrush_php*) native_object)->references.AddReference(colour1, "wxBrush::wxBrush at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer1_0, (wxBrushStyle) style1)\n");
				#endif

				native_object = new wxBrush_php(*(wxColour*) object_pointer1_0, (wxBrushStyle) style1);

				native_object->references.Initialize();
				((wxBrush_php*) native_object)->references.AddReference(colour1, "wxBrush::wxBrush at call with 2 argument(s)");
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxBitmap*) object_pointer2_0)\n");
				#endif

				native_object = new wxBrush_php(*(wxBitmap*) object_pointer2_0);

				native_object->references.Initialize();
				((wxBrush_php*) native_object)->references.AddReference(stippleBitmap2, "wxBrush::wxBrush at call with 1 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxBrush*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxBrush::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxColour_free(void *object TSRMLS_DC) 
{
    zo_wxColour* custom_object = (zo_wxColour*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxColour_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxColour done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxColour_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxColour_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxColour* custom_object;
    custom_object = (zo_wxColour*) emalloc(sizeof(zo_wxColour));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxColour_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXCOLOUR_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxColour::wxColour(int red, int green, int blue, int alpha) */
PHP_METHOD(php_wxColour, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxColour::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxColour* current_object;
	wxColour_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	long red0;
	long green0;
	long blue0;
	long alpha0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* colourName1;
	long colourName_len1;
	bool overload1_called = false;
	//Parameters for overload 2
	long colRGB2;
	bool overload2_called = false;
	//Parameters for overload 3
	zval* colour3 = 0;
	wxColour* object_pointer3_0 = 0;
	bool overload3_called = false;
	//Parameters for overload 4
	bool overload4_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll|l' (&red0, &green0, &blue0, &alpha0)\n");
		#endif

		char parse_parameters_string[] = "lll|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &red0, &green0, &blue0, &alpha0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&colourName1, &colourName_len1)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colourName1, &colourName_len1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&colRGB2)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colRGB2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour3, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour3, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour3) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour3 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour3 TSRMLS_CC))->native_object;
					object_pointer3_0 = (wxColour*) argument_native_object;
					if (!object_pointer3_0 )
					{
						goto overload4;
					}
				}
				else if(Z_TYPE_P(colour3) != IS_NULL)
				{
					goto overload4;
				}
			}

			overload3_called = true;
			already_called = true;
		}
	}

	//Overload 4
	overload4:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload4_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((unsigned char) red0, (unsigned char) green0, (unsigned char) blue0)\n");
				#endif

				native_object = new wxColour_php((unsigned char) red0, (unsigned char) green0, (unsigned char) blue0);

				native_object->references.Initialize();
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((unsigned char) red0, (unsigned char) green0, (unsigned char) blue0, (unsigned char) alpha0)\n");
				#endif

				native_object = new wxColour_php((unsigned char) red0, (unsigned char) green0, (unsigned char) blue0, (unsigned char) alpha0);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(colourName1, wxConvUTF8))\n");
				#endif

				native_object = new wxColour_php(wxString(colourName1, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((unsigned long) colRGB2)\n");
				#endif

				native_object = new wxColour_php((unsigned long) colRGB2);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer3_0)\n");
				#endif

				native_object = new wxColour_php(*(wxColour*) object_pointer3_0);

				native_object->references.Initialize();
				((wxColour_php*) native_object)->references.AddReference(colour3, "wxColour::wxColour at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload4_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxColour_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxColour*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxColour::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxColour::Set(int RGB)
   Sets the RGB intensity values using the given values (first overload), extracting them from the packed long (second overload), using the given string (third overload). */
PHP_METHOD(php_wxColour, Set)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxColour::Set\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxColour* current_object;
	wxphp_object_type current_object_type;
	wxColour_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxColour*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxColour::Set call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCOLOUR_TYPE){
				references = &((wxColour_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long RGB0;
	bool overload0_called = false;
	//Parameters for overload 1
	long red1;
	long green1;
	long blue1;
	long alpha1;
	bool overload1_called = false;
	//Parameters for overload 2
	char* str2;
	long str_len2;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&RGB0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &RGB0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 3  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll|l' (&red1, &green1, &blue1, &alpha1)\n");
		#endif

		char parse_parameters_string[] = "lll|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &red1, &green1, &blue1, &alpha1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&str2, &str_len2)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &str2, &str_len2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxColour::Set((unsigned long) RGB0)\n\n");
				#endif

				((wxColour_php*)native_object)->Set((unsigned long) RGB0);


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxColour::Set((unsigned char) red1, (unsigned char) green1, (unsigned char) blue1)\n\n");
				#endif

				((wxColour_php*)native_object)->Set((unsigned char) red1, (unsigned char) green1, (unsigned char) blue1);


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxColour::Set((unsigned char) red1, (unsigned char) green1, (unsigned char) blue1, (unsigned char) alpha1)\n\n");
				#endif

				((wxColour_php*)native_object)->Set((unsigned char) red1, (unsigned char) green1, (unsigned char) blue1, (unsigned char) alpha1);


				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxColour::Set(wxString(str2, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxColour_php*)native_object)->Set(wxString(str2, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxColour::Set\n");
	}
}
/* }}} */

/* {{{ proto int wxColour::Red()
   Returns the red intensity. */
PHP_METHOD(php_wxColour, Red)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxColour::Red\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxColour* current_object;
	wxphp_object_type current_object_type;
	wxColour_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxColour*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxColour::Red call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCOLOUR_TYPE){
				references = &((wxColour_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxColour::Red())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxColour_php*)native_object)->Red());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxColour::Red\n");
	}
}
/* }}} */

/* {{{ proto  wxColour::SetRGB(int colRGB)
   Sets the RGB or RGBA colour values from a single 32 bit value. */
PHP_METHOD(php_wxColour, SetRGB)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxColour::SetRGB\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxColour* current_object;
	wxphp_object_type current_object_type;
	wxColour_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxColour*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxColour::SetRGB call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCOLOUR_TYPE){
				references = &((wxColour_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long colRGB0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&colRGB0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colRGB0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxColour::SetRGB((wxUint32) colRGB0)\n\n");
				#endif

				((wxColour_php*)native_object)->SetRGB((wxUint32) colRGB0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxColour::SetRGB\n");
	}
}
/* }}} */

/* {{{ proto  wxColour::SetRGBA(int colRGBA)
   Sets the RGB or RGBA colour values from a single 32 bit value. */
PHP_METHOD(php_wxColour, SetRGBA)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxColour::SetRGBA\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxColour* current_object;
	wxphp_object_type current_object_type;
	wxColour_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxColour*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxColour::SetRGBA call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCOLOUR_TYPE){
				references = &((wxColour_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long colRGBA0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&colRGBA0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colRGBA0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxColour::SetRGBA((wxUint32) colRGBA0)\n\n");
				#endif

				((wxColour_php*)native_object)->SetRGBA((wxUint32) colRGBA0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxColour::SetRGBA\n");
	}
}
/* }}} */

/* {{{ proto int wxColour::Blue()
   Returns the blue intensity. */
PHP_METHOD(php_wxColour, Blue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxColour::Blue\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxColour* current_object;
	wxphp_object_type current_object_type;
	wxColour_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxColour*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxColour::Blue call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCOLOUR_TYPE){
				references = &((wxColour_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxColour::Blue())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxColour_php*)native_object)->Blue());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxColour::Blue\n");
	}
}
/* }}} */

/* {{{ proto int wxColour::Green()
   Returns the green intensity. */
PHP_METHOD(php_wxColour, Green)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxColour::Green\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxColour* current_object;
	wxphp_object_type current_object_type;
	wxColour_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxColour*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxColour::Green call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCOLOUR_TYPE){
				references = &((wxColour_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxColour::Green())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxColour_php*)native_object)->Green());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxColour::Green\n");
	}
}
/* }}} */

/* {{{ proto int wxColour::GetRGBA()
   Gets the RGB or RGBA colour values as a single 32 bit value. */
PHP_METHOD(php_wxColour, GetRGBA)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxColour::GetRGBA\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxColour* current_object;
	wxphp_object_type current_object_type;
	wxColour_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxColour*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxColour::GetRGBA call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCOLOUR_TYPE){
				references = &((wxColour_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxColour::GetRGBA())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxColour_php*)native_object)->GetRGBA());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxColour::GetRGBA\n");
	}
}
/* }}} */

/* {{{ proto int wxColour::GetRGB()
   Gets the RGB or RGBA colour values as a single 32 bit value. */
PHP_METHOD(php_wxColour, GetRGB)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxColour::GetRGB\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxColour* current_object;
	wxphp_object_type current_object_type;
	wxColour_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxColour*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxColour::GetRGB call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCOLOUR_TYPE){
				references = &((wxColour_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxColour::GetRGB())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxColour_php*)native_object)->GetRGB());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxColour::GetRGB\n");
	}
}
/* }}} */

/* {{{ proto int wxColour::Alpha()
   Returns the alpha value, on platforms where alpha is not yet supported, this always returns wxALPHA_OPAQUE. */
PHP_METHOD(php_wxColour, Alpha)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxColour::Alpha\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxColour* current_object;
	wxphp_object_type current_object_type;
	wxColour_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxColour*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxColour::Alpha call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCOLOUR_TYPE){
				references = &((wxColour_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxColour::Alpha())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxColour_php*)native_object)->Alpha());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxColour::Alpha\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxCursor_free(void *object TSRMLS_DC) 
{
    zo_wxCursor* custom_object = (zo_wxCursor*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxCursor_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxCursor done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxCursor_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxCursor_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxCursor* custom_object;
    custom_object = (zo_wxCursor*) emalloc(sizeof(zo_wxCursor));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxCursor_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXCURSOR_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto bool wxCursor::IsOk()
   Returns true if cursor data is present. */
PHP_METHOD(php_wxCursor, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCursor::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCursor* current_object;
	wxphp_object_type current_object_type;
	wxCursor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxCursor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxCursor::IsOk call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCURSOR_TYPE){
				references = &((wxCursor_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxCursor::IsOk())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxCursor_php*)native_object)->IsOk());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxCursor::IsOk\n");
	}
}
/* }}} */

/* {{{ proto  wxCursor::wxCursor()
   Default constructor. */
PHP_METHOD(php_wxCursor, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxCursor::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxCursor* current_object;
	wxCursor_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* image1 = 0;
	wxImage* object_pointer1_0 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* cursor2 = 0;
	wxCursor* object_pointer2_0 = 0;
	bool overload2_called = false;
	//Parameters for overload 3
	char* cursorName3;
	long cursorName_len3;
	long type3;
	long hotSpotX3;
	long hotSpotY3;
	bool overload3_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&image1, php_wxImage_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &image1, php_wxImage_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(image1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxImage*) zend_object_store_get_object(image1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxImage*) zend_object_store_get_object(image1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxImage*) argument_native_object;
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(image1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&cursor2, php_wxCursor_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &cursor2, php_wxCursor_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(cursor2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxCursor*) zend_object_store_get_object(cursor2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxCursor*) zend_object_store_get_object(cursor2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxCursor*) argument_native_object;
					if (!object_pointer2_0 )
					{
						goto overload3;
					}
				}
				else if(Z_TYPE_P(cursor2) != IS_NULL)
				{
					goto overload3;
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received >= 1  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|lll' (&cursorName3, &cursorName_len3, &type3, &hotSpotX3, &hotSpotY3)\n");
		#endif

		char parse_parameters_string[] = "s|lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &cursorName3, &cursorName_len3, &type3, &hotSpotX3, &hotSpotY3 ) == SUCCESS)
		{
			overload3_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxCursor_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxImage*) object_pointer1_0)\n");
				#endif

				native_object = new wxCursor_php(*(wxImage*) object_pointer1_0);

				native_object->references.Initialize();
				((wxCursor_php*) native_object)->references.AddReference(image1, "wxCursor::wxCursor at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxCursor*) object_pointer2_0)\n");
				#endif

				native_object = new wxCursor_php(*(wxCursor*) object_pointer2_0);

				native_object->references.Initialize();
				((wxCursor_php*) native_object)->references.AddReference(cursor2, "wxCursor::wxCursor at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(cursorName3, wxConvUTF8))\n");
				#endif

				native_object = new wxCursor_php(wxString(cursorName3, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(cursorName3, wxConvUTF8), (wxBitmapType) type3)\n");
				#endif

				native_object = new wxCursor_php(wxString(cursorName3, wxConvUTF8), (wxBitmapType) type3);

				native_object->references.Initialize();
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(cursorName3, wxConvUTF8), (wxBitmapType) type3, (int) hotSpotX3)\n");
				#endif

				native_object = new wxCursor_php(wxString(cursorName3, wxConvUTF8), (wxBitmapType) type3, (int) hotSpotX3);

				native_object->references.Initialize();
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(cursorName3, wxConvUTF8), (wxBitmapType) type3, (int) hotSpotX3, (int) hotSpotY3)\n");
				#endif

				native_object = new wxCursor_php(wxString(cursorName3, wxConvUTF8), (wxBitmapType) type3, (int) hotSpotX3, (int) hotSpotY3);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxCursor*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxCursor::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxDCClipper_free(void *object TSRMLS_DC) 
{
    zo_wxDCClipper* custom_object = (zo_wxDCClipper*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxDCClipper_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxDCClipper done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxDCClipper_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxDCClipper_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxDCClipper* custom_object;
    custom_object = (zo_wxDCClipper*) emalloc(sizeof(zo_wxDCClipper));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxDCClipper_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXDCCLIPPER_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxDCClipper::wxDCClipper(wxDC &dc, wxRegion region)
   Sets the clipping region to the specified region/coordinates. */
PHP_METHOD(php_wxDCClipper, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxDCClipper::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxDCClipper* current_object;
	wxDCClipper_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	zval* dc0 = 0;
	wxDC* object_pointer0_0 = 0;
	zval* region0 = 0;
	wxRegion* object_pointer0_1 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* dc1 = 0;
	wxDC* object_pointer1_0 = 0;
	zval* rect1 = 0;
	wxRect* object_pointer1_1 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* dc2 = 0;
	wxDC* object_pointer2_0 = 0;
	long x2;
	long y2;
	long w2;
	long h2;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'oO' (&dc0, &region0, php_wxRegion_entry)\n");
		#endif

		char parse_parameters_string[] = "oO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc0, &region0, php_wxRegion_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxDC*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
					goto overload1;
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(region0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRegion*) zend_object_store_get_object(region0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRegion*) zend_object_store_get_object(region0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxRegion*) argument_native_object;
					if (!object_pointer0_1 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(region0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'oO' (&dc1, &rect1, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "oO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc1, &rect1, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxDC*) argument_native_object;
					if (!object_pointer1_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(dc1) != IS_NULL)
				{
					goto overload2;
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(rect1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect1 TSRMLS_CC))->native_object;
					object_pointer1_1 = (wxRect*) argument_native_object;
					if (!object_pointer1_1 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(rect1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ollll' (&dc2, &x2, &y2, &w2, &h2)\n");
		#endif

		char parse_parameters_string[] = "ollll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &dc2, &x2, &y2, &w2, &h2 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(dc2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxDC*) argument_native_object;
					if (!object_pointer2_0 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxDC*) object_pointer0_0, *(wxRegion*) object_pointer0_1)\n");
				#endif

				native_object = new wxDCClipper_php(*(wxDC*) object_pointer0_0, *(wxRegion*) object_pointer0_1);

				native_object->references.Initialize();
				((wxDCClipper_php*) native_object)->references.AddReference(dc0, "wxDCClipper::wxDCClipper at call with 2 argument(s)");
				((wxDCClipper_php*) native_object)->references.AddReference(region0, "wxDCClipper::wxDCClipper at call with 2 argument(s)");
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxDC*) object_pointer1_0, *(wxRect*) object_pointer1_1)\n");
				#endif

				native_object = new wxDCClipper_php(*(wxDC*) object_pointer1_0, *(wxRect*) object_pointer1_1);

				native_object->references.Initialize();
				((wxDCClipper_php*) native_object)->references.AddReference(dc1, "wxDCClipper::wxDCClipper at call with 2 argument(s)");
				((wxDCClipper_php*) native_object)->references.AddReference(rect1, "wxDCClipper::wxDCClipper at call with 2 argument(s)");
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxDC*) object_pointer2_0, (wxCoord) x2, (wxCoord) y2, (wxCoord) w2, (wxCoord) h2)\n");
				#endif

				native_object = new wxDCClipper_php(*(wxDC*) object_pointer2_0, (wxCoord) x2, (wxCoord) y2, (wxCoord) w2, (wxCoord) h2);

				native_object->references.Initialize();
				((wxDCClipper_php*) native_object)->references.AddReference(dc2, "wxDCClipper::wxDCClipper at call with 5 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxDCClipper*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxDCClipper::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFont_free(void *object TSRMLS_DC) 
{
    zo_wxFont* custom_object = (zo_wxFont*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFont_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxFont done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxFont_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFont_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxFont* custom_object;
    custom_object = (zo_wxFont*) emalloc(sizeof(zo_wxFont));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxFont_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXFONT_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxFont::wxFont()
   Default ctor. */
PHP_METHOD(php_wxFont, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* font1 = 0;
	wxFont* object_pointer1_0 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	long pointSize2;
	long family2;
	long style2;
	long weight2;
	bool underline2;
	char* faceName2;
	long faceName_len2;
	long encoding2;
	bool overload2_called = false;
	//Parameters for overload 3
	zval* pixelSize3 = 0;
	wxSize* object_pointer3_0 = 0;
	long family3;
	long style3;
	long weight3;
	bool underline3;
	char* faceName3;
	long faceName_len3;
	long encoding3;
	bool overload3_called = false;
	//Parameters for overload 4
	char* nativeInfoString4;
	long nativeInfoString_len4;
	bool overload4_called = false;
	//Parameters for overload 5
	zval* nativeInfo5 = 0;
	wxNativeFontInfo* object_pointer5_0 = 0;
	bool overload5_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font1, php_wxFont_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font1, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxFont*) argument_native_object;
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(font1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received >= 4  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll|bsl' (&pointSize2, &family2, &style2, &weight2, &underline2, &faceName2, &faceName_len2, &encoding2)\n");
		#endif

		char parse_parameters_string[] = "llll|bsl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pointSize2, &family2, &style2, &weight2, &underline2, &faceName2, &faceName_len2, &encoding2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received >= 4  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Olll|bsl' (&pixelSize3, php_wxSize_entry, &family3, &style3, &weight3, &underline3, &faceName3, &faceName_len3, &encoding3)\n");
		#endif

		char parse_parameters_string[] = "Olll|bsl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pixelSize3, php_wxSize_entry, &family3, &style3, &weight3, &underline3, &faceName3, &faceName_len3, &encoding3 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pixelSize3) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(pixelSize3 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(pixelSize3 TSRMLS_CC))->native_object;
					object_pointer3_0 = (wxSize*) argument_native_object;
					if (!object_pointer3_0 )
					{
						goto overload4;
					}
				}
				else if(Z_TYPE_P(pixelSize3) != IS_NULL)
				{
					goto overload4;
				}
			}

			overload3_called = true;
			already_called = true;
		}
	}

	//Overload 4
	overload4:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&nativeInfoString4, &nativeInfoString_len4)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &nativeInfoString4, &nativeInfoString_len4 ) == SUCCESS)
		{
			overload4_called = true;
			already_called = true;
		}
	}

	//Overload 5
	overload5:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&nativeInfo5, php_wxNativeFontInfo_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &nativeInfo5, php_wxNativeFontInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(nativeInfo5) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxNativeFontInfo*) zend_object_store_get_object(nativeInfo5 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxNativeFontInfo*) zend_object_store_get_object(nativeInfo5 TSRMLS_CC))->native_object;
					object_pointer5_0 = (wxNativeFontInfo*) argument_native_object;
					if (!object_pointer5_0 )
					{
						zend_error(E_ERROR, "Parameter 'nativeInfo' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(nativeInfo5) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'nativeInfo' not null, could not be retreived correctly.");
				}
			}

			overload5_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxFont_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxFont*) object_pointer1_0)\n");
				#endif

				native_object = new wxFont_php(*(wxFont*) object_pointer1_0);

				native_object->references.Initialize();
				((wxFont_php*) native_object)->references.AddReference(font1, "wxFont::wxFont at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) pointSize2, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2)\n");
				#endif

				native_object = new wxFont_php((int) pointSize2, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2);

				native_object->references.Initialize();
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) pointSize2, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2)\n");
				#endif

				native_object = new wxFont_php((int) pointSize2, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2);

				native_object->references.Initialize();
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) pointSize2, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2, wxString(faceName2, wxConvUTF8))\n");
				#endif

				native_object = new wxFont_php((int) pointSize2, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2, wxString(faceName2, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) pointSize2, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2, wxString(faceName2, wxConvUTF8), (wxFontEncoding) encoding2)\n");
				#endif

				native_object = new wxFont_php((int) pointSize2, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2, wxString(faceName2, wxConvUTF8), (wxFontEncoding) encoding2);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (wxFontStyle) style3, (wxFontWeight) weight3)\n");
				#endif

				native_object = new wxFont_php(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (wxFontStyle) style3, (wxFontWeight) weight3);

				native_object->references.Initialize();
				((wxFont_php*) native_object)->references.AddReference(pixelSize3, "wxFont::wxFont at call with 4 argument(s)");
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (wxFontStyle) style3, (wxFontWeight) weight3, underline3)\n");
				#endif

				native_object = new wxFont_php(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (wxFontStyle) style3, (wxFontWeight) weight3, underline3);

				native_object->references.Initialize();
				((wxFont_php*) native_object)->references.AddReference(pixelSize3, "wxFont::wxFont at call with 5 argument(s)");
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (wxFontStyle) style3, (wxFontWeight) weight3, underline3, wxString(faceName3, wxConvUTF8))\n");
				#endif

				native_object = new wxFont_php(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (wxFontStyle) style3, (wxFontWeight) weight3, underline3, wxString(faceName3, wxConvUTF8));

				native_object->references.Initialize();
				((wxFont_php*) native_object)->references.AddReference(pixelSize3, "wxFont::wxFont at call with 6 argument(s)");
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (wxFontStyle) style3, (wxFontWeight) weight3, underline3, wxString(faceName3, wxConvUTF8), (wxFontEncoding) encoding3)\n");
				#endif

				native_object = new wxFont_php(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (wxFontStyle) style3, (wxFontWeight) weight3, underline3, wxString(faceName3, wxConvUTF8), (wxFontEncoding) encoding3);

				native_object->references.Initialize();
				((wxFont_php*) native_object)->references.AddReference(pixelSize3, "wxFont::wxFont at call with 7 argument(s)");
				break;
			}
		}
	}

	if(overload4_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(nativeInfoString4, wxConvUTF8))\n");
				#endif

				native_object = new wxFont_php(wxString(nativeInfoString4, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload5_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxNativeFontInfo*) object_pointer5_0)\n");
				#endif

				native_object = new wxFont_php(*(wxNativeFontInfo*) object_pointer5_0);

				native_object->references.Initialize();
				((wxFont_php*) native_object)->references.AddReference(nativeInfo5, "wxFont::wxFont at call with 1 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxFont::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto wxFont wxFont::Bold()
   Returns a bold version of this font. */
PHP_METHOD(php_wxFont, Bold)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::Bold\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::Bold call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::Bold() to return new object\n\n");
				#endif

				wxFont value_to_return0;
				value_to_return0 = ((wxFont_php*)native_object)->Bold();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxFont));
				object_init_ex(return_value, php_wxFont_entry);
				((wxFont_php*)ptr)->phpObj = return_value;
				zo_wxFont* zo0 = (zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxFont_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::Bold\n");
	}
}
/* }}} */

/* {{{ proto wxFontEncoding wxFont::GetDefaultEncoding()
   Returns the current application's default encoding. */
PHP_METHOD(php_wxFont, GetDefaultEncoding)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::GetDefaultEncoding\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::GetDefaultEncoding call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_LONG(wxFont::GetDefaultEncoding())\n\n");
				#endif

				ZVAL_LONG(return_value, wxFont::GetDefaultEncoding());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::GetDefaultEncoding\n");
	}
}
/* }}} */

/* {{{ proto wxFontEncoding wxFont::GetEncoding()
   Returns the encoding of this font. */
PHP_METHOD(php_wxFont, GetEncoding)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::GetEncoding\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::GetEncoding call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxFont::GetEncoding())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxFont_php*)native_object)->GetEncoding());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::GetEncoding\n");
	}
}
/* }}} */

/* {{{ proto string wxFont::GetFaceName()
   Returns the face name associated with the font, or the empty string if there is no face information. */
PHP_METHOD(php_wxFont, GetFaceName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::GetFaceName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::GetFaceName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFont::GetFaceName().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxFont_php*)native_object)->GetFaceName();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::GetFaceName\n");
	}
}
/* }}} */

/* {{{ proto wxFontFamily wxFont::GetFamily()
   Gets the font family if possible. */
PHP_METHOD(php_wxFont, GetFamily)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::GetFamily\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::GetFamily call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxFont::GetFamily())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxFont_php*)native_object)->GetFamily());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::GetFamily\n");
	}
}
/* }}} */

/* {{{ proto string wxFont::GetNativeFontInfoDesc()
   Returns the platform-dependent string completely describing this font. */
PHP_METHOD(php_wxFont, GetNativeFontInfoDesc)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::GetNativeFontInfoDesc\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::GetNativeFontInfoDesc call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFont::GetNativeFontInfoDesc().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxFont_php*)native_object)->GetNativeFontInfoDesc();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::GetNativeFontInfoDesc\n");
	}
}
/* }}} */

/* {{{ proto string wxFont::GetNativeFontInfoUserDesc()
   Returns a user-friendly string for this font object. */
PHP_METHOD(php_wxFont, GetNativeFontInfoUserDesc)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::GetNativeFontInfoUserDesc\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::GetNativeFontInfoUserDesc call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxFont::GetNativeFontInfoUserDesc().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxFont_php*)native_object)->GetNativeFontInfoUserDesc();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::GetNativeFontInfoUserDesc\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxFont::GetPixelSize()
   Gets the pixel size. */
PHP_METHOD(php_wxFont, GetPixelSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::GetPixelSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::GetPixelSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::GetPixelSize() to return new object\n\n");
				#endif

				wxSize value_to_return0;
				value_to_return0 = ((wxFont_php*)native_object)->GetPixelSize();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				((wxSize_php*)ptr)->phpObj = return_value;
				zo_wxSize* zo0 = (zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxSize_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::GetPixelSize\n");
	}
}
/* }}} */

/* {{{ proto int wxFont::GetPointSize()
   Gets the point size. */
PHP_METHOD(php_wxFont, GetPointSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::GetPointSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::GetPointSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxFont::GetPointSize())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxFont_php*)native_object)->GetPointSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::GetPointSize\n");
	}
}
/* }}} */

/* {{{ proto wxFontStyle wxFont::GetStyle()
   Gets the font style. */
PHP_METHOD(php_wxFont, GetStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::GetStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::GetStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxFont::GetStyle())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxFont_php*)native_object)->GetStyle());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::GetStyle\n");
	}
}
/* }}} */

/* {{{ proto bool wxFont::GetUnderlined()
   Returns true if the font is underlined, false otherwise. */
PHP_METHOD(php_wxFont, GetUnderlined)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::GetUnderlined\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::GetUnderlined call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFont::GetUnderlined())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxFont_php*)native_object)->GetUnderlined());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::GetUnderlined\n");
	}
}
/* }}} */

/* {{{ proto wxFontWeight wxFont::GetWeight()
   Gets the font weight. */
PHP_METHOD(php_wxFont, GetWeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::GetWeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::GetWeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxFont::GetWeight())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxFont_php*)native_object)->GetWeight());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::GetWeight\n");
	}
}
/* }}} */

/* {{{ proto bool wxFont::IsFixedWidth()
   Returns true if the font is a fixed width (or monospaced) font, false if it is a proportional one or font is invalid. */
PHP_METHOD(php_wxFont, IsFixedWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::IsFixedWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::IsFixedWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFont::IsFixedWidth())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxFont_php*)native_object)->IsFixedWidth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::IsFixedWidth\n");
	}
}
/* }}} */

/* {{{ proto bool wxFont::IsOk()
   Returns true if this object is a valid font, false otherwise. */
PHP_METHOD(php_wxFont, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::IsOk call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFont::IsOk())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxFont_php*)native_object)->IsOk());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::IsOk\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxFont::Italic()
   Returns an italic version of this font. */
PHP_METHOD(php_wxFont, Italic)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::Italic\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::Italic call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::Italic() to return new object\n\n");
				#endif

				wxFont value_to_return0;
				value_to_return0 = ((wxFont_php*)native_object)->Italic();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxFont));
				object_init_ex(return_value, php_wxFont_entry);
				((wxFont_php*)ptr)->phpObj = return_value;
				zo_wxFont* zo0 = (zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxFont_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::Italic\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxFont::Larger()
   Returns a larger version of this font. */
PHP_METHOD(php_wxFont, Larger)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::Larger\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::Larger call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::Larger() to return new object\n\n");
				#endif

				wxFont value_to_return0;
				value_to_return0 = ((wxFont_php*)native_object)->Larger();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxFont));
				object_init_ex(return_value, php_wxFont_entry);
				((wxFont_php*)ptr)->phpObj = return_value;
				zo_wxFont* zo0 = (zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxFont_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::Larger\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxFont::MakeBold()
   Changes this font to be bold. */
PHP_METHOD(php_wxFont, MakeBold)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::MakeBold\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::MakeBold call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::MakeBold() to return object reference\n\n");
				#endif

				wxFont_php* value_to_return0;
				value_to_return0 = (wxFont_php*) &((wxFont_php*)native_object)->MakeBold();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxFont::MakeBold at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::MakeBold\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxFont::MakeItalic()
   Changes this font to be italic. */
PHP_METHOD(php_wxFont, MakeItalic)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::MakeItalic\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::MakeItalic call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::MakeItalic() to return object reference\n\n");
				#endif

				wxFont_php* value_to_return0;
				value_to_return0 = (wxFont_php*) &((wxFont_php*)native_object)->MakeItalic();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxFont::MakeItalic at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::MakeItalic\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxFont::MakeLarger()
   Changes this font to be larger. */
PHP_METHOD(php_wxFont, MakeLarger)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::MakeLarger\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::MakeLarger call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::MakeLarger() to return object reference\n\n");
				#endif

				wxFont_php* value_to_return0;
				value_to_return0 = (wxFont_php*) &((wxFont_php*)native_object)->MakeLarger();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxFont::MakeLarger at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::MakeLarger\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxFont::MakeSmaller()
   Changes this font to be smaller. */
PHP_METHOD(php_wxFont, MakeSmaller)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::MakeSmaller\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::MakeSmaller call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::MakeSmaller() to return object reference\n\n");
				#endif

				wxFont_php* value_to_return0;
				value_to_return0 = (wxFont_php*) &((wxFont_php*)native_object)->MakeSmaller();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxFont::MakeSmaller at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::MakeSmaller\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxFont::MakeUnderlined()
   Changes this font to be underlined. */
PHP_METHOD(php_wxFont, MakeUnderlined)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::MakeUnderlined\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::MakeUnderlined call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::MakeUnderlined() to return object reference\n\n");
				#endif

				wxFont_php* value_to_return0;
				value_to_return0 = (wxFont_php*) &((wxFont_php*)native_object)->MakeUnderlined();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxFont::MakeUnderlined at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::MakeUnderlined\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxFont::New(int pointSize, wxFontFamily family, wxFontStyle style, wxFontWeight weight, bool underline, string faceName, wxFontEncoding encoding)
   This function takes the same parameters as the relative wxFont constructor and returns a new font object allocated on the heap. */
PHP_METHOD(php_wxFont, NewMethod)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::New\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::New call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pointSize0;
	long family0;
	long style0;
	long weight0;
	bool underline0;
	char* faceName0;
	long faceName_len0;
	long encoding0;
	bool overload0_called = false;
	//Parameters for overload 1
	long pointSize1;
	long family1;
	long flags1;
	char* faceName1;
	long faceName_len1;
	long encoding1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* pixelSize2 = 0;
	wxSize* object_pointer2_0 = 0;
	long family2;
	long style2;
	long weight2;
	bool underline2;
	char* faceName2;
	long faceName_len2;
	long encoding2;
	bool overload2_called = false;
	//Parameters for overload 3
	zval* pixelSize3 = 0;
	wxSize* object_pointer3_0 = 0;
	long family3;
	long flags3;
	char* faceName3;
	long faceName_len3;
	long encoding3;
	bool overload3_called = false;
	//Parameters for overload 4
	char* nativeInfoString4;
	long nativeInfoString_len4;
	bool overload4_called = false;
	//Parameters for overload 5
	zval* nativeInfo5 = 0;
	wxNativeFontInfo* object_pointer5_0 = 0;
	bool overload5_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 4  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll|bsl' (&pointSize0, &family0, &style0, &weight0, &underline0, &faceName0, &faceName_len0, &encoding0)\n");
		#endif

		char parse_parameters_string[] = "llll|bsl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pointSize0, &family0, &style0, &weight0, &underline0, &faceName0, &faceName_len0, &encoding0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll|lsl' (&pointSize1, &family1, &flags1, &faceName1, &faceName_len1, &encoding1)\n");
		#endif

		char parse_parameters_string[] = "ll|lsl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pointSize1, &family1, &flags1, &faceName1, &faceName_len1, &encoding1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received >= 4  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Olll|bsl' (&pixelSize2, php_wxSize_entry, &family2, &style2, &weight2, &underline2, &faceName2, &faceName_len2, &encoding2)\n");
		#endif

		char parse_parameters_string[] = "Olll|bsl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pixelSize2, php_wxSize_entry, &family2, &style2, &weight2, &underline2, &faceName2, &faceName_len2, &encoding2 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pixelSize2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(pixelSize2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(pixelSize2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxSize*) argument_native_object;
					if (!object_pointer2_0 )
					{
						goto overload3;
					}
				}
				else if(Z_TYPE_P(pixelSize2) != IS_NULL)
				{
					goto overload3;
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|lsl' (&pixelSize3, php_wxSize_entry, &family3, &flags3, &faceName3, &faceName_len3, &encoding3)\n");
		#endif

		char parse_parameters_string[] = "Ol|lsl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pixelSize3, php_wxSize_entry, &family3, &flags3, &faceName3, &faceName_len3, &encoding3 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pixelSize3) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(pixelSize3 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(pixelSize3 TSRMLS_CC))->native_object;
					object_pointer3_0 = (wxSize*) argument_native_object;
					if (!object_pointer3_0 )
					{
						goto overload4;
					}
				}
				else if(Z_TYPE_P(pixelSize3) != IS_NULL)
				{
					goto overload4;
				}
			}

			overload3_called = true;
			already_called = true;
		}
	}

	//Overload 4
	overload4:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&nativeInfoString4, &nativeInfoString_len4)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &nativeInfoString4, &nativeInfoString_len4 ) == SUCCESS)
		{
			overload4_called = true;
			already_called = true;
		}
	}

	//Overload 5
	overload5:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&nativeInfo5, php_wxNativeFontInfo_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &nativeInfo5, php_wxNativeFontInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(nativeInfo5) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxNativeFontInfo*) zend_object_store_get_object(nativeInfo5 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxNativeFontInfo*) zend_object_store_get_object(nativeInfo5 TSRMLS_CC))->native_object;
					object_pointer5_0 = (wxNativeFontInfo*) argument_native_object;
					if (!object_pointer5_0 )
					{
						zend_error(E_ERROR, "Parameter 'nativeInfo' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(nativeInfo5) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'nativeInfo' not null, could not be retreived correctly.");
				}
			}

			overload5_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New((int) pointSize0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return4;
				value_to_return4 = (wxFont_php*) wxFont::New((int) pointSize0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0);
				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return4;
				}



				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New((int) pointSize0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return5;
				value_to_return5 = (wxFont_php*) wxFont::New((int) pointSize0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0);
				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return5;
				}



				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New((int) pointSize0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0, wxString(faceName0, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return6;
				value_to_return6 = (wxFont_php*) wxFont::New((int) pointSize0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0, wxString(faceName0, wxConvUTF8));
				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return6;
				}



				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New((int) pointSize0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0, wxString(faceName0, wxConvUTF8), (wxFontEncoding) encoding0) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return7;
				value_to_return7 = (wxFont_php*) wxFont::New((int) pointSize0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0, wxString(faceName0, wxConvUTF8), (wxFontEncoding) encoding0);
				if(value_to_return7 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return7->references.IsUserInitialized()){
					if(value_to_return7->phpObj != NULL){
						*return_value = *value_to_return7->phpObj;
						zval_add_ref(&value_to_return7->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return7;
				}



				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New((int) pointSize1, (wxFontFamily) family1) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return2;
				value_to_return2 = (wxFont_php*) wxFont::New((int) pointSize1, (wxFontFamily) family1);
				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return2;
				}



				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New((int) pointSize1, (wxFontFamily) family1, (int) flags1) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return3;
				value_to_return3 = (wxFont_php*) wxFont::New((int) pointSize1, (wxFontFamily) family1, (int) flags1);
				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return3;
				}



				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New((int) pointSize1, (wxFontFamily) family1, (int) flags1, wxString(faceName1, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return4;
				value_to_return4 = (wxFont_php*) wxFont::New((int) pointSize1, (wxFontFamily) family1, (int) flags1, wxString(faceName1, wxConvUTF8));
				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return4;
				}



				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New((int) pointSize1, (wxFontFamily) family1, (int) flags1, wxString(faceName1, wxConvUTF8), (wxFontEncoding) encoding1) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return5;
				value_to_return5 = (wxFont_php*) wxFont::New((int) pointSize1, (wxFontFamily) family1, (int) flags1, wxString(faceName1, wxConvUTF8), (wxFontEncoding) encoding1);
				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return5;
				}



				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New(*(wxSize*) object_pointer2_0, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return4;
				value_to_return4 = (wxFont_php*) wxFont::New(*(wxSize*) object_pointer2_0, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2);
				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return4;
				}



				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New(*(wxSize*) object_pointer2_0, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return5;
				value_to_return5 = (wxFont_php*) wxFont::New(*(wxSize*) object_pointer2_0, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2);
				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return5;
				}



				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New(*(wxSize*) object_pointer2_0, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2, wxString(faceName2, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return6;
				value_to_return6 = (wxFont_php*) wxFont::New(*(wxSize*) object_pointer2_0, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2, wxString(faceName2, wxConvUTF8));
				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return6;
				}



				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New(*(wxSize*) object_pointer2_0, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2, wxString(faceName2, wxConvUTF8), (wxFontEncoding) encoding2) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return7;
				value_to_return7 = (wxFont_php*) wxFont::New(*(wxSize*) object_pointer2_0, (wxFontFamily) family2, (wxFontStyle) style2, (wxFontWeight) weight2, underline2, wxString(faceName2, wxConvUTF8), (wxFontEncoding) encoding2);
				if(value_to_return7 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return7->references.IsUserInitialized()){
					if(value_to_return7->phpObj != NULL){
						*return_value = *value_to_return7->phpObj;
						zval_add_ref(&value_to_return7->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return7;
				}



				return;
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New(*(wxSize*) object_pointer3_0, (wxFontFamily) family3) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return2;
				value_to_return2 = (wxFont_php*) wxFont::New(*(wxSize*) object_pointer3_0, (wxFontFamily) family3);
				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return2;
				}



				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (int) flags3) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return3;
				value_to_return3 = (wxFont_php*) wxFont::New(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (int) flags3);
				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return3;
				}



				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (int) flags3, wxString(faceName3, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return4;
				value_to_return4 = (wxFont_php*) wxFont::New(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (int) flags3, wxString(faceName3, wxConvUTF8));
				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return4;
				}



				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (int) flags3, wxString(faceName3, wxConvUTF8), (wxFontEncoding) encoding3) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return5;
				value_to_return5 = (wxFont_php*) wxFont::New(*(wxSize*) object_pointer3_0, (wxFontFamily) family3, (int) flags3, wxString(faceName3, wxConvUTF8), (wxFontEncoding) encoding3);
				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return5;
				}



				return;
				break;
			}
		}
	}

	if(overload4_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New(wxString(nativeInfoString4, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return1;
				value_to_return1 = (wxFont_php*) wxFont::New(wxString(nativeInfoString4, wxConvUTF8));
				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return1;
				}



				return;
				break;
			}
		}
	}

	if(overload5_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::New(*(wxNativeFontInfo*) object_pointer5_0) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return1;
				value_to_return1 = (wxFont_php*) wxFont::New(*(wxNativeFontInfo*) object_pointer5_0);
				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return1;
				}



				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::New\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxFont::Scale(float x)
   Changes the size of this font. */
PHP_METHOD(php_wxFont, Scale)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::Scale\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::Scale call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	double x0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'd' (&x0)\n");
		#endif

		char parse_parameters_string[] = "d";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::Scale(x0) to return object reference\n\n");
				#endif

				wxFont_php* value_to_return1;
				value_to_return1 = (wxFont_php*) &((wxFont_php*)native_object)->Scale(x0);

				if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return1;
				}

				if((void*)value_to_return1 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxFont::Scale at call with 1 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::Scale\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxFont::Scaled(float x)
   Returns a scaled version of this font. */
PHP_METHOD(php_wxFont, Scaled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::Scaled\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::Scaled call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	double x0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'd' (&x0)\n");
		#endif

		char parse_parameters_string[] = "d";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::Scaled(x0) to return new object\n\n");
				#endif

				wxFont value_to_return1;
				value_to_return1 = ((wxFont_php*)native_object)->Scaled(x0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxFont));
				object_init_ex(return_value, php_wxFont_entry);
				((wxFont_php*)ptr)->phpObj = return_value;
				zo_wxFont* zo1 = (zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxFont_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::Scaled\n");
	}
}
/* }}} */

/* {{{ proto  wxFont::SetDefaultEncoding(wxFontEncoding encoding)
   Sets the default font encoding. */
PHP_METHOD(php_wxFont, SetDefaultEncoding)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::SetDefaultEncoding\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::SetDefaultEncoding call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long encoding0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&encoding0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &encoding0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFont::SetDefaultEncoding((wxFontEncoding) encoding0)\n\n");
				#endif

				wxFont::SetDefaultEncoding((wxFontEncoding) encoding0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::SetDefaultEncoding\n");
	}
}
/* }}} */

/* {{{ proto  wxFont::SetEncoding(wxFontEncoding encoding)
   Sets the encoding for this font. */
PHP_METHOD(php_wxFont, SetEncoding)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::SetEncoding\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::SetEncoding call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long encoding0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&encoding0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &encoding0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::SetEncoding((wxFontEncoding) encoding0)\n\n");
				#endif

				((wxFont_php*)native_object)->SetEncoding((wxFontEncoding) encoding0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::SetEncoding\n");
	}
}
/* }}} */

/* {{{ proto bool wxFont::SetFaceName(string faceName)
   Sets the facename for the font. */
PHP_METHOD(php_wxFont, SetFaceName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::SetFaceName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::SetFaceName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* faceName0;
	long faceName_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&faceName0, &faceName_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &faceName0, &faceName_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFont::SetFaceName(wxString(faceName0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxFont_php*)native_object)->SetFaceName(wxString(faceName0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::SetFaceName\n");
	}
}
/* }}} */

/* {{{ proto  wxFont::SetFamily(wxFontFamily family)
   Sets the font family. */
PHP_METHOD(php_wxFont, SetFamily)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::SetFamily\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::SetFamily call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long family0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&family0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &family0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::SetFamily((wxFontFamily) family0)\n\n");
				#endif

				((wxFont_php*)native_object)->SetFamily((wxFontFamily) family0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::SetFamily\n");
	}
}
/* }}} */

/* {{{ proto bool wxFont::SetNativeFontInfo(string info)
   Creates the font corresponding to the given native font description string which must have been previously returned by GetNativeFontInfoDesc(). */
PHP_METHOD(php_wxFont, SetNativeFontInfo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::SetNativeFontInfo\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::SetNativeFontInfo call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* info0;
	long info_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* info1 = 0;
	wxNativeFontInfo* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&info0, &info_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &info0, &info_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&info1, php_wxNativeFontInfo_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &info1, php_wxNativeFontInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(info1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxNativeFontInfo*) zend_object_store_get_object(info1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxNativeFontInfo*) zend_object_store_get_object(info1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxNativeFontInfo*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'info' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(info1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'info' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFont::SetNativeFontInfo(wxString(info0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxFont_php*)native_object)->SetNativeFontInfo(wxString(info0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::SetNativeFontInfo(*(wxNativeFontInfo*) object_pointer1_0)\n\n");
				#endif

				((wxFont_php*)native_object)->SetNativeFontInfo(*(wxNativeFontInfo*) object_pointer1_0);

				references->AddReference(info1, "wxFont::SetNativeFontInfo at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::SetNativeFontInfo\n");
	}
}
/* }}} */

/* {{{ proto bool wxFont::SetNativeFontInfoUserDesc(string info)
   Creates the font corresponding to the given native font description string and returns true if the creation was successful. */
PHP_METHOD(php_wxFont, SetNativeFontInfoUserDesc)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::SetNativeFontInfoUserDesc\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::SetNativeFontInfoUserDesc call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* info0;
	long info_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&info0, &info_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &info0, &info_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFont::SetNativeFontInfoUserDesc(wxString(info0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxFont_php*)native_object)->SetNativeFontInfoUserDesc(wxString(info0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::SetNativeFontInfoUserDesc\n");
	}
}
/* }}} */

/* {{{ proto  wxFont::SetPixelSize(wxSize pixelSize)
   Sets the pixel size. */
PHP_METHOD(php_wxFont, SetPixelSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::SetPixelSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::SetPixelSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* pixelSize0 = 0;
	wxSize* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&pixelSize0, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pixelSize0, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(pixelSize0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(pixelSize0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(pixelSize0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxSize*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'pixelSize' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pixelSize0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pixelSize' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::SetPixelSize(*(wxSize*) object_pointer0_0)\n\n");
				#endif

				((wxFont_php*)native_object)->SetPixelSize(*(wxSize*) object_pointer0_0);

				references->AddReference(pixelSize0, "wxFont::SetPixelSize at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::SetPixelSize\n");
	}
}
/* }}} */

/* {{{ proto  wxFont::SetPointSize(int pointSize)
   Sets the point size. */
PHP_METHOD(php_wxFont, SetPointSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::SetPointSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::SetPointSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pointSize0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pointSize0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pointSize0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::SetPointSize((int) pointSize0)\n\n");
				#endif

				((wxFont_php*)native_object)->SetPointSize((int) pointSize0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::SetPointSize\n");
	}
}
/* }}} */

/* {{{ proto  wxFont::SetStyle(wxFontStyle style)
   Sets the font style. */
PHP_METHOD(php_wxFont, SetStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::SetStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::SetStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&style0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::SetStyle((wxFontStyle) style0)\n\n");
				#endif

				((wxFont_php*)native_object)->SetStyle((wxFontStyle) style0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::SetStyle\n");
	}
}
/* }}} */

/* {{{ proto  wxFont::SetSymbolicSize(wxFontSymbolicSize size)
   Sets the font size using a predefined symbolic size name. */
PHP_METHOD(php_wxFont, SetSymbolicSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::SetSymbolicSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::SetSymbolicSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long size0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&size0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::SetSymbolicSize((wxFontSymbolicSize) size0)\n\n");
				#endif

				((wxFont_php*)native_object)->SetSymbolicSize((wxFontSymbolicSize) size0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::SetSymbolicSize\n");
	}
}
/* }}} */

/* {{{ proto  wxFont::SetSymbolicSizeRelativeTo(wxFontSymbolicSize size, int base)
   Sets the font size compared to the base font size. */
PHP_METHOD(php_wxFont, SetSymbolicSizeRelativeTo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::SetSymbolicSizeRelativeTo\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::SetSymbolicSizeRelativeTo call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long size0;
	long base0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&size0, &base0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size0, &base0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::SetSymbolicSizeRelativeTo((wxFontSymbolicSize) size0, (int) base0)\n\n");
				#endif

				((wxFont_php*)native_object)->SetSymbolicSizeRelativeTo((wxFontSymbolicSize) size0, (int) base0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::SetSymbolicSizeRelativeTo\n");
	}
}
/* }}} */

/* {{{ proto  wxFont::SetUnderlined(bool underlined)
   Sets underlining. */
PHP_METHOD(php_wxFont, SetUnderlined)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::SetUnderlined\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::SetUnderlined call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool underlined0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&underlined0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &underlined0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::SetUnderlined(underlined0)\n\n");
				#endif

				((wxFont_php*)native_object)->SetUnderlined(underlined0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::SetUnderlined\n");
	}
}
/* }}} */

/* {{{ proto  wxFont::SetWeight(wxFontWeight weight)
   Sets the font weight. */
PHP_METHOD(php_wxFont, SetWeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::SetWeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::SetWeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long weight0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&weight0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &weight0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::SetWeight((wxFontWeight) weight0)\n\n");
				#endif

				((wxFont_php*)native_object)->SetWeight((wxFontWeight) weight0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::SetWeight\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxFont::Smaller()
   Returns a smaller version of this font. */
PHP_METHOD(php_wxFont, Smaller)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::Smaller\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::Smaller call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::Smaller() to return new object\n\n");
				#endif

				wxFont value_to_return0;
				value_to_return0 = ((wxFont_php*)native_object)->Smaller();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxFont));
				object_init_ex(return_value, php_wxFont_entry);
				((wxFont_php*)ptr)->phpObj = return_value;
				zo_wxFont* zo0 = (zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxFont_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::Smaller\n");
	}
}
/* }}} */

/* {{{ proto wxFont wxFont::Underlined()
   Returns underlined version of this font. */
PHP_METHOD(php_wxFont, Underlined)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::Underlined\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::Underlined call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::Underlined() to return new object\n\n");
				#endif

				wxFont value_to_return0;
				value_to_return0 = ((wxFont_php*)native_object)->Underlined();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxFont_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxFont));
				object_init_ex(return_value, php_wxFont_entry);
				((wxFont_php*)ptr)->phpObj = return_value;
				zo_wxFont* zo0 = (zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxFont_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::Underlined\n");
	}
}
/* }}} */

/* {{{ proto wxNativeFontInfo wxFont::GetNativeFontInfo()
   Returns the encoding of this font. */
PHP_METHOD(php_wxFont, GetNativeFontInfo)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFont::GetNativeFontInfo\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFont* current_object;
	wxphp_object_type current_object_type;
	wxFont_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFont*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFont::GetNativeFontInfo call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONT_TYPE){
				references = &((wxFont_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFont::GetNativeFontInfo() to return object pointer\n\n");
				#endif

				wxNativeFontInfo_php* value_to_return0;
				value_to_return0 = (wxNativeFontInfo_php*) ((wxFont_php*)native_object)->GetNativeFontInfo();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxNativeFontInfo_entry);
					((zo_wxNativeFontInfo*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxNativeFontInfo_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxFont::GetNativeFontInfo at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFont::GetNativeFontInfo\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFontList_free(void *object TSRMLS_DC) 
{
    zo_wxFontList* custom_object = (zo_wxFontList*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFontList_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxFontList done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxFontList_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFontList_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxFontList* custom_object;
    custom_object = (zo_wxFontList*) emalloc(sizeof(zo_wxFontList));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxFontList_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXFONTLIST_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxFontList::wxFontList()
   Constructor. */
PHP_METHOD(php_wxFontList, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFontList::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFontList* current_object;
	wxFontList_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxFontList_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxFontList*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxFontList::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto wxFont wxFontList::FindOrCreateFont(int point_size, wxFontFamily family, wxFontStyle style, wxFontWeight weight, bool underline, string facename, wxFontEncoding encoding)
   Finds a font of the given specification, or creates one and adds it to the list. */
PHP_METHOD(php_wxFontList, FindOrCreateFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFontList::FindOrCreateFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFontList* current_object;
	wxphp_object_type current_object_type;
	wxFontList_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFontList*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFontList::FindOrCreateFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONTLIST_TYPE){
				references = &((wxFontList_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long point_size0;
	long family0;
	long style0;
	long weight0;
	bool underline0;
	char* facename0;
	long facename_len0;
	long encoding0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 4  && arguments_received <= 7)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll|bsl' (&point_size0, &family0, &style0, &weight0, &underline0, &facename0, &facename_len0, &encoding0)\n");
		#endif

		char parse_parameters_string[] = "llll|bsl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &point_size0, &family0, &style0, &weight0, &underline0, &facename0, &facename_len0, &encoding0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFontList::FindOrCreateFont((int) point_size0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return4;
				value_to_return4 = (wxFont_php*) ((wxFontList_php*)native_object)->FindOrCreateFont((int) point_size0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0);

				if(value_to_return4 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return4;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return4 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxFontList::FindOrCreateFont at call with 4 argument(s)");
				}


				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFontList::FindOrCreateFont((int) point_size0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return5;
				value_to_return5 = (wxFont_php*) ((wxFontList_php*)native_object)->FindOrCreateFont((int) point_size0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0);

				if(value_to_return5 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return5;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return5 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxFontList::FindOrCreateFont at call with 5 argument(s)");
				}


				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFontList::FindOrCreateFont((int) point_size0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0, wxString(facename0, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return6;
				value_to_return6 = (wxFont_php*) ((wxFontList_php*)native_object)->FindOrCreateFont((int) point_size0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0, wxString(facename0, wxConvUTF8));

				if(value_to_return6 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return6->references.IsUserInitialized()){
					if(value_to_return6->phpObj != NULL){
						*return_value = *value_to_return6->phpObj;
						zval_add_ref(&value_to_return6->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return6;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return6 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxFontList::FindOrCreateFont at call with 6 argument(s)");
				}


				return;
				break;
			}
			case 7:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxFontList::FindOrCreateFont((int) point_size0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0, wxString(facename0, wxConvUTF8), (wxFontEncoding) encoding0) to return object pointer\n\n");
				#endif

				wxFont_php* value_to_return7;
				value_to_return7 = (wxFont_php*) ((wxFontList_php*)native_object)->FindOrCreateFont((int) point_size0, (wxFontFamily) family0, (wxFontStyle) style0, (wxFontWeight) weight0, underline0, wxString(facename0, wxConvUTF8), (wxFontEncoding) encoding0);

				if(value_to_return7 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return7->references.IsUserInitialized()){
					if(value_to_return7->phpObj != NULL){
						*return_value = *value_to_return7->phpObj;
						zval_add_ref(&value_to_return7->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxFont_entry);
					((zo_wxFont*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxFont_php*) value_to_return7;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return7 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxFontList::FindOrCreateFont at call with 7 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFontList::FindOrCreateFont\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxFontEnumerator_free(void *object TSRMLS_DC) 
{
    zo_wxFontEnumerator* custom_object = (zo_wxFontEnumerator*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFontEnumerator_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxFontEnumerator done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxFontEnumerator_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxFontEnumerator_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxFontEnumerator* custom_object;
    custom_object = (zo_wxFontEnumerator*) emalloc(sizeof(zo_wxFontEnumerator));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxFontEnumerator_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXFONTENUMERATOR_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto bool wxFontEnumerator::OnFontEncoding(string font, string encoding)
   Called by EnumerateEncodings() for each match. */
bool wxFontEnumerator_php::OnFontEncoding(const wxString& font, const wxString& encoding)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxFontEnumerator::OnFontEncoding\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[2];
	zval *arguments[2];
	
	//Initilize arguments array
	for(int i=0; i<2; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnFontEncoding", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	temp_string = (char*)malloc(sizeof(wxChar)*(font.size()+1));
	strcpy(temp_string, (const char *) font.char_str());
	ZVAL_STRING(arguments[0], temp_string, 1);
	free(temp_string);
	temp_string = (char*)malloc(sizeof(wxChar)*(encoding.size()+1));
	strcpy(temp_string, (const char *) encoding.char_str());
	ZVAL_STRING(arguments[1], temp_string, 1);
	free(temp_string);
		
	for(int i=0; i<2; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnFontEncoding", 14, &return_value, 2, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<2; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxFontEnumerator::OnFontEncoding(font, encoding);
}
/* }}} */

/* {{{ proto bool wxFontEnumerator::OnFacename(string font)
   Called by EnumerateFacenames() for each match. */
bool wxFontEnumerator_php::OnFacename(const wxString& font)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxFontEnumerator::OnFacename\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "OnFacename", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	temp_string = (char*)malloc(sizeof(wxChar)*(font.size()+1));
	strcpy(temp_string, (const char *) font.char_str());
	ZVAL_STRING(arguments[0], temp_string, 1);
	free(temp_string);
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "OnFacename", 10, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Returning userspace value.\n");
		#endif
		
		return Z_BVAL_P(return_value);
	}
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling original method\n");
	php_printf("===========================================\n\n");
	#endif
	
	//Call original method
	return wxFontEnumerator::OnFacename(font);
}
/* }}} */

/* {{{ proto bool wxFontEnumerator::IsValidFacename(string facename)
   Returns true if the given string is valid face name, i.e. */
PHP_METHOD(php_wxFontEnumerator, IsValidFacename)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFontEnumerator::IsValidFacename\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFontEnumerator* current_object;
	wxphp_object_type current_object_type;
	wxFontEnumerator_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFontEnumerator*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFontEnumerator::IsValidFacename call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONTENUMERATOR_TYPE){
				references = &((wxFontEnumerator_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* facename0;
	long facename_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&facename0, &facename_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &facename0, &facename_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_BOOL(wxFontEnumerator::IsValidFacename(wxString(facename0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, wxFontEnumerator::IsValidFacename(wxString(facename0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFontEnumerator::IsValidFacename\n");
	}
}
/* }}} */

/* {{{ proto array wxFontEnumerator::GetFacenames(wxFontEncoding encoding, bool fixedWidthOnly)
   Return array of strings containing all facenames found by EnumerateFacenames(). */
PHP_METHOD(php_wxFontEnumerator, GetFacenames)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFontEnumerator::GetFacenames\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFontEnumerator* current_object;
	wxphp_object_type current_object_type;
	wxFontEnumerator_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFontEnumerator*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFontEnumerator::GetFacenames call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONTENUMERATOR_TYPE){
				references = &((wxFontEnumerator_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long encoding0;
	bool fixedWidthOnly0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|lb' (&encoding0, &fixedWidthOnly0)\n");
		#endif

		char parse_parameters_string[] = "|lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &encoding0, &fixedWidthOnly0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFontEnumerator::GetFacenames() to return strings array\n\n");
				#endif

				wxArrayString value_to_return0;
				value_to_return0 = wxFontEnumerator::GetFacenames();
				char* temp_string0;
				array_init(return_value);
				for(size_t i=0; i<value_to_return0.GetCount(); i++)
				{
					temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0[i].size()+1));
					strcpy (temp_string0, (const char *) value_to_return0[i].char_str() );
					add_next_index_string(return_value, (char*) temp_string0, 1);
					free(temp_string0);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFontEnumerator::GetFacenames((wxFontEncoding) encoding0) to return strings array\n\n");
				#endif

				wxArrayString value_to_return1;
				value_to_return1 = wxFontEnumerator::GetFacenames((wxFontEncoding) encoding0);
				char* temp_string1;
				array_init(return_value);
				for(size_t i=0; i<value_to_return1.GetCount(); i++)
				{
					temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1[i].size()+1));
					strcpy (temp_string1, (const char *) value_to_return1[i].char_str() );
					add_next_index_string(return_value, (char*) temp_string1, 1);
					free(temp_string1);
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFontEnumerator::GetFacenames((wxFontEncoding) encoding0, fixedWidthOnly0) to return strings array\n\n");
				#endif

				wxArrayString value_to_return2;
				value_to_return2 = wxFontEnumerator::GetFacenames((wxFontEncoding) encoding0, fixedWidthOnly0);
				char* temp_string2;
				array_init(return_value);
				for(size_t i=0; i<value_to_return2.GetCount(); i++)
				{
					temp_string2 = (char*)malloc(sizeof(wxChar)*(value_to_return2[i].size()+1));
					strcpy (temp_string2, (const char *) value_to_return2[i].char_str() );
					add_next_index_string(return_value, (char*) temp_string2, 1);
					free(temp_string2);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFontEnumerator::GetFacenames\n");
	}
}
/* }}} */

/* {{{ proto array wxFontEnumerator::GetEncodings(string facename)
   Return array of strings containing all encodings found by EnumerateEncodings(). */
PHP_METHOD(php_wxFontEnumerator, GetEncodings)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFontEnumerator::GetEncodings\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFontEnumerator* current_object;
	wxphp_object_type current_object_type;
	wxFontEnumerator_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFontEnumerator*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFontEnumerator::GetEncodings call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONTENUMERATOR_TYPE){
				references = &((wxFontEnumerator_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* facename0;
	long facename_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|s' (&facename0, &facename_len0)\n");
		#endif

		char parse_parameters_string[] = "|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &facename0, &facename_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFontEnumerator::GetEncodings() to return strings array\n\n");
				#endif

				wxArrayString value_to_return0;
				value_to_return0 = wxFontEnumerator::GetEncodings();
				char* temp_string0;
				array_init(return_value);
				for(size_t i=0; i<value_to_return0.GetCount(); i++)
				{
					temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0[i].size()+1));
					strcpy (temp_string0, (const char *) value_to_return0[i].char_str() );
					add_next_index_string(return_value, (char*) temp_string0, 1);
					free(temp_string0);
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxFontEnumerator::GetEncodings(wxString(facename0, wxConvUTF8)) to return strings array\n\n");
				#endif

				wxArrayString value_to_return1;
				value_to_return1 = wxFontEnumerator::GetEncodings(wxString(facename0, wxConvUTF8));
				char* temp_string1;
				array_init(return_value);
				for(size_t i=0; i<value_to_return1.GetCount(); i++)
				{
					temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1[i].size()+1));
					strcpy (temp_string1, (const char *) value_to_return1[i].char_str() );
					add_next_index_string(return_value, (char*) temp_string1, 1);
					free(temp_string1);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFontEnumerator::GetEncodings\n");
	}
}
/* }}} */

/* {{{ proto bool wxFontEnumerator::EnumerateFacenames(wxFontEncoding encoding, bool fixedWidthOnly)
   Call OnFacename() for each font which supports given encoding (only if it is not wxFONTENCODING_SYSTEM) and is of fixed width (if fixedWidthOnly is true). */
PHP_METHOD(php_wxFontEnumerator, EnumerateFacenames)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFontEnumerator::EnumerateFacenames\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFontEnumerator* current_object;
	wxphp_object_type current_object_type;
	wxFontEnumerator_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFontEnumerator*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFontEnumerator::EnumerateFacenames call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONTENUMERATOR_TYPE){
				references = &((wxFontEnumerator_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long encoding0;
	bool fixedWidthOnly0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|lb' (&encoding0, &fixedWidthOnly0)\n");
		#endif

		char parse_parameters_string[] = "|lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &encoding0, &fixedWidthOnly0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFontEnumerator::EnumerateFacenames())\n\n");
				#endif

				if(current_object_type == PHP_WXFONTENUMERATOR_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxFontEnumerator_php*)native_object)->EnumerateFacenames());
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFontEnumerator::EnumerateFacenames((wxFontEncoding) encoding0))\n\n");
				#endif

				if(current_object_type == PHP_WXFONTENUMERATOR_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxFontEnumerator_php*)native_object)->EnumerateFacenames((wxFontEncoding) encoding0));
				}


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFontEnumerator::EnumerateFacenames((wxFontEncoding) encoding0, fixedWidthOnly0))\n\n");
				#endif

				if(current_object_type == PHP_WXFONTENUMERATOR_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxFontEnumerator_php*)native_object)->EnumerateFacenames((wxFontEncoding) encoding0, fixedWidthOnly0));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFontEnumerator::EnumerateFacenames\n");
	}
}
/* }}} */

/* {{{ proto bool wxFontEnumerator::EnumerateEncodings(string font)
   Call OnFontEncoding() for each encoding supported by the given font - or for each encoding supported by at least some font if font is not specified. */
PHP_METHOD(php_wxFontEnumerator, EnumerateEncodings)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxFontEnumerator::EnumerateEncodings\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxFontEnumerator* current_object;
	wxphp_object_type current_object_type;
	wxFontEnumerator_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxFontEnumerator*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxFontEnumerator::EnumerateEncodings call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXFONTENUMERATOR_TYPE){
				references = &((wxFontEnumerator_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* font0;
	long font_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|s' (&font0, &font_len0)\n");
		#endif

		char parse_parameters_string[] = "|s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, &font_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFontEnumerator::EnumerateEncodings())\n\n");
				#endif

				if(current_object_type == PHP_WXFONTENUMERATOR_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxFontEnumerator_php*)native_object)->EnumerateEncodings());
				}


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxFontEnumerator::EnumerateEncodings(wxString(font0, wxConvUTF8)))\n\n");
				#endif

				if(current_object_type == PHP_WXFONTENUMERATOR_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxFontEnumerator_php*)native_object)->EnumerateEncodings(wxString(font0, wxConvUTF8)));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxFontEnumerator::EnumerateEncodings\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxNativeFontInfo_free(void *object TSRMLS_DC) 
{
    zo_wxNativeFontInfo* custom_object = (zo_wxNativeFontInfo*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxNativeFontInfo_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxNativeFontInfo done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxNativeFontInfo_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxNativeFontInfo_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxNativeFontInfo* custom_object;
    custom_object = (zo_wxNativeFontInfo*) emalloc(sizeof(zo_wxNativeFontInfo));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxNativeFontInfo_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXNATIVEFONTINFO_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxNativeFontInfo::wxNativeFontInfo() */
PHP_METHOD(php_wxNativeFontInfo, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* info1 = 0;
	wxNativeFontInfo* object_pointer1_0 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&info1, php_wxNativeFontInfo_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &info1, php_wxNativeFontInfo_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(info1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxNativeFontInfo*) zend_object_store_get_object(info1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxNativeFontInfo*) zend_object_store_get_object(info1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxNativeFontInfo*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'info' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(info1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'info' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxNativeFontInfo_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxNativeFontInfo*) object_pointer1_0)\n");
				#endif

				native_object = new wxNativeFontInfo_php(*(wxNativeFontInfo*) object_pointer1_0);

				native_object->references.Initialize();
				((wxNativeFontInfo_php*) native_object)->references.AddReference(info1, "wxNativeFontInfo::wxNativeFontInfo at call with 1 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxNativeFontInfo::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto bool wxNativeFontInfo::FromString(string s) */
PHP_METHOD(php_wxNativeFontInfo, FromString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::FromString\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::FromString call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* s0;
	long s_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&s0, &s_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s0, &s_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxNativeFontInfo::FromString(wxString(s0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxNativeFontInfo_php*)native_object)->FromString(wxString(s0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::FromString\n");
	}
}
/* }}} */

/* {{{ proto bool wxNativeFontInfo::FromUserString(string s) */
PHP_METHOD(php_wxNativeFontInfo, FromUserString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::FromUserString\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::FromUserString call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* s0;
	long s_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&s0, &s_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &s0, &s_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxNativeFontInfo::FromUserString(wxString(s0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxNativeFontInfo_php*)native_object)->FromUserString(wxString(s0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::FromUserString\n");
	}
}
/* }}} */

/* {{{ proto wxFontEncoding wxNativeFontInfo::GetEncoding() */
PHP_METHOD(php_wxNativeFontInfo, GetEncoding)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::GetEncoding\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::GetEncoding call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxNativeFontInfo::GetEncoding())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxNativeFontInfo_php*)native_object)->GetEncoding());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::GetEncoding\n");
	}
}
/* }}} */

/* {{{ proto string wxNativeFontInfo::GetFaceName() */
PHP_METHOD(php_wxNativeFontInfo, GetFaceName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::GetFaceName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::GetFaceName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxNativeFontInfo::GetFaceName().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxNativeFontInfo_php*)native_object)->GetFaceName();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::GetFaceName\n");
	}
}
/* }}} */

/* {{{ proto wxFontFamily wxNativeFontInfo::GetFamily() */
PHP_METHOD(php_wxNativeFontInfo, GetFamily)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::GetFamily\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::GetFamily call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxNativeFontInfo::GetFamily())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxNativeFontInfo_php*)native_object)->GetFamily());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::GetFamily\n");
	}
}
/* }}} */

/* {{{ proto int wxNativeFontInfo::GetPointSize() */
PHP_METHOD(php_wxNativeFontInfo, GetPointSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::GetPointSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::GetPointSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxNativeFontInfo::GetPointSize())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxNativeFontInfo_php*)native_object)->GetPointSize());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::GetPointSize\n");
	}
}
/* }}} */

/* {{{ proto wxFontStyle wxNativeFontInfo::GetStyle() */
PHP_METHOD(php_wxNativeFontInfo, GetStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::GetStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::GetStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxNativeFontInfo::GetStyle())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxNativeFontInfo_php*)native_object)->GetStyle());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::GetStyle\n");
	}
}
/* }}} */

/* {{{ proto bool wxNativeFontInfo::GetUnderlined() */
PHP_METHOD(php_wxNativeFontInfo, GetUnderlined)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::GetUnderlined\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::GetUnderlined call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxNativeFontInfo::GetUnderlined())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxNativeFontInfo_php*)native_object)->GetUnderlined());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::GetUnderlined\n");
	}
}
/* }}} */

/* {{{ proto wxFontWeight wxNativeFontInfo::GetWeight() */
PHP_METHOD(php_wxNativeFontInfo, GetWeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::GetWeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::GetWeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxNativeFontInfo::GetWeight())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxNativeFontInfo_php*)native_object)->GetWeight());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::GetWeight\n");
	}
}
/* }}} */

/* {{{ proto  wxNativeFontInfo::Init() */
PHP_METHOD(php_wxNativeFontInfo, Init)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::Init\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::Init call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxNativeFontInfo::Init()\n\n");
				#endif

				((wxNativeFontInfo_php*)native_object)->Init();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::Init\n");
	}
}
/* }}} */

/* {{{ proto  wxNativeFontInfo::InitFromFont(wxFont font) */
PHP_METHOD(php_wxNativeFontInfo, InitFromFont)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::InitFromFont\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::InitFromFont call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* font0 = 0;
	wxFont* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&font0, php_wxFont_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &font0, php_wxFont_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(font0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxFont*) zend_object_store_get_object(font0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxFont*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'font' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(font0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'font' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxNativeFontInfo::InitFromFont(*(wxFont*) object_pointer0_0)\n\n");
				#endif

				((wxNativeFontInfo_php*)native_object)->InitFromFont(*(wxFont*) object_pointer0_0);

				references->AddReference(font0, "wxNativeFontInfo::InitFromFont at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::InitFromFont\n");
	}
}
/* }}} */

/* {{{ proto  wxNativeFontInfo::SetEncoding(wxFontEncoding encoding) */
PHP_METHOD(php_wxNativeFontInfo, SetEncoding)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::SetEncoding\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::SetEncoding call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long encoding0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&encoding0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &encoding0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxNativeFontInfo::SetEncoding((wxFontEncoding) encoding0)\n\n");
				#endif

				((wxNativeFontInfo_php*)native_object)->SetEncoding((wxFontEncoding) encoding0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::SetEncoding\n");
	}
}
/* }}} */

/* {{{ proto bool wxNativeFontInfo::SetFaceName(string facename) */
PHP_METHOD(php_wxNativeFontInfo, SetFaceName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::SetFaceName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::SetFaceName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* facename0;
	long facename_len0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* facenames1 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&facename0, &facename_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &facename0, &facename_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&facenames1)\n");
		#endif

		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &facenames1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxNativeFontInfo::SetFaceName(wxString(facename0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxNativeFontInfo_php*)native_object)->SetFaceName(wxString(facename0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		wxArrayString strings_array1_0;
		bool strings_continue1_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index1_0 = 0;
				zval** temp_array_value1_0 = 0;
				while(strings_continue1_0)
				{
					if(zend_hash_index_find(HASH_OF(facenames1), array_index1_0, (void**)&temp_array_value1_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value1_0);
						strings_array1_0.Add(wxString(Z_STRVAL_PP(temp_array_value1_0), wxConvUTF8));
						array_index1_0++;
					}
					else
					{
						strings_continue1_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxNativeFontInfo::SetFaceName(strings_array1_0)\n\n");
				#endif

				((wxNativeFontInfo_php*)native_object)->SetFaceName(strings_array1_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::SetFaceName\n");
	}
}
/* }}} */

/* {{{ proto  wxNativeFontInfo::SetFamily(wxFontFamily family) */
PHP_METHOD(php_wxNativeFontInfo, SetFamily)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::SetFamily\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::SetFamily call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long family0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&family0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &family0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxNativeFontInfo::SetFamily((wxFontFamily) family0)\n\n");
				#endif

				((wxNativeFontInfo_php*)native_object)->SetFamily((wxFontFamily) family0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::SetFamily\n");
	}
}
/* }}} */

/* {{{ proto  wxNativeFontInfo::SetPointSize(int pointsize) */
PHP_METHOD(php_wxNativeFontInfo, SetPointSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::SetPointSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::SetPointSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pointsize0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&pointsize0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pointsize0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxNativeFontInfo::SetPointSize((int) pointsize0)\n\n");
				#endif

				((wxNativeFontInfo_php*)native_object)->SetPointSize((int) pointsize0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::SetPointSize\n");
	}
}
/* }}} */

/* {{{ proto  wxNativeFontInfo::SetStyle(wxFontStyle style) */
PHP_METHOD(php_wxNativeFontInfo, SetStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::SetStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::SetStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&style0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxNativeFontInfo::SetStyle((wxFontStyle) style0)\n\n");
				#endif

				((wxNativeFontInfo_php*)native_object)->SetStyle((wxFontStyle) style0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::SetStyle\n");
	}
}
/* }}} */

/* {{{ proto  wxNativeFontInfo::SetUnderlined(bool underlined) */
PHP_METHOD(php_wxNativeFontInfo, SetUnderlined)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::SetUnderlined\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::SetUnderlined call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool underlined0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'b' (&underlined0)\n");
		#endif

		char parse_parameters_string[] = "b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &underlined0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxNativeFontInfo::SetUnderlined(underlined0)\n\n");
				#endif

				((wxNativeFontInfo_php*)native_object)->SetUnderlined(underlined0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::SetUnderlined\n");
	}
}
/* }}} */

/* {{{ proto  wxNativeFontInfo::SetWeight(wxFontWeight weight) */
PHP_METHOD(php_wxNativeFontInfo, SetWeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::SetWeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::SetWeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long weight0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&weight0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &weight0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxNativeFontInfo::SetWeight((wxFontWeight) weight0)\n\n");
				#endif

				((wxNativeFontInfo_php*)native_object)->SetWeight((wxFontWeight) weight0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::SetWeight\n");
	}
}
/* }}} */

/* {{{ proto string wxNativeFontInfo::ToString() */
PHP_METHOD(php_wxNativeFontInfo, ToString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::ToString\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::ToString call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxNativeFontInfo::ToString().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxNativeFontInfo_php*)native_object)->ToString();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::ToString\n");
	}
}
/* }}} */

/* {{{ proto string wxNativeFontInfo::ToUserString() */
PHP_METHOD(php_wxNativeFontInfo, ToUserString)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxNativeFontInfo::ToUserString\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxNativeFontInfo* current_object;
	wxphp_object_type current_object_type;
	wxNativeFontInfo_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxNativeFontInfo*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxNativeFontInfo::ToUserString call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXNATIVEFONTINFO_TYPE){
				references = &((wxNativeFontInfo_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxNativeFontInfo::ToUserString().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = ((wxNativeFontInfo_php*)native_object)->ToUserString();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxNativeFontInfo::ToUserString\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxColourDatabase_free(void *object TSRMLS_DC) 
{
    zo_wxColourDatabase* custom_object = (zo_wxColourDatabase*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxColourDatabase_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxColourDatabase done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxColourDatabase_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxColourDatabase_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxColourDatabase* custom_object;
    custom_object = (zo_wxColourDatabase*) emalloc(sizeof(zo_wxColourDatabase));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxColourDatabase_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXCOLOURDATABASE_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxColourDatabase::AddColour(string colourName, wxColour colour)
   Adds a colour to the database. */
PHP_METHOD(php_wxColourDatabase, AddColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxColourDatabase::AddColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxColourDatabase* current_object;
	wxphp_object_type current_object_type;
	wxColourDatabase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxColourDatabase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxColourDatabase::AddColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCOLOURDATABASE_TYPE){
				references = &((wxColourDatabase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* colourName0;
	long colourName_len0;
	zval* colour0 = 0;
	wxColour* object_pointer0_1 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sO' (&colourName0, &colourName_len0, &colour0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "sO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colourName0, &colourName_len0, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(colour0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxColour*) argument_native_object;
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxColourDatabase::AddColour(wxString(colourName0, wxConvUTF8), *(wxColour*) object_pointer0_1)\n\n");
				#endif

				((wxColourDatabase_php*)native_object)->AddColour(wxString(colourName0, wxConvUTF8), *(wxColour*) object_pointer0_1);

				references->AddReference(colour0, "wxColourDatabase::AddColour at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxColourDatabase::AddColour\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxColourDatabase::Find(string colourName)
   Finds a colour given the name. */
PHP_METHOD(php_wxColourDatabase, Find)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxColourDatabase::Find\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxColourDatabase* current_object;
	wxphp_object_type current_object_type;
	wxColourDatabase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxColourDatabase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxColourDatabase::Find call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCOLOURDATABASE_TYPE){
				references = &((wxColourDatabase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* colourName0;
	long colourName_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&colourName0, &colourName_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colourName0, &colourName_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxColourDatabase::Find(wxString(colourName0, wxConvUTF8)) to return new object\n\n");
				#endif

				wxColour value_to_return1;
				value_to_return1 = ((wxColourDatabase_php*)native_object)->Find(wxString(colourName0, wxConvUTF8));
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				((wxColour_php*)ptr)->phpObj = return_value;
				zo_wxColour* zo1 = (zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxColour_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxColourDatabase::Find\n");
	}
}
/* }}} */

/* {{{ proto string wxColourDatabase::FindName(wxColour colour)
   Finds a colour name given the colour. */
PHP_METHOD(php_wxColourDatabase, FindName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxColourDatabase::FindName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxColourDatabase* current_object;
	wxphp_object_type current_object_type;
	wxColourDatabase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxColourDatabase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxColourDatabase::FindName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXCOLOURDATABASE_TYPE){
				references = &((wxColourDatabase_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colour0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxColourDatabase::FindName(*(wxColour*) object_pointer0_0).fn_str(), 1)\n\n");
				#endif

				wxString value_to_return1;
				value_to_return1 = ((wxColourDatabase_php*)native_object)->FindName(*(wxColour*) object_pointer0_0);
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);

				references->AddReference(colour0, "wxColourDatabase::FindName at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxColourDatabase::FindName\n");
	}
}
/* }}} */

/* {{{ proto  wxColourDatabase::wxColourDatabase()
   Constructs the colour database. */
PHP_METHOD(php_wxColourDatabase, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxColourDatabase::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxColourDatabase* current_object;
	wxColourDatabase_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxColourDatabase_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxColourDatabase*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxColourDatabase::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxGDIObject_free(void *object TSRMLS_DC) 
{
    zo_wxGDIObject* custom_object = (zo_wxGDIObject*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGDIObject_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGDIObject done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGDIObject_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGDIObject_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGDIObject* custom_object;
    custom_object = (zo_wxGDIObject*) emalloc(sizeof(zo_wxGDIObject));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGDIObject_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXGDIOBJECT_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxGraphicsRenderer_free(void *object TSRMLS_DC) 
{
    zo_wxGraphicsRenderer* custom_object = (zo_wxGraphicsRenderer*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGraphicsRenderer_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGraphicsRenderer done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGraphicsRenderer_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGraphicsRenderer_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGraphicsRenderer* custom_object;
    custom_object = (zo_wxGraphicsRenderer*) emalloc(sizeof(zo_wxGraphicsRenderer));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGraphicsRenderer_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXGRAPHICSRENDERER_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxGraphicsMatrix_free(void *object TSRMLS_DC) 
{
    zo_wxGraphicsMatrix* custom_object = (zo_wxGraphicsMatrix*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGraphicsMatrix_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxGraphicsMatrix done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxGraphicsMatrix_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxGraphicsMatrix_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxGraphicsMatrix* custom_object;
    custom_object = (zo_wxGraphicsMatrix*) emalloc(sizeof(zo_wxGraphicsMatrix));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxGraphicsMatrix_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXGRAPHICSMATRIX_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

BEGIN_EXTERN_C()
void php_wxIcon_free(void *object TSRMLS_DC) 
{
    zo_wxIcon* custom_object = (zo_wxIcon*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxIcon_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxIcon done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxIcon_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxIcon_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxIcon* custom_object;
    custom_object = (zo_wxIcon*) emalloc(sizeof(zo_wxIcon));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxIcon_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXICON_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxIcon::wxIcon(string name, wxBitmapType type, int desiredWidth, int desiredHeight)
   Loads an icon from a file or resource. */
PHP_METHOD(php_wxIcon, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIcon::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIcon* current_object;
	wxIcon_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	long type0;
	long desiredWidth0;
	long desiredHeight0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* icon1 = 0;
	wxIcon* object_pointer1_0 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|lll' (&name0, &name_len0, &type0, &desiredWidth0, &desiredHeight0)\n");
		#endif

		char parse_parameters_string[] = "s|lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0, &type0, &desiredWidth0, &desiredHeight0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&icon1, php_wxIcon_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &icon1, php_wxIcon_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(icon1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxIcon*) zend_object_store_get_object(icon1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxIcon*) zend_object_store_get_object(icon1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxIcon*) argument_native_object;
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(icon1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload2_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name0, wxConvUTF8))\n");
				#endif

				native_object = new wxIcon_php(wxString(name0, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name0, wxConvUTF8), (wxBitmapType) type0)\n");
				#endif

				native_object = new wxIcon_php(wxString(name0, wxConvUTF8), (wxBitmapType) type0);

				native_object->references.Initialize();
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name0, wxConvUTF8), (wxBitmapType) type0, (int) desiredWidth0)\n");
				#endif

				native_object = new wxIcon_php(wxString(name0, wxConvUTF8), (wxBitmapType) type0, (int) desiredWidth0);

				native_object->references.Initialize();
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name0, wxConvUTF8), (wxBitmapType) type0, (int) desiredWidth0, (int) desiredHeight0)\n");
				#endif

				native_object = new wxIcon_php(wxString(name0, wxConvUTF8), (wxBitmapType) type0, (int) desiredWidth0, (int) desiredHeight0);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxIcon*) object_pointer1_0)\n");
				#endif

				native_object = new wxIcon_php(*(wxIcon*) object_pointer1_0);

				native_object->references.Initialize();
				((wxIcon_php*) native_object)->references.AddReference(icon1, "wxIcon::wxIcon at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxIcon_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxIcon*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxIcon::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxIcon::SetWidth(int width)
   Sets the width member (does not affect the icon data). */
PHP_METHOD(php_wxIcon, SetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIcon::SetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIcon* current_object;
	wxphp_object_type current_object_type;
	wxIcon_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxIcon*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxIcon::SetWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXICON_TYPE){
				references = &((wxIcon_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxIcon::SetWidth((int) width0)\n\n");
				#endif

				((wxIcon_php*)native_object)->SetWidth((int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxIcon::SetWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxIcon::SetHeight(int height)
   Sets the height member (does not affect the icon data). */
PHP_METHOD(php_wxIcon, SetHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIcon::SetHeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIcon* current_object;
	wxphp_object_type current_object_type;
	wxIcon_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxIcon*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxIcon::SetHeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXICON_TYPE){
				references = &((wxIcon_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long height0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&height0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxIcon::SetHeight((int) height0)\n\n");
				#endif

				((wxIcon_php*)native_object)->SetHeight((int) height0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxIcon::SetHeight\n");
	}
}
/* }}} */

/* {{{ proto  wxIcon::SetDepth(int depth)
   Sets the depth member (does not affect the icon data). */
PHP_METHOD(php_wxIcon, SetDepth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIcon::SetDepth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIcon* current_object;
	wxphp_object_type current_object_type;
	wxIcon_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxIcon*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxIcon::SetDepth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXICON_TYPE){
				references = &((wxIcon_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long depth0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&depth0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &depth0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxIcon::SetDepth((int) depth0)\n\n");
				#endif

				((wxIcon_php*)native_object)->SetDepth((int) depth0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxIcon::SetDepth\n");
	}
}
/* }}} */

/* {{{ proto bool wxIcon::LoadFile(string name, wxBitmapType type, int desiredWidth, int desiredHeight)
   Loads an icon from a file or resource. */
PHP_METHOD(php_wxIcon, LoadFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIcon::LoadFile\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIcon* current_object;
	wxphp_object_type current_object_type;
	wxIcon_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxIcon*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxIcon::LoadFile call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXICON_TYPE){
				references = &((wxIcon_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	long type0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* name1;
	long name_len1;
	long type1;
	long desiredWidth1;
	long desiredHeight1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|l' (&name0, &name_len0, &type0)\n");
		#endif

		char parse_parameters_string[] = "s|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0, &type0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'slll' (&name1, &name_len1, &type1, &desiredWidth1, &desiredHeight1)\n");
		#endif

		char parse_parameters_string[] = "slll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name1, &name_len1, &type1, &desiredWidth1, &desiredHeight1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxIcon::LoadFile(wxString(name0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxIcon_php*)native_object)->LoadFile(wxString(name0, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxIcon::LoadFile(wxString(name0, wxConvUTF8), (wxBitmapType) type0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxIcon_php*)native_object)->LoadFile(wxString(name0, wxConvUTF8), (wxBitmapType) type0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxIcon::LoadFile(wxString(name1, wxConvUTF8), (wxBitmapType) type1, (int) desiredWidth1, (int) desiredHeight1))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxIcon_php*)native_object)->LoadFile(wxString(name1, wxConvUTF8), (wxBitmapType) type1, (int) desiredWidth1, (int) desiredHeight1));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxIcon::LoadFile\n");
	}
}
/* }}} */

/* {{{ proto bool wxIcon::IsOk()
   Returns true if icon data is present. */
PHP_METHOD(php_wxIcon, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIcon::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIcon* current_object;
	wxphp_object_type current_object_type;
	wxIcon_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxIcon*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxIcon::IsOk call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXICON_TYPE){
				references = &((wxIcon_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxIcon::IsOk())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxIcon_php*)native_object)->IsOk());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxIcon::IsOk\n");
	}
}
/* }}} */

/* {{{ proto int wxIcon::GetWidth()
   Gets the width of the icon in pixels. */
PHP_METHOD(php_wxIcon, GetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIcon::GetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIcon* current_object;
	wxphp_object_type current_object_type;
	wxIcon_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxIcon*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxIcon::GetWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXICON_TYPE){
				references = &((wxIcon_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxIcon::GetWidth())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxIcon_php*)native_object)->GetWidth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxIcon::GetWidth\n");
	}
}
/* }}} */

/* {{{ proto int wxIcon::GetHeight()
   Gets the height of the icon in pixels. */
PHP_METHOD(php_wxIcon, GetHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIcon::GetHeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIcon* current_object;
	wxphp_object_type current_object_type;
	wxIcon_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxIcon*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxIcon::GetHeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXICON_TYPE){
				references = &((wxIcon_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxIcon::GetHeight())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxIcon_php*)native_object)->GetHeight());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxIcon::GetHeight\n");
	}
}
/* }}} */

/* {{{ proto int wxIcon::GetDepth()
   Gets the colour depth of the icon. */
PHP_METHOD(php_wxIcon, GetDepth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIcon::GetDepth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIcon* current_object;
	wxphp_object_type current_object_type;
	wxIcon_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxIcon*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxIcon::GetDepth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXICON_TYPE){
				references = &((wxIcon_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxIcon::GetDepth())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxIcon_php*)native_object)->GetDepth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxIcon::GetDepth\n");
	}
}
/* }}} */

/* {{{ proto  wxIcon::CopyFromBitmap(wxBitmap bmp)
   Copies bmp bitmap to this icon. */
PHP_METHOD(php_wxIcon, CopyFromBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIcon::CopyFromBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIcon* current_object;
	wxphp_object_type current_object_type;
	wxIcon_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxIcon*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxIcon::CopyFromBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXICON_TYPE){
				references = &((wxIcon_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bmp0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&bmp0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bmp0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bmp0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bmp0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bmp0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'bmp' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bmp0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bmp' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxIcon::CopyFromBitmap(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif

				((wxIcon_php*)native_object)->CopyFromBitmap(*(wxBitmap*) object_pointer0_0);

				references->AddReference(bmp0, "wxIcon::CopyFromBitmap at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxIcon::CopyFromBitmap\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxIconBundle_free(void *object TSRMLS_DC) 
{
    zo_wxIconBundle* custom_object = (zo_wxIconBundle*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxIconBundle_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxIconBundle done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxIconBundle_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxIconBundle_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxIconBundle* custom_object;
    custom_object = (zo_wxIconBundle*) emalloc(sizeof(zo_wxIconBundle));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxIconBundle_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXICONBUNDLE_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxIconBundle::wxIconBundle()
   Default ctor. */
PHP_METHOD(php_wxIconBundle, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIconBundle::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIconBundle* current_object;
	wxIconBundle_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	char* file1;
	long file_len1;
	long type1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* icon2 = 0;
	wxIcon* object_pointer2_0 = 0;
	bool overload2_called = false;
	//Parameters for overload 3
	zval* ic3 = 0;
	wxIconBundle* object_pointer3_0 = 0;
	bool overload3_called = false;
	//Parameters for overload 4
	zval* stream4 = 0;
	wxInputStream* object_pointer4_0 = 0;
	long type4;
	bool overload4_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|l' (&file1, &file_len1, &type1)\n");
		#endif

		char parse_parameters_string[] = "s|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &file1, &file_len1, &type1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&icon2, php_wxIcon_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &icon2, php_wxIcon_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(icon2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxIcon*) zend_object_store_get_object(icon2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxIcon*) zend_object_store_get_object(icon2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxIcon*) argument_native_object;
					if (!object_pointer2_0 )
					{
						goto overload3;
					}
				}
				else if(Z_TYPE_P(icon2) != IS_NULL)
				{
					goto overload3;
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&ic3, php_wxIconBundle_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &ic3, php_wxIconBundle_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(ic3) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxIconBundle*) zend_object_store_get_object(ic3 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxIconBundle*) zend_object_store_get_object(ic3 TSRMLS_CC))->native_object;
					object_pointer3_0 = (wxIconBundle*) argument_native_object;
					if (!object_pointer3_0 )
					{
						goto overload4;
					}
				}
				else if(Z_TYPE_P(ic3) != IS_NULL)
				{
					goto overload4;
				}
			}

			overload3_called = true;
			already_called = true;
		}
	}

	//Overload 4
	overload4:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'o|l' (&stream4, &type4)\n");
		#endif

		char parse_parameters_string[] = "o|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stream4, &type4 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stream4) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxInputStream*) zend_object_store_get_object(stream4 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxInputStream*) zend_object_store_get_object(stream4 TSRMLS_CC))->native_object;
					object_pointer4_0 = (wxInputStream*) argument_native_object;
					if (!object_pointer4_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'stream' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(stream4) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'stream' not null, could not be retreived correctly.");
				}
			}

			overload4_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxIconBundle_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(file1, wxConvUTF8))\n");
				#endif

				native_object = new wxIconBundle_php(wxString(file1, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(file1, wxConvUTF8), (wxBitmapType) type1)\n");
				#endif

				native_object = new wxIconBundle_php(wxString(file1, wxConvUTF8), (wxBitmapType) type1);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxIcon*) object_pointer2_0)\n");
				#endif

				native_object = new wxIconBundle_php(*(wxIcon*) object_pointer2_0);

				native_object->references.Initialize();
				((wxIconBundle_php*) native_object)->references.AddReference(icon2, "wxIconBundle::wxIconBundle at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxIconBundle*) object_pointer3_0)\n");
				#endif

				native_object = new wxIconBundle_php(*(wxIconBundle*) object_pointer3_0);

				native_object->references.Initialize();
				((wxIconBundle_php*) native_object)->references.AddReference(ic3, "wxIconBundle::wxIconBundle at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload4_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxInputStream*) object_pointer4_0)\n");
				#endif

				native_object = new wxIconBundle_php(*(wxInputStream*) object_pointer4_0);

				native_object->references.Initialize();
				((wxIconBundle_php*) native_object)->references.AddReference(stream4, "wxIconBundle::wxIconBundle at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxInputStream*) object_pointer4_0, (wxBitmapType) type4)\n");
				#endif

				native_object = new wxIconBundle_php(*(wxInputStream*) object_pointer4_0, (wxBitmapType) type4);

				native_object->references.Initialize();
				((wxIconBundle_php*) native_object)->references.AddReference(stream4, "wxIconBundle::wxIconBundle at call with 2 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxIconBundle*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxIconBundle::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto bool wxIconBundle::IsEmpty()
   Returns true if the bundle doesn't contain any icons, false otherwise (in which case a call to GetIcon() with default parameter should return a valid icon). */
PHP_METHOD(php_wxIconBundle, IsEmpty)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIconBundle::IsEmpty\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIconBundle* current_object;
	wxphp_object_type current_object_type;
	wxIconBundle_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxIconBundle*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxIconBundle::IsEmpty call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXICONBUNDLE_TYPE){
				references = &((wxIconBundle_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxIconBundle::IsEmpty())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxIconBundle_php*)native_object)->IsEmpty());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxIconBundle::IsEmpty\n");
	}
}
/* }}} */

/* {{{ proto wxIcon wxIconBundle::GetIconOfExactSize(wxSize size)
   Returns the icon with exactly the given size or wxNullIcon if this size is not available. */
PHP_METHOD(php_wxIconBundle, GetIconOfExactSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIconBundle::GetIconOfExactSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIconBundle* current_object;
	wxphp_object_type current_object_type;
	wxIconBundle_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxIconBundle*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxIconBundle::GetIconOfExactSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXICONBUNDLE_TYPE){
				references = &((wxIconBundle_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* size0 = 0;
	wxSize* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&size0, php_wxSize_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size0, php_wxSize_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxSize*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxIconBundle::GetIconOfExactSize(*(wxSize*) object_pointer0_0) to return new object\n\n");
				#endif

				wxIcon value_to_return1;
				value_to_return1 = ((wxIconBundle_php*)native_object)->GetIconOfExactSize(*(wxSize*) object_pointer0_0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxIcon));
				object_init_ex(return_value, php_wxIcon_entry);
				((wxIcon_php*)ptr)->phpObj = return_value;
				zo_wxIcon* zo1 = (zo_wxIcon*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxIcon_php*) ptr;

				references->AddReference(size0, "wxIconBundle::GetIconOfExactSize at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxIconBundle::GetIconOfExactSize\n");
	}
}
/* }}} */

/* {{{ proto int wxIconBundle::GetIconCount()
   return the number of available icons */
PHP_METHOD(php_wxIconBundle, GetIconCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIconBundle::GetIconCount\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIconBundle* current_object;
	wxphp_object_type current_object_type;
	wxIconBundle_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxIconBundle*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxIconBundle::GetIconCount call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXICONBUNDLE_TYPE){
				references = &((wxIconBundle_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxIconBundle::GetIconCount())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxIconBundle_php*)native_object)->GetIconCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxIconBundle::GetIconCount\n");
	}
}
/* }}} */

/* {{{ proto wxIcon wxIconBundle::GetIconByIndex(int n)
   return the icon at index (must be < GetIconCount()) */
PHP_METHOD(php_wxIconBundle, GetIconByIndex)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIconBundle::GetIconByIndex\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIconBundle* current_object;
	wxphp_object_type current_object_type;
	wxIconBundle_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxIconBundle*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxIconBundle::GetIconByIndex call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXICONBUNDLE_TYPE){
				references = &((wxIconBundle_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&n0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxIconBundle::GetIconByIndex((size_t) n0) to return new object\n\n");
				#endif

				wxIcon value_to_return1;
				value_to_return1 = ((wxIconBundle_php*)native_object)->GetIconByIndex((size_t) n0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxIcon));
				object_init_ex(return_value, php_wxIcon_entry);
				((wxIcon_php*)ptr)->phpObj = return_value;
				zo_wxIcon* zo1 = (zo_wxIcon*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxIcon_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxIconBundle::GetIconByIndex\n");
	}
}
/* }}} */

/* {{{ proto  wxIconBundle::AddIcon(wxIcon icon)
   Adds the icon to the collection; if the collection already contains an icon with the same width and height, it is replaced by the new one. */
PHP_METHOD(php_wxIconBundle, AddIcon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIconBundle::AddIcon\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIconBundle* current_object;
	wxphp_object_type current_object_type;
	wxIconBundle_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxIconBundle*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxIconBundle::AddIcon call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXICONBUNDLE_TYPE){
				references = &((wxIconBundle_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* icon0 = 0;
	wxIcon* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* file1;
	long file_len1;
	long type1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* stream2 = 0;
	wxInputStream* object_pointer2_0 = 0;
	long type2;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&icon0, php_wxIcon_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &icon0, php_wxIcon_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(icon0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxIcon*) zend_object_store_get_object(icon0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxIcon*) zend_object_store_get_object(icon0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxIcon*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(icon0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|l' (&file1, &file_len1, &type1)\n");
		#endif

		char parse_parameters_string[] = "s|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &file1, &file_len1, &type1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'o|l' (&stream2, &type2)\n");
		#endif

		char parse_parameters_string[] = "o|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stream2, &type2 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stream2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxInputStream*) zend_object_store_get_object(stream2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxInputStream*) zend_object_store_get_object(stream2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxInputStream*) argument_native_object;
					if (!object_pointer2_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'stream' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(stream2) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'stream' not null, could not be retreived correctly.");
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxIconBundle::AddIcon(*(wxIcon*) object_pointer0_0)\n\n");
				#endif

				((wxIconBundle_php*)native_object)->AddIcon(*(wxIcon*) object_pointer0_0);

				references->AddReference(icon0, "wxIconBundle::AddIcon at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxIconBundle::AddIcon(wxString(file1, wxConvUTF8))\n\n");
				#endif

				((wxIconBundle_php*)native_object)->AddIcon(wxString(file1, wxConvUTF8));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxIconBundle::AddIcon(wxString(file1, wxConvUTF8), (wxBitmapType) type1)\n\n");
				#endif

				((wxIconBundle_php*)native_object)->AddIcon(wxString(file1, wxConvUTF8), (wxBitmapType) type1);


				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxIconBundle::AddIcon(*(wxInputStream*) object_pointer2_0)\n\n");
				#endif

				((wxIconBundle_php*)native_object)->AddIcon(*(wxInputStream*) object_pointer2_0);

				references->AddReference(stream2, "wxIconBundle::AddIcon at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxIconBundle::AddIcon(*(wxInputStream*) object_pointer2_0, (wxBitmapType) type2)\n\n");
				#endif

				((wxIconBundle_php*)native_object)->AddIcon(*(wxInputStream*) object_pointer2_0, (wxBitmapType) type2);

				references->AddReference(stream2, "wxIconBundle::AddIcon at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxIconBundle::AddIcon\n");
	}
}
/* }}} */

/* {{{ proto wxIcon wxIconBundle::GetIcon(wxSize size, int flags)
   Returns the icon with the given size. */
PHP_METHOD(php_wxIconBundle, GetIcon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxIconBundle::GetIcon\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxIconBundle* current_object;
	wxphp_object_type current_object_type;
	wxIconBundle_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxIconBundle*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxIconBundle::GetIcon call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXICONBUNDLE_TYPE){
				references = &((wxIconBundle_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* size0 = 0;
	wxSize* object_pointer0_0 = 0;
	long flags0;
	bool overload0_called = false;
	//Parameters for overload 1
	long size1;
	long flags1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|l' (&size0, php_wxSize_entry, &flags0)\n");
		#endif

		char parse_parameters_string[] = "O|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size0, php_wxSize_entry, &flags0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxSize*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|ll' (&size1, &flags1)\n");
		#endif

		char parse_parameters_string[] = "|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size1, &flags1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxIconBundle::GetIcon(*(wxSize*) object_pointer0_0) to return new object\n\n");
				#endif

				wxIcon value_to_return1;
				value_to_return1 = ((wxIconBundle_php*)native_object)->GetIcon(*(wxSize*) object_pointer0_0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxIcon));
				object_init_ex(return_value, php_wxIcon_entry);
				((wxIcon_php*)ptr)->phpObj = return_value;
				zo_wxIcon* zo1 = (zo_wxIcon*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxIcon_php*) ptr;

				references->AddReference(size0, "wxIconBundle::GetIcon at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxIconBundle::GetIcon(*(wxSize*) object_pointer0_0, (int) flags0) to return new object\n\n");
				#endif

				wxIcon value_to_return2;
				value_to_return2 = ((wxIconBundle_php*)native_object)->GetIcon(*(wxSize*) object_pointer0_0, (int) flags0);
				((wxRefCounter *) value_to_return2.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxIcon));
				object_init_ex(return_value, php_wxIcon_entry);
				((wxIcon_php*)ptr)->phpObj = return_value;
				zo_wxIcon* zo2 = (zo_wxIcon*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo2->native_object = (wxIcon_php*) ptr;

				references->AddReference(size0, "wxIconBundle::GetIcon at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxIconBundle::GetIcon() to return new object\n\n");
				#endif

				wxIcon value_to_return0;
				value_to_return0 = ((wxIconBundle_php*)native_object)->GetIcon();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxIcon));
				object_init_ex(return_value, php_wxIcon_entry);
				((wxIcon_php*)ptr)->phpObj = return_value;
				zo_wxIcon* zo0 = (zo_wxIcon*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxIcon_php*) ptr;


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxIconBundle::GetIcon((wxCoord) size1) to return new object\n\n");
				#endif

				wxIcon value_to_return1;
				value_to_return1 = ((wxIconBundle_php*)native_object)->GetIcon((wxCoord) size1);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxIcon));
				object_init_ex(return_value, php_wxIcon_entry);
				((wxIcon_php*)ptr)->phpObj = return_value;
				zo_wxIcon* zo1 = (zo_wxIcon*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxIcon_php*) ptr;


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxIconBundle::GetIcon((wxCoord) size1, (int) flags1) to return new object\n\n");
				#endif

				wxIcon value_to_return2;
				value_to_return2 = ((wxIconBundle_php*)native_object)->GetIcon((wxCoord) size1, (int) flags1);
				((wxRefCounter *) value_to_return2.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxIcon));
				object_init_ex(return_value, php_wxIcon_entry);
				((wxIcon_php*)ptr)->phpObj = return_value;
				zo_wxIcon* zo2 = (zo_wxIcon*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo2->native_object = (wxIcon_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxIconBundle::GetIcon\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxImageHandler_free(void *object TSRMLS_DC) 
{
    zo_wxImageHandler* custom_object = (zo_wxImageHandler*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxImageHandler_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxImageHandler done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxImageHandler_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxImageHandler_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxImageHandler* custom_object;
    custom_object = (zo_wxImageHandler*) emalloc(sizeof(zo_wxImageHandler));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxImageHandler_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXIMAGEHANDLER_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto bool wxImageHandler::CanRead(wxInputStream &stream)
   Returns true if this handler supports the image format contained in the given stream. */
PHP_METHOD(php_wxImageHandler, CanRead)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageHandler::CanRead\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageHandler* current_object;
	wxphp_object_type current_object_type;
	wxImageHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageHandler::CanRead call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
				references = &((wxImageHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* stream0 = 0;
	wxInputStream* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* filename1;
	long filename_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'o' (&stream0)\n");
		#endif

		char parse_parameters_string[] = "o";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stream0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stream0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxInputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxInputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxInputStream*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(stream0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&filename1, &filename_len1)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filename1, &filename_len1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageHandler::CanRead(*(wxInputStream*) object_pointer0_0))\n\n");
				#endif

				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxImageHandler_php*)native_object)->CanRead(*(wxInputStream*) object_pointer0_0));
				}

				references->AddReference(stream0, "wxImageHandler::CanRead at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageHandler::CanRead(wxString(filename1, wxConvUTF8)))\n\n");
				#endif

				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxImageHandler_php*)native_object)->CanRead(wxString(filename1, wxConvUTF8)));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageHandler::CanRead\n");
	}
}
/* }}} */

/* {{{ proto array wxImageHandler::GetAltExtensions()
   Returns the other file extensions associated with this handler. */
PHP_METHOD(php_wxImageHandler, GetAltExtensions)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageHandler::GetAltExtensions\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageHandler* current_object;
	wxphp_object_type current_object_type;
	wxImageHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageHandler::GetAltExtensions call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
				references = &((wxImageHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImageHandler::GetAltExtensions() to return strings array\n\n");
				#endif

				wxArrayString value_to_return0;
				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					value_to_return0 = ((wxImageHandler_php*)native_object)->GetAltExtensions();
				}
				char* temp_string0;
				array_init(return_value);
				for(size_t i=0; i<value_to_return0.GetCount(); i++)
				{
					temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0[i].size()+1));
					strcpy (temp_string0, (const char *) value_to_return0[i].char_str() );
					add_next_index_string(return_value, (char*) temp_string0, 1);
					free(temp_string0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageHandler::GetAltExtensions\n");
	}
}
/* }}} */

/* {{{ proto string wxImageHandler::GetExtension()
   Gets the preferred file extension associated with this handler. */
PHP_METHOD(php_wxImageHandler, GetExtension)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageHandler::GetExtension\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageHandler* current_object;
	wxphp_object_type current_object_type;
	wxImageHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageHandler::GetExtension call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
				references = &((wxImageHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxImageHandler::GetExtension().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					value_to_return0 = ((wxImageHandler_php*)native_object)->GetExtension();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageHandler::GetExtension\n");
	}
}
/* }}} */

/* {{{ proto int wxImageHandler::GetImageCount(wxInputStream &stream)
   If the image file contains more than one image and the image handler is capable of retrieving these individually, this function will return the number of available images. */
PHP_METHOD(php_wxImageHandler, GetImageCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageHandler::GetImageCount\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageHandler* current_object;
	wxphp_object_type current_object_type;
	wxImageHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageHandler::GetImageCount call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
				references = &((wxImageHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* stream0 = 0;
	wxInputStream* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'o' (&stream0)\n");
		#endif

		char parse_parameters_string[] = "o";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stream0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stream0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxInputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxInputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxInputStream*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'stream' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(stream0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'stream' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImageHandler::GetImageCount(*(wxInputStream*) object_pointer0_0))\n\n");
				#endif

				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					ZVAL_LONG(return_value, ((wxImageHandler_php*)native_object)->GetImageCount(*(wxInputStream*) object_pointer0_0));
				}

				references->AddReference(stream0, "wxImageHandler::GetImageCount at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageHandler::GetImageCount\n");
	}
}
/* }}} */

/* {{{ proto string wxImageHandler::GetMimeType()
   Gets the MIME type associated with this handler. */
PHP_METHOD(php_wxImageHandler, GetMimeType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageHandler::GetMimeType\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageHandler* current_object;
	wxphp_object_type current_object_type;
	wxImageHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageHandler::GetMimeType call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
				references = &((wxImageHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxImageHandler::GetMimeType().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					value_to_return0 = ((wxImageHandler_php*)native_object)->GetMimeType();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageHandler::GetMimeType\n");
	}
}
/* }}} */

/* {{{ proto string wxImageHandler::GetName()
   Gets the name of this handler. */
PHP_METHOD(php_wxImageHandler, GetName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageHandler::GetName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageHandler* current_object;
	wxphp_object_type current_object_type;
	wxImageHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageHandler::GetName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
				references = &((wxImageHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxImageHandler::GetName().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					value_to_return0 = ((wxImageHandler_php*)native_object)->GetName();
				}
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageHandler::GetName\n");
	}
}
/* }}} */

/* {{{ proto wxBitmapType wxImageHandler::GetType()
   Gets the image type associated with this handler. */
PHP_METHOD(php_wxImageHandler, GetType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageHandler::GetType\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageHandler* current_object;
	wxphp_object_type current_object_type;
	wxImageHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageHandler::GetType call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
				references = &((wxImageHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImageHandler::GetType())\n\n");
				#endif

				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					ZVAL_LONG(return_value, ((wxImageHandler_php*)native_object)->GetType());
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageHandler::GetType\n");
	}
}
/* }}} */

/* {{{ proto bool wxImageHandler::LoadFile(wxImage &image, wxInputStream &stream, bool verbose, int index)
   Loads a image from a stream, putting the resulting data into image. */
PHP_METHOD(php_wxImageHandler, LoadFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageHandler::LoadFile\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageHandler* current_object;
	wxphp_object_type current_object_type;
	wxImageHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageHandler::LoadFile call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
				references = &((wxImageHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* image0 = 0;
	wxImage* object_pointer0_0 = 0;
	zval* stream0 = 0;
	wxInputStream* object_pointer0_1 = 0;
	bool verbose0;
	long index0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zo|bl' (&image0, &stream0, &verbose0, &index0)\n");
		#endif

		char parse_parameters_string[] = "zo|bl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &image0, &stream0, &verbose0, &index0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(image0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxImage*) zend_object_store_get_object(image0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxImage*) zend_object_store_get_object(image0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxImage*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXIMAGE_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'image' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(image0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'image' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(stream0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxInputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxInputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxInputStream*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'stream' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(stream0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'stream' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageHandler::LoadFile((wxImage*) object_pointer0_0, *(wxInputStream*) object_pointer0_1))\n\n");
				#endif

				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxImageHandler_php*)native_object)->LoadFile((wxImage*) object_pointer0_0, *(wxInputStream*) object_pointer0_1));
				}

				references->AddReference(image0, "wxImageHandler::LoadFile at call with 2 argument(s)");
				references->AddReference(stream0, "wxImageHandler::LoadFile at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageHandler::LoadFile((wxImage*) object_pointer0_0, *(wxInputStream*) object_pointer0_1, verbose0))\n\n");
				#endif

				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxImageHandler_php*)native_object)->LoadFile((wxImage*) object_pointer0_0, *(wxInputStream*) object_pointer0_1, verbose0));
				}

				references->AddReference(image0, "wxImageHandler::LoadFile at call with 3 argument(s)");
				references->AddReference(stream0, "wxImageHandler::LoadFile at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageHandler::LoadFile((wxImage*) object_pointer0_0, *(wxInputStream*) object_pointer0_1, verbose0, (int) index0))\n\n");
				#endif

				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxImageHandler_php*)native_object)->LoadFile((wxImage*) object_pointer0_0, *(wxInputStream*) object_pointer0_1, verbose0, (int) index0));
				}

				references->AddReference(image0, "wxImageHandler::LoadFile at call with 4 argument(s)");
				references->AddReference(stream0, "wxImageHandler::LoadFile at call with 4 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageHandler::LoadFile\n");
	}
}
/* }}} */

/* {{{ proto bool wxImageHandler::SaveFile(wxImage &image, wxOutputStream &stream, bool verbose)
   Saves a image in the output stream. */
PHP_METHOD(php_wxImageHandler, SaveFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageHandler::SaveFile\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageHandler* current_object;
	wxphp_object_type current_object_type;
	wxImageHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageHandler::SaveFile call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
				references = &((wxImageHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* image0 = 0;
	wxImage* object_pointer0_0 = 0;
	zval* stream0 = 0;
	wxOutputStream* object_pointer0_1 = 0;
	bool verbose0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'zo|b' (&image0, &stream0, &verbose0)\n");
		#endif

		char parse_parameters_string[] = "zo|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &image0, &stream0, &verbose0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(image0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxImage*) zend_object_store_get_object(image0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxImage*) zend_object_store_get_object(image0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxImage*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXIMAGE_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'image' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(image0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'image' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(stream0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxOutputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxOutputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxOutputStream*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXOUTPUTSTREAM_TYPE && argument_type != PHP_WXFFILEOUTPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEOUTPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'stream' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(stream0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'stream' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageHandler::SaveFile((wxImage*) object_pointer0_0, *(wxOutputStream*) object_pointer0_1))\n\n");
				#endif

				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxImageHandler_php*)native_object)->SaveFile((wxImage*) object_pointer0_0, *(wxOutputStream*) object_pointer0_1));
				}

				references->AddReference(image0, "wxImageHandler::SaveFile at call with 2 argument(s)");
				references->AddReference(stream0, "wxImageHandler::SaveFile at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageHandler::SaveFile((wxImage*) object_pointer0_0, *(wxOutputStream*) object_pointer0_1, verbose0))\n\n");
				#endif

				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					ZVAL_BOOL(return_value, ((wxImageHandler_php*)native_object)->SaveFile((wxImage*) object_pointer0_0, *(wxOutputStream*) object_pointer0_1, verbose0));
				}

				references->AddReference(image0, "wxImageHandler::SaveFile at call with 3 argument(s)");
				references->AddReference(stream0, "wxImageHandler::SaveFile at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageHandler::SaveFile\n");
	}
}
/* }}} */

/* {{{ proto  wxImageHandler::SetAltExtensions(array extensions)
   Sets the alternative file extensions associated with this handler. */
PHP_METHOD(php_wxImageHandler, SetAltExtensions)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageHandler::SetAltExtensions\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageHandler* current_object;
	wxphp_object_type current_object_type;
	wxImageHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageHandler::SetAltExtensions call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
				references = &((wxImageHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* extensions0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'a' (&extensions0)\n");
		#endif

		char parse_parameters_string[] = "a";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &extensions0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		wxArrayString strings_array0_0;
		bool strings_continue0_0 = true;

		switch(arguments_received)
		{
			case 1:
			{
				int array_index0_0 = 0;
				zval** temp_array_value0_0 = 0;
				while(strings_continue0_0)
				{
					if(zend_hash_index_find(HASH_OF(extensions0), array_index0_0, (void**)&temp_array_value0_0) == SUCCESS)
					{
						convert_to_string(*temp_array_value0_0);
						strings_array0_0.Add(wxString(Z_STRVAL_PP(temp_array_value0_0), wxConvUTF8));
						array_index0_0++;
					}
					else
					{
						strings_continue0_0 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImageHandler::SetAltExtensions(strings_array0_0)\n\n");
				#endif

				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					((wxImageHandler_php*)native_object)->SetAltExtensions(strings_array0_0);
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageHandler::SetAltExtensions\n");
	}
}
/* }}} */

/* {{{ proto  wxImageHandler::SetExtension(string extension)
   Sets the preferred file extension associated with this handler. */
PHP_METHOD(php_wxImageHandler, SetExtension)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageHandler::SetExtension\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageHandler* current_object;
	wxphp_object_type current_object_type;
	wxImageHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageHandler::SetExtension call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
				references = &((wxImageHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* extension0;
	long extension_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&extension0, &extension_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &extension0, &extension_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImageHandler::SetExtension(wxString(extension0, wxConvUTF8))\n\n");
				#endif

				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					((wxImageHandler_php*)native_object)->SetExtension(wxString(extension0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageHandler::SetExtension\n");
	}
}
/* }}} */

/* {{{ proto  wxImageHandler::SetMimeType(string mimetype)
   Sets the handler MIME type. */
PHP_METHOD(php_wxImageHandler, SetMimeType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageHandler::SetMimeType\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageHandler* current_object;
	wxphp_object_type current_object_type;
	wxImageHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageHandler::SetMimeType call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
				references = &((wxImageHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* mimetype0;
	long mimetype_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&mimetype0, &mimetype_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &mimetype0, &mimetype_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImageHandler::SetMimeType(wxString(mimetype0, wxConvUTF8))\n\n");
				#endif

				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					((wxImageHandler_php*)native_object)->SetMimeType(wxString(mimetype0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageHandler::SetMimeType\n");
	}
}
/* }}} */

/* {{{ proto  wxImageHandler::SetName(string name)
   Sets the handler name. */
PHP_METHOD(php_wxImageHandler, SetName)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageHandler::SetName\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageHandler* current_object;
	wxphp_object_type current_object_type;
	wxImageHandler_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageHandler*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageHandler::SetName call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGEHANDLER_TYPE){
				references = &((wxImageHandler_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImageHandler::SetName(wxString(name0, wxConvUTF8))\n\n");
				#endif

				if(current_object_type == PHP_WXIMAGEHANDLER_TYPE)
				{
					((wxImageHandler_php*)native_object)->SetName(wxString(name0, wxConvUTF8));
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageHandler::SetName\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxImage_free(void *object TSRMLS_DC) 
{
    zo_wxImage* custom_object = (zo_wxImage*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxImage_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxImage done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxImage_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxImage_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxImage* custom_object;
    custom_object = (zo_wxImage*) emalloc(sizeof(zo_wxImage));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxImage_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXIMAGE_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxImage::wxImage(int width, int height, bool clear)
   Creates an image with the given size and clears it if requested. */
PHP_METHOD(php_wxImage, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	long width0;
	long height0;
	bool clear0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
	//Parameters for overload 2
	zval* sz2 = 0;
	wxSize* object_pointer2_0 = 0;
	bool clear2;
	bool overload2_called = false;
	//Parameters for overload 3
	char* name3;
	long name_len3;
	long type3;
	long index3;
	bool overload3_called = false;
	//Parameters for overload 4
	char* name4;
	long name_len4;
	char* mimetype4;
	long mimetype_len4;
	long index4;
	bool overload4_called = false;
	//Parameters for overload 5
	zval* stream5 = 0;
	wxInputStream* object_pointer5_0 = 0;
	long type5;
	long index5;
	bool overload5_called = false;
	//Parameters for overload 6
	zval* stream6 = 0;
	wxInputStream* object_pointer6_0 = 0;
	char* mimetype6;
	long mimetype_len6;
	long index6;
	bool overload6_called = false;
	//Parameters for overload 7
	zval* sz7 = 0;
	wxSize* object_pointer7_0 = 0;
	long* data7;
	zval* data7_ref;
	long* alpha7;
	zval* alpha7_ref;
	bool static_data7;
	bool overload7_called = false;
	//Parameters for overload 8
	long width8;
	long height8;
	long* data8;
	zval* data8_ref;
	long* alpha8;
	zval* alpha8_ref;
	bool static_data8;
	bool overload8_called = false;
	//Parameters for overload 9
	zval* sz9 = 0;
	wxSize* object_pointer9_0 = 0;
	long* data9;
	zval* data9_ref;
	bool static_data9;
	bool overload9_called = false;
	//Parameters for overload 10
	long width10;
	long height10;
	long* data10;
	zval* data10_ref;
	bool static_data10;
	bool overload10_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll|b' (&width0, &height0, &clear0)\n");
		#endif

		char parse_parameters_string[] = "ll|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0, &height0, &clear0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload1_called = true;
		already_called = true;
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|b' (&sz2, php_wxSize_entry, &clear2)\n");
		#endif

		char parse_parameters_string[] = "O|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &sz2, php_wxSize_entry, &clear2 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(sz2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(sz2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(sz2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxSize*) argument_native_object;
					if (!object_pointer2_0 )
					{
						goto overload3;
					}
				}
				else if(Z_TYPE_P(sz2) != IS_NULL)
				{
					goto overload3;
				}
			}

			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received >= 1  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|ll' (&name3, &name_len3, &type3, &index3)\n");
		#endif

		char parse_parameters_string[] = "s|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name3, &name_len3, &type3, &index3 ) == SUCCESS)
		{
			overload3_called = true;
			already_called = true;
		}
	}

	//Overload 4
	overload4:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ss|l' (&name4, &name_len4, &mimetype4, &mimetype_len4, &index4)\n");
		#endif

		char parse_parameters_string[] = "ss|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name4, &name_len4, &mimetype4, &mimetype_len4, &index4 ) == SUCCESS)
		{
			overload4_called = true;
			already_called = true;
		}
	}

	//Overload 5
	overload5:
	if(!already_called && arguments_received >= 1  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'o|ll' (&stream5, &type5, &index5)\n");
		#endif

		char parse_parameters_string[] = "o|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stream5, &type5, &index5 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stream5) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxInputStream*) zend_object_store_get_object(stream5 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxInputStream*) zend_object_store_get_object(stream5 TSRMLS_CC))->native_object;
					object_pointer5_0 = (wxInputStream*) argument_native_object;
					if (!object_pointer5_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
					{
						goto overload6;
					}
				}
				else if(Z_TYPE_P(stream5) != IS_NULL)
				{
					goto overload6;
				}
			}

			overload5_called = true;
			already_called = true;
		}
	}

	//Overload 6
	overload6:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'os|l' (&stream6, &mimetype6, &mimetype_len6, &index6)\n");
		#endif

		char parse_parameters_string[] = "os|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stream6, &mimetype6, &mimetype_len6, &index6 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stream6) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxInputStream*) zend_object_store_get_object(stream6 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxInputStream*) zend_object_store_get_object(stream6 TSRMLS_CC))->native_object;
					object_pointer6_0 = (wxInputStream*) argument_native_object;
					if (!object_pointer6_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
					{
						goto overload7;
					}
				}
				else if(Z_TYPE_P(stream6) != IS_NULL)
				{
					goto overload7;
				}
			}

			overload6_called = true;
			already_called = true;
		}
	}

	//Overload 7
	overload7:
	if(!already_called && arguments_received >= 3  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Oll|b' (&sz7, php_wxSize_entry, data7, alpha7, &static_data7)\n");
		#endif

		char parse_parameters_string[] = "Oll|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &sz7, php_wxSize_entry, data7, alpha7, &static_data7 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(sz7) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(sz7 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(sz7 TSRMLS_CC))->native_object;
					object_pointer7_0 = (wxSize*) argument_native_object;
					if (!object_pointer7_0 )
					{
						goto overload8;
					}
				}
				else if(Z_TYPE_P(sz7) != IS_NULL)
				{
					goto overload8;
				}
			}

			overload7_called = true;
			already_called = true;

			char parse_references_string[] = "zzz|z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &data7_ref, &alpha7_ref, &dummy );
		}
	}

	//Overload 8
	overload8:
	if(!already_called && arguments_received >= 4  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll|b' (&width8, &height8, data8, alpha8, &static_data8)\n");
		#endif

		char parse_parameters_string[] = "llll|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width8, &height8, data8, alpha8, &static_data8 ) == SUCCESS)
		{
			overload8_called = true;
			already_called = true;

			char parse_references_string[] = "zzzz|z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &dummy, &data8_ref, &alpha8_ref, &dummy );
		}
	}

	//Overload 9
	overload9:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|b' (&sz9, php_wxSize_entry, data9, &static_data9)\n");
		#endif

		char parse_parameters_string[] = "Ol|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &sz9, php_wxSize_entry, data9, &static_data9 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(sz9) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(sz9 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(sz9 TSRMLS_CC))->native_object;
					object_pointer9_0 = (wxSize*) argument_native_object;
					if (!object_pointer9_0 )
					{
						goto overload10;
					}
				}
				else if(Z_TYPE_P(sz9) != IS_NULL)
				{
					goto overload10;
				}
			}

			overload9_called = true;
			already_called = true;

			char parse_references_string[] = "zz|z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &data9_ref, &dummy );
		}
	}

	//Overload 10
	overload10:
	if(!already_called && arguments_received >= 3  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll|b' (&width10, &height10, data10, &static_data10)\n");
		#endif

		char parse_parameters_string[] = "lll|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width10, &height10, data10, &static_data10 ) == SUCCESS)
		{
			overload10_called = true;
			already_called = true;

			char parse_references_string[] = "zzz|z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &dummy, &data10_ref, &dummy );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width0, (int) height0)\n");
				#endif

				native_object = new wxImage_php((int) width0, (int) height0);

				native_object->references.Initialize();
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width0, (int) height0, clear0)\n");
				#endif

				native_object = new wxImage_php((int) width0, (int) height0, clear0);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxImage_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxSize*) object_pointer2_0)\n");
				#endif

				native_object = new wxImage_php(*(wxSize*) object_pointer2_0);

				native_object->references.Initialize();
				((wxImage_php*) native_object)->references.AddReference(sz2, "wxImage::wxImage at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxSize*) object_pointer2_0, clear2)\n");
				#endif

				native_object = new wxImage_php(*(wxSize*) object_pointer2_0, clear2);

				native_object->references.Initialize();
				((wxImage_php*) native_object)->references.AddReference(sz2, "wxImage::wxImage at call with 2 argument(s)");
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name3, wxConvUTF8))\n");
				#endif

				native_object = new wxImage_php(wxString(name3, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name3, wxConvUTF8), (wxBitmapType) type3)\n");
				#endif

				native_object = new wxImage_php(wxString(name3, wxConvUTF8), (wxBitmapType) type3);

				native_object->references.Initialize();
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name3, wxConvUTF8), (wxBitmapType) type3, (int) index3)\n");
				#endif

				native_object = new wxImage_php(wxString(name3, wxConvUTF8), (wxBitmapType) type3, (int) index3);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload4_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name4, wxConvUTF8), wxString(mimetype4, wxConvUTF8))\n");
				#endif

				native_object = new wxImage_php(wxString(name4, wxConvUTF8), wxString(mimetype4, wxConvUTF8));

				native_object->references.Initialize();
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(wxString(name4, wxConvUTF8), wxString(mimetype4, wxConvUTF8), (int) index4)\n");
				#endif

				native_object = new wxImage_php(wxString(name4, wxConvUTF8), wxString(mimetype4, wxConvUTF8), (int) index4);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload5_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxInputStream*) object_pointer5_0)\n");
				#endif

				native_object = new wxImage_php(*(wxInputStream*) object_pointer5_0);

				native_object->references.Initialize();
				((wxImage_php*) native_object)->references.AddReference(stream5, "wxImage::wxImage at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxInputStream*) object_pointer5_0, (wxBitmapType) type5)\n");
				#endif

				native_object = new wxImage_php(*(wxInputStream*) object_pointer5_0, (wxBitmapType) type5);

				native_object->references.Initialize();
				((wxImage_php*) native_object)->references.AddReference(stream5, "wxImage::wxImage at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxInputStream*) object_pointer5_0, (wxBitmapType) type5, (int) index5)\n");
				#endif

				native_object = new wxImage_php(*(wxInputStream*) object_pointer5_0, (wxBitmapType) type5, (int) index5);

				native_object->references.Initialize();
				((wxImage_php*) native_object)->references.AddReference(stream5, "wxImage::wxImage at call with 3 argument(s)");
				break;
			}
		}
	}

	if(overload6_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxInputStream*) object_pointer6_0, wxString(mimetype6, wxConvUTF8))\n");
				#endif

				native_object = new wxImage_php(*(wxInputStream*) object_pointer6_0, wxString(mimetype6, wxConvUTF8));

				native_object->references.Initialize();
				((wxImage_php*) native_object)->references.AddReference(stream6, "wxImage::wxImage at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxInputStream*) object_pointer6_0, wxString(mimetype6, wxConvUTF8), (int) index6)\n");
				#endif

				native_object = new wxImage_php(*(wxInputStream*) object_pointer6_0, wxString(mimetype6, wxConvUTF8), (int) index6);

				native_object->references.Initialize();
				((wxImage_php*) native_object)->references.AddReference(stream6, "wxImage::wxImage at call with 3 argument(s)");
				break;
			}
		}
	}

	if(overload7_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxSize*) object_pointer7_0, (unsigned char*) data7, (unsigned char*) alpha7)\n");
				#endif

				native_object = new wxImage_php(*(wxSize*) object_pointer7_0, (unsigned char*) data7, (unsigned char*) alpha7);

				native_object->references.Initialize();
				((wxImage_php*) native_object)->references.AddReference(sz7, "wxImage::wxImage at call with 3 argument(s)");
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxSize*) object_pointer7_0, (unsigned char*) data7, (unsigned char*) alpha7, static_data7)\n");
				#endif

				native_object = new wxImage_php(*(wxSize*) object_pointer7_0, (unsigned char*) data7, (unsigned char*) alpha7, static_data7);

				native_object->references.Initialize();
				((wxImage_php*) native_object)->references.AddReference(sz7, "wxImage::wxImage at call with 4 argument(s)");
				break;
			}
		}
	}

	if(overload8_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width8, (int) height8, (unsigned char*) data8, (unsigned char*) alpha8)\n");
				#endif

				native_object = new wxImage_php((int) width8, (int) height8, (unsigned char*) data8, (unsigned char*) alpha8);

				native_object->references.Initialize();
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width8, (int) height8, (unsigned char*) data8, (unsigned char*) alpha8, static_data8)\n");
				#endif

				native_object = new wxImage_php((int) width8, (int) height8, (unsigned char*) data8, (unsigned char*) alpha8, static_data8);

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload9_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxSize*) object_pointer9_0, (unsigned char*) data9)\n");
				#endif

				native_object = new wxImage_php(*(wxSize*) object_pointer9_0, (unsigned char*) data9);

				native_object->references.Initialize();
				((wxImage_php*) native_object)->references.AddReference(sz9, "wxImage::wxImage at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxSize*) object_pointer9_0, (unsigned char*) data9, static_data9)\n");
				#endif

				native_object = new wxImage_php(*(wxSize*) object_pointer9_0, (unsigned char*) data9, static_data9);

				native_object->references.Initialize();
				((wxImage_php*) native_object)->references.AddReference(sz9, "wxImage::wxImage at call with 3 argument(s)");
				break;
			}
		}
	}

	if(overload10_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width10, (int) height10, (unsigned char*) data10)\n");
				#endif

				native_object = new wxImage_php((int) width10, (int) height10, (unsigned char*) data10);

				native_object->references.Initialize();
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width10, (int) height10, (unsigned char*) data10, static_data10)\n");
				#endif

				native_object = new wxImage_php((int) width10, (int) height10, (unsigned char*) data10, static_data10);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxImage::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto  wxImage::SetType(wxBitmapType type)
   Set the type of image returned by GetType(). */
PHP_METHOD(php_wxImage, SetType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::SetType\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::SetType call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long type0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&type0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &type0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::SetType((wxBitmapType) type0)\n\n");
				#endif

				((wxImage_php*)native_object)->SetType((wxBitmapType) type0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::SetType\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::SetRGB(wxRect rect, int red, int green, int blue)
   Sets the colour of the pixels within the given rectangle. */
PHP_METHOD(php_wxImage, SetRGB)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::SetRGB\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::SetRGB call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* rect0 = 0;
	wxRect* object_pointer0_0 = 0;
	long red0;
	long green0;
	long blue0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Olll' (&rect0, php_wxRect_entry, &red0, &green0, &blue0)\n");
		#endif

		char parse_parameters_string[] = "Olll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect0, php_wxRect_entry, &red0, &green0, &blue0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxRect*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::SetRGB(*(wxRect*) object_pointer0_0, (unsigned char) red0, (unsigned char) green0, (unsigned char) blue0)\n\n");
				#endif

				((wxImage_php*)native_object)->SetRGB(*(wxRect*) object_pointer0_0, (unsigned char) red0, (unsigned char) green0, (unsigned char) blue0);

				references->AddReference(rect0, "wxImage::SetRGB at call with 4 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::SetRGB\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::SetPalette(wxPalette palette)
   Associates a palette with the image. */
PHP_METHOD(php_wxImage, SetPalette)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::SetPalette\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::SetPalette call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* palette0 = 0;
	wxPalette* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&palette0, php_wxPalette_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &palette0, php_wxPalette_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(palette0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPalette*) zend_object_store_get_object(palette0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPalette*) zend_object_store_get_object(palette0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxPalette*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'palette' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(palette0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'palette' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::SetPalette(*(wxPalette*) object_pointer0_0)\n\n");
				#endif

				((wxImage_php*)native_object)->SetPalette(*(wxPalette*) object_pointer0_0);

				references->AddReference(palette0, "wxImage::SetPalette at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::SetPalette\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::SetOption(string name, int value)
   This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. */
PHP_METHOD(php_wxImage, SetOption)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::SetOption\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::SetOption call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	long value0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* name1;
	long name_len1;
	char* value1;
	long value_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl' (&name0, &name_len0, &value0)\n");
		#endif

		char parse_parameters_string[] = "sl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0, &value0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ss' (&name1, &name_len1, &value1, &value_len1)\n");
		#endif

		char parse_parameters_string[] = "ss";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name1, &name_len1, &value1, &value_len1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::SetOption(wxString(name0, wxConvUTF8), (int) value0)\n\n");
				#endif

				((wxImage_php*)native_object)->SetOption(wxString(name0, wxConvUTF8), (int) value0);


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::SetOption(wxString(name1, wxConvUTF8), wxString(value1, wxConvUTF8))\n\n");
				#endif

				((wxImage_php*)native_object)->SetOption(wxString(name1, wxConvUTF8), wxString(value1, wxConvUTF8));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::SetOption\n");
	}
}
/* }}} */

/* {{{ proto bool wxImage::SetMaskFromImage(wxImage mask, int mr, int mg, int mb)
   Sets image's mask so that the pixels that have RGB value of mr,mg,mb in mask will be masked in the image. */
PHP_METHOD(php_wxImage, SetMaskFromImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::SetMaskFromImage\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::SetMaskFromImage call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* mask0 = 0;
	wxImage* object_pointer0_0 = 0;
	long mr0;
	long mg0;
	long mb0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Olll' (&mask0, php_wxImage_entry, &mr0, &mg0, &mb0)\n");
		#endif

		char parse_parameters_string[] = "Olll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &mask0, php_wxImage_entry, &mr0, &mg0, &mb0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(mask0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxImage*) zend_object_store_get_object(mask0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxImage*) zend_object_store_get_object(mask0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxImage*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'mask' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(mask0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'mask' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::SetMaskFromImage(*(wxImage*) object_pointer0_0, (unsigned char) mr0, (unsigned char) mg0, (unsigned char) mb0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->SetMaskFromImage(*(wxImage*) object_pointer0_0, (unsigned char) mr0, (unsigned char) mg0, (unsigned char) mb0));

				references->AddReference(mask0, "wxImage::SetMaskFromImage at call with 4 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::SetMaskFromImage\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::SetMaskColour(int red, int green, int blue)
   Sets the mask colour for this image (and tells the image to use the mask). */
PHP_METHOD(php_wxImage, SetMaskColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::SetMaskColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::SetMaskColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long red0;
	long green0;
	long blue0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&red0, &green0, &blue0)\n");
		#endif

		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &red0, &green0, &blue0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::SetMaskColour((unsigned char) red0, (unsigned char) green0, (unsigned char) blue0)\n\n");
				#endif

				((wxImage_php*)native_object)->SetMaskColour((unsigned char) red0, (unsigned char) green0, (unsigned char) blue0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::SetMaskColour\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::SetMask(bool hasMask)
   Specifies whether there is a mask or not. */
PHP_METHOD(php_wxImage, SetMask)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::SetMask\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::SetMask call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool hasMask0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&hasMask0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &hasMask0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::SetMask()\n\n");
				#endif

				((wxImage_php*)native_object)->SetMask();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::SetMask(hasMask0)\n\n");
				#endif

				((wxImage_php*)native_object)->SetMask(hasMask0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::SetMask\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::SetData(int &data, int new_width, int new_height, bool static_data)
   This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. */
PHP_METHOD(php_wxImage, SetData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::SetData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::SetData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long* data0;
	zval* data0_ref;
	long new_width0;
	long new_height0;
	bool static_data0;
	bool overload0_called = false;
	//Parameters for overload 1
	long* data1;
	zval* data1_ref;
	bool static_data1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll|b' (data0, &new_width0, &new_height0, &static_data0)\n");
		#endif

		char parse_parameters_string[] = "lll|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, data0, &new_width0, &new_height0, &static_data0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zzz|z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &data0_ref, &dummy, &dummy, &dummy );
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l|b' (data1, &static_data1)\n");
		#endif

		char parse_parameters_string[] = "l|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, data1, &static_data1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;

			char parse_references_string[] = "z|z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &data1_ref, &dummy );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::SetData((unsigned char*) data0, (int) new_width0, (int) new_height0)\n\n");
				#endif

				((wxImage_php*)native_object)->SetData((unsigned char*) data0, (int) new_width0, (int) new_height0);

				size_t elements_returned0_0 = sizeof(data0)/sizeof(*data0);
				array_init(data0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(data0_ref, data0[i]);
				}

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::SetData((unsigned char*) data0, (int) new_width0, (int) new_height0, static_data0)\n\n");
				#endif

				((wxImage_php*)native_object)->SetData((unsigned char*) data0, (int) new_width0, (int) new_height0, static_data0);

				size_t elements_returned0_0 = sizeof(data0)/sizeof(*data0);
				array_init(data0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(data0_ref, data0[i]);
				}

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::SetData((unsigned char*) data1)\n\n");
				#endif

				((wxImage_php*)native_object)->SetData((unsigned char*) data1);

				size_t elements_returned1_0 = sizeof(data1)/sizeof(*data1);
				array_init(data1_ref);
				for(size_t i=0; i<elements_returned1_0; i++)
				{
					add_next_index_long(data1_ref, data1[i]);
				}

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::SetData((unsigned char*) data1, static_data1)\n\n");
				#endif

				((wxImage_php*)native_object)->SetData((unsigned char*) data1, static_data1);

				size_t elements_returned1_0 = sizeof(data1)/sizeof(*data1);
				array_init(data1_ref);
				for(size_t i=0; i<elements_returned1_0; i++)
				{
					add_next_index_long(data1_ref, data1[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::SetData\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::SetAlpha(int x, int y, int alpha)
   Sets the alpha value for the given pixel. */
PHP_METHOD(php_wxImage, SetAlpha)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::SetAlpha\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::SetAlpha call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	long alpha0;
	bool overload0_called = false;
	//Parameters for overload 1
	long* alpha1;
	zval* alpha1_ref;
	bool static_data1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&x0, &y0, &alpha0)\n");
		#endif

		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0, &alpha0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 0  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|lb' (alpha1, &static_data1)\n");
		#endif

		char parse_parameters_string[] = "|lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, alpha1, &static_data1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;

			char parse_references_string[] = "|zz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &alpha1_ref, &dummy );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::SetAlpha((int) x0, (int) y0, (unsigned char) alpha0)\n\n");
				#endif

				((wxImage_php*)native_object)->SetAlpha((int) x0, (int) y0, (unsigned char) alpha0);


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::SetAlpha()\n\n");
				#endif

				((wxImage_php*)native_object)->SetAlpha();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::SetAlpha((unsigned char*) alpha1)\n\n");
				#endif

				((wxImage_php*)native_object)->SetAlpha((unsigned char*) alpha1);

				size_t elements_returned1_0 = sizeof(alpha1)/sizeof(*alpha1);
				array_init(alpha1_ref);
				for(size_t i=0; i<elements_returned1_0; i++)
				{
					add_next_index_long(alpha1_ref, alpha1[i]);
				}

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::SetAlpha((unsigned char*) alpha1, static_data1)\n\n");
				#endif

				((wxImage_php*)native_object)->SetAlpha((unsigned char*) alpha1, static_data1);

				size_t elements_returned1_0 = sizeof(alpha1)/sizeof(*alpha1);
				array_init(alpha1_ref);
				for(size_t i=0; i<elements_returned1_0; i++)
				{
					add_next_index_long(alpha1_ref, alpha1[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::SetAlpha\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxImage::Scale(int width, int height, wxImageResizeQuality quality)
   Returns a scaled version of the image. */
PHP_METHOD(php_wxImage, Scale)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::Scale\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::Scale call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	long height0;
	long quality0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll|l' (&width0, &height0, &quality0)\n");
		#endif

		char parse_parameters_string[] = "ll|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0, &height0, &quality0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Scale((int) width0, (int) height0) to return new object\n\n");
				#endif

				wxImage value_to_return2;
				value_to_return2 = ((wxImage_php*)native_object)->Scale((int) width0, (int) height0);
				((wxRefCounter *) value_to_return2.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo2 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo2->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Scale((int) width0, (int) height0, (wxImageResizeQuality) quality0) to return new object\n\n");
				#endif

				wxImage value_to_return3;
				value_to_return3 = ((wxImage_php*)native_object)->Scale((int) width0, (int) height0, (wxImageResizeQuality) quality0);
				((wxRefCounter *) value_to_return3.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo3 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo3->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::Scale\n");
	}
}
/* }}} */

/* {{{ proto bool wxImage::SaveFile(wxOutputStream &stream, wxBitmapType type)
   Saves an image in the given stream. */
PHP_METHOD(php_wxImage, SaveFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::SaveFile\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::SaveFile call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* stream0 = 0;
	wxOutputStream* object_pointer0_0 = 0;
	long type0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* name1;
	long name_len1;
	bool overload1_called = false;
	//Parameters for overload 2
	char* name2;
	long name_len2;
	long type2;
	bool overload2_called = false;
	//Parameters for overload 3
	zval* stream3 = 0;
	wxOutputStream* object_pointer3_0 = 0;
	char* mimetype3;
	long mimetype_len3;
	bool overload3_called = false;
	//Parameters for overload 4
	char* name4;
	long name_len4;
	char* mimetype4;
	long mimetype_len4;
	bool overload4_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ol' (&stream0, &type0)\n");
		#endif

		char parse_parameters_string[] = "ol";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stream0, &type0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stream0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxOutputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxOutputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxOutputStream*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXOUTPUTSTREAM_TYPE && argument_type != PHP_WXFFILEOUTPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEOUTPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(stream0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name1, &name_len1)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name1, &name_len1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl' (&name2, &name_len2, &type2)\n");
		#endif

		char parse_parameters_string[] = "sl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name2, &name_len2, &type2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'os' (&stream3, &mimetype3, &mimetype_len3)\n");
		#endif

		char parse_parameters_string[] = "os";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stream3, &mimetype3, &mimetype_len3 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stream3) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxOutputStream*) zend_object_store_get_object(stream3 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxOutputStream*) zend_object_store_get_object(stream3 TSRMLS_CC))->native_object;
					object_pointer3_0 = (wxOutputStream*) argument_native_object;
					if (!object_pointer3_0 || (argument_type != PHP_WXOUTPUTSTREAM_TYPE && argument_type != PHP_WXFFILEOUTPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEOUTPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
					{
						goto overload4;
					}
				}
				else if(Z_TYPE_P(stream3) != IS_NULL)
				{
					goto overload4;
				}
			}

			overload3_called = true;
			already_called = true;
		}
	}

	//Overload 4
	overload4:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ss' (&name4, &name_len4, &mimetype4, &mimetype_len4)\n");
		#endif

		char parse_parameters_string[] = "ss";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name4, &name_len4, &mimetype4, &mimetype_len4 ) == SUCCESS)
		{
			overload4_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::SaveFile(*(wxOutputStream*) object_pointer0_0, (wxBitmapType) type0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->SaveFile(*(wxOutputStream*) object_pointer0_0, (wxBitmapType) type0));

				references->AddReference(stream0, "wxImage::SaveFile at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::SaveFile(wxString(name1, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->SaveFile(wxString(name1, wxConvUTF8)));


				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::SaveFile(wxString(name2, wxConvUTF8), (wxBitmapType) type2))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->SaveFile(wxString(name2, wxConvUTF8), (wxBitmapType) type2));


				return;
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::SaveFile(*(wxOutputStream*) object_pointer3_0, wxString(mimetype3, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->SaveFile(*(wxOutputStream*) object_pointer3_0, wxString(mimetype3, wxConvUTF8)));

				references->AddReference(stream3, "wxImage::SaveFile at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload4_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::SaveFile(wxString(name4, wxConvUTF8), wxString(mimetype4, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->SaveFile(wxString(name4, wxConvUTF8), wxString(mimetype4, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::SaveFile\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::RotateHue(float angle)
   Rotates the hue of each pixel in the image by angle, which is a double in the range of -1.0 to +1.0, where -1.0 corresponds to -360 degrees and +1.0 corresponds to +360 degrees. */
PHP_METHOD(php_wxImage, RotateHue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::RotateHue\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::RotateHue call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	double angle0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'd' (&angle0)\n");
		#endif

		char parse_parameters_string[] = "d";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &angle0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::RotateHue(angle0)\n\n");
				#endif

				((wxImage_php*)native_object)->RotateHue(angle0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::RotateHue\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxImage::Rotate90(bool clockwise)
   Returns a copy of the image rotated 90 degrees in the direction indicated by clockwise. */
PHP_METHOD(php_wxImage, Rotate90)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::Rotate90\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::Rotate90 call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool clockwise0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&clockwise0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &clockwise0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Rotate90() to return new object\n\n");
				#endif

				wxImage value_to_return0;
				value_to_return0 = ((wxImage_php*)native_object)->Rotate90();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo0 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Rotate90(clockwise0) to return new object\n\n");
				#endif

				wxImage value_to_return1;
				value_to_return1 = ((wxImage_php*)native_object)->Rotate90(clockwise0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo1 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::Rotate90\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxImage::Rotate180()
   Returns a copy of the image rotated by 180 degrees. */
PHP_METHOD(php_wxImage, Rotate180)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::Rotate180\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::Rotate180 call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Rotate180() to return new object\n\n");
				#endif

				wxImage value_to_return0;
				value_to_return0 = ((wxImage_php*)native_object)->Rotate180();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo0 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::Rotate180\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxImage::Rotate(float angle, wxPoint rotationCentre, bool interpolating, wxPoint &offsetAfterRotation)
   Rotates the image about the given point, by angle radians. */
PHP_METHOD(php_wxImage, Rotate)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::Rotate\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::Rotate call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	double angle0;
	zval* rotationCentre0 = 0;
	wxPoint* object_pointer0_1 = 0;
	bool interpolating0;
	zval* offsetAfterRotation0 = 0;
	wxPoint* object_pointer0_3 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'dO|bz' (&angle0, &rotationCentre0, php_wxPoint_entry, &interpolating0, &offsetAfterRotation0)\n");
		#endif

		char parse_parameters_string[] = "dO|bz";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &angle0, &rotationCentre0, php_wxPoint_entry, &interpolating0, &offsetAfterRotation0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(rotationCentre0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(rotationCentre0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(rotationCentre0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxPoint*) argument_native_object;
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter 'rotationCentre' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rotationCentre0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rotationCentre' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 4){
				if(Z_TYPE_P(offsetAfterRotation0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(offsetAfterRotation0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(offsetAfterRotation0 TSRMLS_CC))->native_object;
					object_pointer0_3 = (wxPoint*) argument_native_object;
					if (!object_pointer0_3 || (argument_type != PHP_WXPOINT_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'offsetAfterRotation' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(offsetAfterRotation0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'offsetAfterRotation' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Rotate(angle0, *(wxPoint*) object_pointer0_1) to return new object\n\n");
				#endif

				wxImage value_to_return2;
				value_to_return2 = ((wxImage_php*)native_object)->Rotate(angle0, *(wxPoint*) object_pointer0_1);
				((wxRefCounter *) value_to_return2.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo2 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo2->native_object = (wxImage_php*) ptr;

				references->AddReference(rotationCentre0, "wxImage::Rotate at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Rotate(angle0, *(wxPoint*) object_pointer0_1, interpolating0) to return new object\n\n");
				#endif

				wxImage value_to_return3;
				value_to_return3 = ((wxImage_php*)native_object)->Rotate(angle0, *(wxPoint*) object_pointer0_1, interpolating0);
				((wxRefCounter *) value_to_return3.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo3 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo3->native_object = (wxImage_php*) ptr;

				references->AddReference(rotationCentre0, "wxImage::Rotate at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Rotate(angle0, *(wxPoint*) object_pointer0_1, interpolating0, (wxPoint*) object_pointer0_3) to return new object\n\n");
				#endif

				wxImage value_to_return4;
				value_to_return4 = ((wxImage_php*)native_object)->Rotate(angle0, *(wxPoint*) object_pointer0_1, interpolating0, (wxPoint*) object_pointer0_3);
				((wxRefCounter *) value_to_return4.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo4 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo4->native_object = (wxImage_php*) ptr;

				references->AddReference(rotationCentre0, "wxImage::Rotate at call with 4 argument(s)");
				references->AddReference(offsetAfterRotation0, "wxImage::Rotate at call with 4 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::Rotate\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxImage::Resize(wxSize size, wxPoint pos, int red, int green, int blue)
   Changes the size of the image in-place without scaling it by adding either a border with the given colour or cropping as necessary. */
PHP_METHOD(php_wxImage, Resize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::Resize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::Resize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* size0 = 0;
	wxSize* object_pointer0_0 = 0;
	zval* pos0 = 0;
	wxPoint* object_pointer0_1 = 0;
	long red0;
	long green0;
	long blue0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO|lll' (&size0, php_wxSize_entry, &pos0, php_wxPoint_entry, &red0, &green0, &blue0)\n");
		#endif

		char parse_parameters_string[] = "OO|lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size0, php_wxSize_entry, &pos0, php_wxPoint_entry, &red0, &green0, &blue0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxSize*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(pos0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pos0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pos0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxPoint*) argument_native_object;
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter 'pos' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pos' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Resize(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1) to return object reference\n\n");
				#endif

				wxImage_php* value_to_return2;
				value_to_return2 = (wxImage_php*) &((wxImage_php*)native_object)->Resize(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxImage_entry);
					((zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxImage_php*) value_to_return2;
				}

				if((void*)value_to_return2 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxImage::Resize at call with 2 argument(s)");
				}

				references->AddReference(size0, "wxImage::Resize at call with 2 argument(s)");
				references->AddReference(pos0, "wxImage::Resize at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Resize(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0) to return object reference\n\n");
				#endif

				wxImage_php* value_to_return3;
				value_to_return3 = (wxImage_php*) &((wxImage_php*)native_object)->Resize(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0);

				if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxImage_entry);
					((zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxImage_php*) value_to_return3;
				}

				if((void*)value_to_return3 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxImage::Resize at call with 3 argument(s)");
				}

				references->AddReference(size0, "wxImage::Resize at call with 3 argument(s)");
				references->AddReference(pos0, "wxImage::Resize at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Resize(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0, (int) green0) to return object reference\n\n");
				#endif

				wxImage_php* value_to_return4;
				value_to_return4 = (wxImage_php*) &((wxImage_php*)native_object)->Resize(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0, (int) green0);

				if(value_to_return4->references.IsUserInitialized()){
					if(value_to_return4->phpObj != NULL){
						*return_value = *value_to_return4->phpObj;
						zval_add_ref(&value_to_return4->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxImage_entry);
					((zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxImage_php*) value_to_return4;
				}

				if((void*)value_to_return4 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxImage::Resize at call with 4 argument(s)");
				}

				references->AddReference(size0, "wxImage::Resize at call with 4 argument(s)");
				references->AddReference(pos0, "wxImage::Resize at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Resize(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0, (int) green0, (int) blue0) to return object reference\n\n");
				#endif

				wxImage_php* value_to_return5;
				value_to_return5 = (wxImage_php*) &((wxImage_php*)native_object)->Resize(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0, (int) green0, (int) blue0);

				if(value_to_return5->references.IsUserInitialized()){
					if(value_to_return5->phpObj != NULL){
						*return_value = *value_to_return5->phpObj;
						zval_add_ref(&value_to_return5->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxImage_entry);
					((zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxImage_php*) value_to_return5;
				}

				if((void*)value_to_return5 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxImage::Resize at call with 5 argument(s)");
				}

				references->AddReference(size0, "wxImage::Resize at call with 5 argument(s)");
				references->AddReference(pos0, "wxImage::Resize at call with 5 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::Resize\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxImage::Rescale(int width, int height, wxImageResizeQuality quality)
   Changes the size of the image in-place by scaling it: after a call to this function,the image will have the given width and height. */
PHP_METHOD(php_wxImage, Rescale)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::Rescale\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::Rescale call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	long height0;
	long quality0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll|l' (&width0, &height0, &quality0)\n");
		#endif

		char parse_parameters_string[] = "ll|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0, &height0, &quality0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Rescale((int) width0, (int) height0) to return object reference\n\n");
				#endif

				wxImage_php* value_to_return2;
				value_to_return2 = (wxImage_php*) &((wxImage_php*)native_object)->Rescale((int) width0, (int) height0);

				if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxImage_entry);
					((zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxImage_php*) value_to_return2;
				}

				if((void*)value_to_return2 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxImage::Rescale at call with 2 argument(s)");
				}


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Rescale((int) width0, (int) height0, (wxImageResizeQuality) quality0) to return object reference\n\n");
				#endif

				wxImage_php* value_to_return3;
				value_to_return3 = (wxImage_php*) &((wxImage_php*)native_object)->Rescale((int) width0, (int) height0, (wxImageResizeQuality) quality0);

				if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxImage_entry);
					((zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxImage_php*) value_to_return3;
				}

				if((void*)value_to_return3 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxImage::Rescale at call with 3 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::Rescale\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::Replace(int r1, int g1, int b1, int r2, int g2, int b2)
   Replaces the colour specified by r1,g1,b1 by the colour r2,g2,b2. */
PHP_METHOD(php_wxImage, Replace)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::Replace\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::Replace call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long r10;
	long g10;
	long b10;
	long r20;
	long g20;
	long b20;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llllll' (&r10, &g10, &b10, &r20, &g20, &b20)\n");
		#endif

		char parse_parameters_string[] = "llllll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &r10, &g10, &b10, &r20, &g20, &b20 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Replace((unsigned char) r10, (unsigned char) g10, (unsigned char) b10, (unsigned char) r20, (unsigned char) g20, (unsigned char) b20)\n\n");
				#endif

				((wxImage_php*)native_object)->Replace((unsigned char) r10, (unsigned char) g10, (unsigned char) b10, (unsigned char) r20, (unsigned char) g20, (unsigned char) b20);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::Replace\n");
	}
}
/* }}} */

/* {{{ proto bool wxImage::RemoveHandler(string name)
   Finds the handler with the given name, and removes it. */
PHP_METHOD(php_wxImage, RemoveHandler)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::RemoveHandler\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::RemoveHandler call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_BOOL(wxImage::RemoveHandler(wxString(name0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, wxImage::RemoveHandler(wxString(name0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::RemoveHandler\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::Paste(wxImage image, int x, int y)
   Copy the data of the given image to the specified position in this image. */
PHP_METHOD(php_wxImage, Paste)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::Paste\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::Paste call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* image0 = 0;
	wxImage* object_pointer0_0 = 0;
	long x0;
	long y0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Oll' (&image0, php_wxImage_entry, &x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "Oll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &image0, php_wxImage_entry, &x0, &y0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(image0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxImage*) zend_object_store_get_object(image0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxImage*) zend_object_store_get_object(image0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxImage*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'image' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(image0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'image' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Paste(*(wxImage*) object_pointer0_0, (int) x0, (int) y0)\n\n");
				#endif

				((wxImage_php*)native_object)->Paste(*(wxImage*) object_pointer0_0, (int) x0, (int) y0);

				references->AddReference(image0, "wxImage::Paste at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::Paste\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxImage::Mirror(bool horizontally)
   Returns a mirrored copy of the image. */
PHP_METHOD(php_wxImage, Mirror)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::Mirror\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::Mirror call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool horizontally0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|b' (&horizontally0)\n");
		#endif

		char parse_parameters_string[] = "|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &horizontally0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Mirror() to return new object\n\n");
				#endif

				wxImage value_to_return0;
				value_to_return0 = ((wxImage_php*)native_object)->Mirror();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo0 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Mirror(horizontally0) to return new object\n\n");
				#endif

				wxImage value_to_return1;
				value_to_return1 = ((wxImage_php*)native_object)->Mirror(horizontally0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo1 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::Mirror\n");
	}
}
/* }}} */

/* {{{ proto bool wxImage::LoadFile(wxInputStream &stream, string mimetype, int index)
   Loads an image from an input stream. */
PHP_METHOD(php_wxImage, LoadFile)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::LoadFile\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::LoadFile call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* stream0 = 0;
	wxInputStream* object_pointer0_0 = 0;
	char* mimetype0;
	long mimetype_len0;
	long index0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* name1;
	long name_len1;
	char* mimetype1;
	long mimetype_len1;
	long index1;
	bool overload1_called = false;
	//Parameters for overload 2
	char* name2;
	long name_len2;
	long type2;
	long index2;
	bool overload2_called = false;
	//Parameters for overload 3
	zval* stream3 = 0;
	wxInputStream* object_pointer3_0 = 0;
	long type3;
	long index3;
	bool overload3_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'os|l' (&stream0, &mimetype0, &mimetype_len0, &index0)\n");
		#endif

		char parse_parameters_string[] = "os|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stream0, &mimetype0, &mimetype_len0, &index0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stream0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxInputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxInputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxInputStream*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(stream0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ss|l' (&name1, &name_len1, &mimetype1, &mimetype_len1, &index1)\n");
		#endif

		char parse_parameters_string[] = "ss|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name1, &name_len1, &mimetype1, &mimetype_len1, &index1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received >= 1  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|ll' (&name2, &name_len2, &type2, &index2)\n");
		#endif

		char parse_parameters_string[] = "s|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name2, &name_len2, &type2, &index2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received >= 1  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'o|ll' (&stream3, &type3, &index3)\n");
		#endif

		char parse_parameters_string[] = "o|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stream3, &type3, &index3 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stream3) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxInputStream*) zend_object_store_get_object(stream3 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxInputStream*) zend_object_store_get_object(stream3 TSRMLS_CC))->native_object;
					object_pointer3_0 = (wxInputStream*) argument_native_object;
					if (!object_pointer3_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'stream' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(stream3) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'stream' not null, could not be retreived correctly.");
				}
			}

			overload3_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::LoadFile(*(wxInputStream*) object_pointer0_0, wxString(mimetype0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->LoadFile(*(wxInputStream*) object_pointer0_0, wxString(mimetype0, wxConvUTF8)));

				references->AddReference(stream0, "wxImage::LoadFile at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::LoadFile(*(wxInputStream*) object_pointer0_0, wxString(mimetype0, wxConvUTF8), (int) index0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->LoadFile(*(wxInputStream*) object_pointer0_0, wxString(mimetype0, wxConvUTF8), (int) index0));

				references->AddReference(stream0, "wxImage::LoadFile at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::LoadFile(wxString(name1, wxConvUTF8), wxString(mimetype1, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->LoadFile(wxString(name1, wxConvUTF8), wxString(mimetype1, wxConvUTF8)));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::LoadFile(wxString(name1, wxConvUTF8), wxString(mimetype1, wxConvUTF8), (int) index1))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->LoadFile(wxString(name1, wxConvUTF8), wxString(mimetype1, wxConvUTF8), (int) index1));


				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::LoadFile(wxString(name2, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->LoadFile(wxString(name2, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::LoadFile(wxString(name2, wxConvUTF8), (wxBitmapType) type2))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->LoadFile(wxString(name2, wxConvUTF8), (wxBitmapType) type2));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::LoadFile(wxString(name2, wxConvUTF8), (wxBitmapType) type2, (int) index2))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->LoadFile(wxString(name2, wxConvUTF8), (wxBitmapType) type2, (int) index2));


				return;
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::LoadFile(*(wxInputStream*) object_pointer3_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->LoadFile(*(wxInputStream*) object_pointer3_0));

				references->AddReference(stream3, "wxImage::LoadFile at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::LoadFile(*(wxInputStream*) object_pointer3_0, (wxBitmapType) type3))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->LoadFile(*(wxInputStream*) object_pointer3_0, (wxBitmapType) type3));

				references->AddReference(stream3, "wxImage::LoadFile at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::LoadFile(*(wxInputStream*) object_pointer3_0, (wxBitmapType) type3, (int) index3))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->LoadFile(*(wxInputStream*) object_pointer3_0, (wxBitmapType) type3, (int) index3));

				references->AddReference(stream3, "wxImage::LoadFile at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::LoadFile\n");
	}
}
/* }}} */

/* {{{ proto bool wxImage::IsTransparent(int x, int y, int threshold)
   Returns true if the given pixel is transparent, i.e. either has the mask colour if this image has a mask or if this image has alpha channel and alpha value of this pixel is strictly less than threshold. */
PHP_METHOD(php_wxImage, IsTransparent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::IsTransparent\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::IsTransparent call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	long threshold0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll|l' (&x0, &y0, &threshold0)\n");
		#endif

		char parse_parameters_string[] = "ll|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0, &threshold0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::IsTransparent((int) x0, (int) y0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->IsTransparent((int) x0, (int) y0));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::IsTransparent((int) x0, (int) y0, (unsigned char) threshold0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->IsTransparent((int) x0, (int) y0, (unsigned char) threshold0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::IsTransparent\n");
	}
}
/* }}} */

/* {{{ proto bool wxImage::IsOk()
   Returns true if image data is present. */
PHP_METHOD(php_wxImage, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::IsOk call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::IsOk())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->IsOk());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::IsOk\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::InsertHandler(wxImageHandler &handler)
   Adds a handler at the start of the static list of format handlers. */
PHP_METHOD(php_wxImage, InsertHandler)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::InsertHandler\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::InsertHandler call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* handler0 = 0;
	wxImageHandler* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&handler0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &handler0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(handler0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxImageHandler*) zend_object_store_get_object(handler0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxImageHandler*) zend_object_store_get_object(handler0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxImageHandler*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXIMAGEHANDLER_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'handler' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(handler0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'handler' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxImage::InsertHandler((wxImageHandler*) object_pointer0_0)\n\n");
				#endif

				wxImage::InsertHandler((wxImageHandler*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::InsertHandler\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::InitStandardHandlers()
   Internal use only. */
PHP_METHOD(php_wxImage, InitStandardHandlers)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::InitStandardHandlers\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::InitStandardHandlers call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxImage::InitStandardHandlers()\n\n");
				#endif

				wxImage::InitStandardHandlers();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::InitStandardHandlers\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::InitAlpha()
   Initializes the image alpha channel data. */
PHP_METHOD(php_wxImage, InitAlpha)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::InitAlpha\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::InitAlpha call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::InitAlpha()\n\n");
				#endif

				((wxImage_php*)native_object)->InitAlpha();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::InitAlpha\n");
	}
}
/* }}} */

/* {{{ proto bool wxImage::HasOption(string name)
   Returns true if the given option is present. */
PHP_METHOD(php_wxImage, HasOption)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::HasOption\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::HasOption call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::HasOption(wxString(name0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->HasOption(wxString(name0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::HasOption\n");
	}
}
/* }}} */

/* {{{ proto bool wxImage::HasMask()
   Returns true if there is a mask active, false otherwise. */
PHP_METHOD(php_wxImage, HasMask)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::HasMask\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::HasMask call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::HasMask())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->HasMask());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::HasMask\n");
	}
}
/* }}} */

/* {{{ proto bool wxImage::HasAlpha()
   Returns true if this image has alpha channel, false otherwise. */
PHP_METHOD(php_wxImage, HasAlpha)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::HasAlpha\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::HasAlpha call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::HasAlpha())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->HasAlpha());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::HasAlpha\n");
	}
}
/* }}} */

/* {{{ proto int wxImage::GetWidth()
   Gets the width of the image in pixels. */
PHP_METHOD(php_wxImage, GetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImage::GetWidth())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxImage_php*)native_object)->GetWidth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetWidth\n");
	}
}
/* }}} */

/* {{{ proto wxBitmapType wxImage::GetType()
   Gets the type of image found by LoadFile() or specified with SaveFile(). */
PHP_METHOD(php_wxImage, GetType)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetType\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetType call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImage::GetType())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxImage_php*)native_object)->GetType());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetType\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxImage::GetSubImage(wxRect rect)
   Returns a sub image of the current one as long as the rect belongs entirely to the image. */
PHP_METHOD(php_wxImage, GetSubImage)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetSubImage\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetSubImage call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* rect0 = 0;
	wxRect* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&rect0, php_wxRect_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &rect0, php_wxRect_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(rect0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRect*) zend_object_store_get_object(rect0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxRect*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'rect' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(rect0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'rect' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::GetSubImage(*(wxRect*) object_pointer0_0) to return new object\n\n");
				#endif

				wxImage value_to_return1;
				value_to_return1 = ((wxImage_php*)native_object)->GetSubImage(*(wxRect*) object_pointer0_0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo1 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxImage_php*) ptr;

				references->AddReference(rect0, "wxImage::GetSubImage at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetSubImage\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxImage::GetSize()
   Returns the size of the image in pixels. */
PHP_METHOD(php_wxImage, GetSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::GetSize() to return new object\n\n");
				#endif

				wxSize value_to_return0;
				value_to_return0 = ((wxImage_php*)native_object)->GetSize();
				void* ptr = safe_emalloc(1, sizeof(wxSize_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxSize));
				object_init_ex(return_value, php_wxSize_entry);
				((wxSize_php*)ptr)->phpObj = return_value;
				zo_wxSize* zo0 = (zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxSize_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetSize\n");
	}
}
/* }}} */

/* {{{ proto int wxImage::GetRed(int x, int y)
   Returns the red intensity at the given coordinate. */
PHP_METHOD(php_wxImage, GetRed)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetRed\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetRed call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImage::GetRed((int) x0, (int) y0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxImage_php*)native_object)->GetRed((int) x0, (int) y0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetRed\n");
	}
}
/* }}} */

/* {{{ proto wxPalette wxImage::GetPalette()
   Returns the palette associated with the image. */
PHP_METHOD(php_wxImage, GetPalette)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetPalette\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetPalette call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::GetPalette() to return object reference\n\n");
				#endif

				wxPalette_php* value_to_return0;
				value_to_return0 = (wxPalette_php*) &((wxImage_php*)native_object)->GetPalette();

				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxPalette_entry);
					((zo_wxPalette*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPalette_php*) value_to_return0;
				}

				if((void*)value_to_return0 != (void*)native_object && return_is_user_initialized){ //Prevent adding references to it self
					references->AddReference(return_value, "wxImage::GetPalette at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetPalette\n");
	}
}
/* }}} */

/* {{{ proto bool wxImage::GetOrFindMaskColour(int &r, int &g, int &b)
   Get the current mask colour or find a suitable unused colour that could be used as a mask colour. */
PHP_METHOD(php_wxImage, GetOrFindMaskColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetOrFindMaskColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetOrFindMaskColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long* r0;
	zval* r0_ref;
	long* g0;
	zval* g0_ref;
	long* b0;
	zval* b0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (r0, g0, b0)\n");
		#endif

		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, r0, g0, b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zzz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &r0_ref, &g0_ref, &b0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::GetOrFindMaskColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->GetOrFindMaskColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0));

				size_t elements_returned0_0 = sizeof(r0)/sizeof(*r0);
				array_init(r0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(r0_ref, r0[i]);
				}
				size_t elements_returned0_1 = sizeof(g0)/sizeof(*g0);
				array_init(g0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(g0_ref, g0[i]);
				}
				size_t elements_returned0_2 = sizeof(b0)/sizeof(*b0);
				array_init(b0_ref);
				for(size_t i=0; i<elements_returned0_2; i++)
				{
					add_next_index_long(b0_ref, b0[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetOrFindMaskColour\n");
	}
}
/* }}} */

/* {{{ proto int wxImage::GetOptionInt(string name)
   Gets a user-defined integer-valued option. */
PHP_METHOD(php_wxImage, GetOptionInt)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetOptionInt\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetOptionInt call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImage::GetOptionInt(wxString(name0, wxConvUTF8)))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxImage_php*)native_object)->GetOptionInt(wxString(name0, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetOptionInt\n");
	}
}
/* }}} */

/* {{{ proto string wxImage::GetOption(string name)
   Gets a user-defined string-valued option. */
PHP_METHOD(php_wxImage, GetOption)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetOption\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetOption call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_STRING(wxImage::GetOption(wxString(name0, wxConvUTF8)).fn_str(), 1)\n\n");
				#endif

				wxString value_to_return1;
				value_to_return1 = ((wxImage_php*)native_object)->GetOption(wxString(name0, wxConvUTF8));
				char* temp_string1;
				temp_string1 = (char*)malloc(sizeof(wxChar)*(value_to_return1.size()+1));
				strcpy (temp_string1, (const char *) value_to_return1.char_str() );
				ZVAL_STRING(return_value, temp_string1, 1);
				free(temp_string1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetOption\n");
	}
}
/* }}} */

/* {{{ proto int wxImage::GetMaskRed()
   Gets the red value of the mask colour. */
PHP_METHOD(php_wxImage, GetMaskRed)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetMaskRed\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetMaskRed call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImage::GetMaskRed())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxImage_php*)native_object)->GetMaskRed());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetMaskRed\n");
	}
}
/* }}} */

/* {{{ proto int wxImage::GetMaskGreen()
   Gets the green value of the mask colour. */
PHP_METHOD(php_wxImage, GetMaskGreen)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetMaskGreen\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetMaskGreen call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImage::GetMaskGreen())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxImage_php*)native_object)->GetMaskGreen());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetMaskGreen\n");
	}
}
/* }}} */

/* {{{ proto int wxImage::GetMaskBlue()
   Gets the blue value of the mask colour. */
PHP_METHOD(php_wxImage, GetMaskBlue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetMaskBlue\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetMaskBlue call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImage::GetMaskBlue())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxImage_php*)native_object)->GetMaskBlue());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetMaskBlue\n");
	}
}
/* }}} */

/* {{{ proto string wxImage::GetImageExtWildcard()
   Iterates all registered wxImageHandler objects, and returns a string containing file extension masks suitable for passing to file open/save dialog boxes. */
PHP_METHOD(php_wxImage, GetImageExtWildcard)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetImageExtWildcard\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetImageExtWildcard call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_STRING(wxImage::GetImageExtWildcard().fn_str(), 1)\n\n");
				#endif

				wxString value_to_return0;
				value_to_return0 = wxImage::GetImageExtWildcard();
				char* temp_string0;
				temp_string0 = (char*)malloc(sizeof(wxChar)*(value_to_return0.size()+1));
				strcpy (temp_string0, (const char *) value_to_return0.char_str() );
				ZVAL_STRING(return_value, temp_string0, 1);
				free(temp_string0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetImageExtWildcard\n");
	}
}
/* }}} */

/* {{{ proto int wxImage::GetImageCount(wxInputStream &stream, wxBitmapType type)
   If the image file contains more than one image and the image handler is capable of retrieving these individually, this function will return the number of available images. */
PHP_METHOD(php_wxImage, GetImageCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetImageCount\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetImageCount call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* stream0 = 0;
	wxInputStream* object_pointer0_0 = 0;
	long type0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* filename1;
	long filename_len1;
	long type1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'o|l' (&stream0, &type0)\n");
		#endif

		char parse_parameters_string[] = "o|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stream0, &type0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stream0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxInputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxInputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxInputStream*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(stream0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's|l' (&filename1, &filename_len1, &type1)\n");
		#endif

		char parse_parameters_string[] = "s|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filename1, &filename_len1, &type1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_LONG(wxImage::GetImageCount(*(wxInputStream*) object_pointer0_0))\n\n");
				#endif

				ZVAL_LONG(return_value, wxImage::GetImageCount(*(wxInputStream*) object_pointer0_0));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_LONG(wxImage::GetImageCount(*(wxInputStream*) object_pointer0_0, (wxBitmapType) type0))\n\n");
				#endif

				ZVAL_LONG(return_value, wxImage::GetImageCount(*(wxInputStream*) object_pointer0_0, (wxBitmapType) type0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_LONG(wxImage::GetImageCount(wxString(filename1, wxConvUTF8)))\n\n");
				#endif

				ZVAL_LONG(return_value, wxImage::GetImageCount(wxString(filename1, wxConvUTF8)));


				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_LONG(wxImage::GetImageCount(wxString(filename1, wxConvUTF8), (wxBitmapType) type1))\n\n");
				#endif

				ZVAL_LONG(return_value, wxImage::GetImageCount(wxString(filename1, wxConvUTF8), (wxBitmapType) type1));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetImageCount\n");
	}
}
/* }}} */

/* {{{ proto int wxImage::GetHeight()
   Gets the height of the image in pixels. */
PHP_METHOD(php_wxImage, GetHeight)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetHeight\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetHeight call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImage::GetHeight())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxImage_php*)native_object)->GetHeight());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetHeight\n");
	}
}
/* }}} */

/* {{{ proto int wxImage::GetGreen(int x, int y)
   Returns the green intensity at the given coordinate. */
PHP_METHOD(php_wxImage, GetGreen)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetGreen\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetGreen call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImage::GetGreen((int) x0, (int) y0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxImage_php*)native_object)->GetGreen((int) x0, (int) y0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetGreen\n");
	}
}
/* }}} */

/* {{{ proto int wxImage::GetData()
   Returns the image data as an array. */
PHP_METHOD(php_wxImage, GetData)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetData\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetData call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImage::GetData())\n\n");
				#endif

				ZVAL_LONG(return_value, *(((wxImage_php*)native_object)->GetData()));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetData\n");
	}
}
/* }}} */

/* {{{ proto int wxImage::GetBlue(int x, int y)
   Returns the blue intensity at the given coordinate. */
PHP_METHOD(php_wxImage, GetBlue)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetBlue\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetBlue call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImage::GetBlue((int) x0, (int) y0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxImage_php*)native_object)->GetBlue((int) x0, (int) y0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetBlue\n");
	}
}
/* }}} */

/* {{{ proto int wxImage::GetAlpha(int x, int y)
   Return alpha value at given pixel location. */
PHP_METHOD(php_wxImage, GetAlpha)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::GetAlpha\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::GetAlpha call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long x0;
	long y0;
	bool overload0_called = false;
	//Parameters for overload 1
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll' (&x0, &y0)\n");
		#endif

		char parse_parameters_string[] = "ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &x0, &y0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload1_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImage::GetAlpha((int) x0, (int) y0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxImage_php*)native_object)->GetAlpha((int) x0, (int) y0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImage::GetAlpha())\n\n");
				#endif

				ZVAL_LONG(return_value, *(((wxImage_php*)native_object)->GetAlpha()));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::GetAlpha\n");
	}
}
/* }}} */

/* {{{ proto wxImageHandler wxImage::FindHandlerMime(string mimetype)
   Finds the handler associated with the given MIME type. */
PHP_METHOD(php_wxImage, FindHandlerMime)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::FindHandlerMime\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::FindHandlerMime call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* mimetype0;
	long mimetype_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&mimetype0, &mimetype_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &mimetype0, &mimetype_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxImage::FindHandlerMime(wxString(mimetype0, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxImageHandler_php* value_to_return1;
				value_to_return1 = (wxImageHandler_php*) wxImage::FindHandlerMime(wxString(mimetype0, wxConvUTF8));
				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxImageHandler_entry);
					((zo_wxImageHandler*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxImageHandler_php*) value_to_return1;
				}



				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::FindHandlerMime\n");
	}
}
/* }}} */

/* {{{ proto wxImageHandler wxImage::FindHandler(wxBitmapType imageType)
   Finds the handler associated with the given image type. */
PHP_METHOD(php_wxImage, FindHandler)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::FindHandler\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::FindHandler call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long imageType0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* extension1;
	long extension_len1;
	long imageType1;
	bool overload1_called = false;
	//Parameters for overload 2
	char* name2;
	long name_len2;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&imageType0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &imageType0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'sl' (&extension1, &extension_len1, &imageType1)\n");
		#endif

		char parse_parameters_string[] = "sl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &extension1, &extension_len1, &imageType1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name2, &name_len2)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name2, &name_len2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxImage::FindHandler((wxBitmapType) imageType0) to return object pointer\n\n");
				#endif

				wxImageHandler_php* value_to_return1;
				value_to_return1 = (wxImageHandler_php*) wxImage::FindHandler((wxBitmapType) imageType0);
				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxImageHandler_entry);
					((zo_wxImageHandler*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxImageHandler_php*) value_to_return1;
				}



				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxImage::FindHandler(wxString(extension1, wxConvUTF8), (wxBitmapType) imageType1) to return object pointer\n\n");
				#endif

				wxImageHandler_php* value_to_return2;
				value_to_return2 = (wxImageHandler_php*) wxImage::FindHandler(wxString(extension1, wxConvUTF8), (wxBitmapType) imageType1);
				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxImageHandler_entry);
					((zo_wxImageHandler*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxImageHandler_php*) value_to_return2;
				}



				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxImage::FindHandler(wxString(name2, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxImageHandler_php* value_to_return1;
				value_to_return1 = (wxImageHandler_php*) wxImage::FindHandler(wxString(name2, wxConvUTF8));
				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxImageHandler_entry);
					((zo_wxImageHandler*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxImageHandler_php*) value_to_return1;
				}



				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::FindHandler\n");
	}
}
/* }}} */

/* {{{ proto bool wxImage::FindFirstUnusedColour(int &r, int &g, int &b, int startR, int startG, int startB)
   Finds the first colour that is never used in the image. */
PHP_METHOD(php_wxImage, FindFirstUnusedColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::FindFirstUnusedColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::FindFirstUnusedColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long* r0;
	zval* r0_ref;
	long* g0;
	zval* g0_ref;
	long* b0;
	zval* b0_ref;
	long startR0;
	long startG0;
	long startB0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll|lll' (r0, g0, b0, &startR0, &startG0, &startB0)\n");
		#endif

		char parse_parameters_string[] = "lll|lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, r0, g0, b0, &startR0, &startG0, &startB0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zzz|zzz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &r0_ref, &g0_ref, &b0_ref, &dummy, &dummy, &dummy );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::FindFirstUnusedColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->FindFirstUnusedColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0));

				size_t elements_returned0_0 = sizeof(r0)/sizeof(*r0);
				array_init(r0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(r0_ref, r0[i]);
				}
				size_t elements_returned0_1 = sizeof(g0)/sizeof(*g0);
				array_init(g0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(g0_ref, g0[i]);
				}
				size_t elements_returned0_2 = sizeof(b0)/sizeof(*b0);
				array_init(b0_ref);
				for(size_t i=0; i<elements_returned0_2; i++)
				{
					add_next_index_long(b0_ref, b0[i]);
				}

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::FindFirstUnusedColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0, (unsigned char) startR0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->FindFirstUnusedColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0, (unsigned char) startR0));

				size_t elements_returned0_0 = sizeof(r0)/sizeof(*r0);
				array_init(r0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(r0_ref, r0[i]);
				}
				size_t elements_returned0_1 = sizeof(g0)/sizeof(*g0);
				array_init(g0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(g0_ref, g0[i]);
				}
				size_t elements_returned0_2 = sizeof(b0)/sizeof(*b0);
				array_init(b0_ref);
				for(size_t i=0; i<elements_returned0_2; i++)
				{
					add_next_index_long(b0_ref, b0[i]);
				}

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::FindFirstUnusedColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0, (unsigned char) startR0, (unsigned char) startG0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->FindFirstUnusedColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0, (unsigned char) startR0, (unsigned char) startG0));

				size_t elements_returned0_0 = sizeof(r0)/sizeof(*r0);
				array_init(r0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(r0_ref, r0[i]);
				}
				size_t elements_returned0_1 = sizeof(g0)/sizeof(*g0);
				array_init(g0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(g0_ref, g0[i]);
				}
				size_t elements_returned0_2 = sizeof(b0)/sizeof(*b0);
				array_init(b0_ref);
				for(size_t i=0; i<elements_returned0_2; i++)
				{
					add_next_index_long(b0_ref, b0[i]);
				}

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::FindFirstUnusedColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0, (unsigned char) startR0, (unsigned char) startG0, (unsigned char) startB0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->FindFirstUnusedColour((unsigned char*) r0, (unsigned char*) g0, (unsigned char*) b0, (unsigned char) startR0, (unsigned char) startG0, (unsigned char) startB0));

				size_t elements_returned0_0 = sizeof(r0)/sizeof(*r0);
				array_init(r0_ref);
				for(size_t i=0; i<elements_returned0_0; i++)
				{
					add_next_index_long(r0_ref, r0[i]);
				}
				size_t elements_returned0_1 = sizeof(g0)/sizeof(*g0);
				array_init(g0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(g0_ref, g0[i]);
				}
				size_t elements_returned0_2 = sizeof(b0)/sizeof(*b0);
				array_init(b0_ref);
				for(size_t i=0; i<elements_returned0_2; i++)
				{
					add_next_index_long(b0_ref, b0[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::FindFirstUnusedColour\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::Destroy()
   Destroys the image data. */
PHP_METHOD(php_wxImage, Destroy)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::Destroy\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::Destroy call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Destroy()\n\n");
				#endif

				((wxImage_php*)native_object)->Destroy();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::Destroy\n");
	}
}
/* }}} */

/* {{{ proto bool wxImage::Create(wxSize sz, int &data, int &alpha, bool static_data)
   This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. */
PHP_METHOD(php_wxImage, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::Create\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::Create call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* sz0 = 0;
	wxSize* object_pointer0_0 = 0;
	long* data0;
	zval* data0_ref;
	long* alpha0;
	zval* alpha0_ref;
	bool static_data0;
	bool overload0_called = false;
	//Parameters for overload 1
	long width1;
	long height1;
	long* data1;
	zval* data1_ref;
	long* alpha1;
	zval* alpha1_ref;
	bool static_data1;
	bool overload1_called = false;
	//Parameters for overload 2
	zval* sz2 = 0;
	wxSize* object_pointer2_0 = 0;
	long* data2;
	zval* data2_ref;
	bool static_data2;
	bool overload2_called = false;
	//Parameters for overload 3
	long width3;
	long height3;
	long* data3;
	zval* data3_ref;
	bool static_data3;
	bool overload3_called = false;
	//Parameters for overload 4
	zval* sz4 = 0;
	wxSize* object_pointer4_0 = 0;
	bool clear4;
	bool overload4_called = false;
	//Parameters for overload 5
	long width5;
	long height5;
	bool clear5;
	bool overload5_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Oll|b' (&sz0, php_wxSize_entry, data0, alpha0, &static_data0)\n");
		#endif

		char parse_parameters_string[] = "Oll|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &sz0, php_wxSize_entry, data0, alpha0, &static_data0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(sz0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(sz0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(sz0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxSize*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(sz0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zzz|z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &data0_ref, &alpha0_ref, &dummy );
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 4  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll|b' (&width1, &height1, data1, alpha1, &static_data1)\n");
		#endif

		char parse_parameters_string[] = "llll|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width1, &height1, data1, alpha1, &static_data1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;

			char parse_references_string[] = "zzzz|z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &dummy, &data1_ref, &alpha1_ref, &dummy );
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'Ol|b' (&sz2, php_wxSize_entry, data2, &static_data2)\n");
		#endif

		char parse_parameters_string[] = "Ol|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &sz2, php_wxSize_entry, data2, &static_data2 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(sz2) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(sz2 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(sz2 TSRMLS_CC))->native_object;
					object_pointer2_0 = (wxSize*) argument_native_object;
					if (!object_pointer2_0 )
					{
						goto overload3;
					}
				}
				else if(Z_TYPE_P(sz2) != IS_NULL)
				{
					goto overload3;
				}
			}

			overload2_called = true;
			already_called = true;

			char parse_references_string[] = "zz|z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &data2_ref, &dummy );
		}
	}

	//Overload 3
	overload3:
	if(!already_called && arguments_received >= 3  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll|b' (&width3, &height3, data3, &static_data3)\n");
		#endif

		char parse_parameters_string[] = "lll|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width3, &height3, data3, &static_data3 ) == SUCCESS)
		{
			overload3_called = true;
			already_called = true;

			char parse_references_string[] = "zzz|z";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &dummy, &data3_ref, &dummy );
		}
	}

	//Overload 4
	overload4:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|b' (&sz4, php_wxSize_entry, &clear4)\n");
		#endif

		char parse_parameters_string[] = "O|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &sz4, php_wxSize_entry, &clear4 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(sz4) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(sz4 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(sz4 TSRMLS_CC))->native_object;
					object_pointer4_0 = (wxSize*) argument_native_object;
					if (!object_pointer4_0 )
					{
						goto overload5;
					}
				}
				else if(Z_TYPE_P(sz4) != IS_NULL)
				{
					goto overload5;
				}
			}

			overload4_called = true;
			already_called = true;
		}
	}

	//Overload 5
	overload5:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll|b' (&width5, &height5, &clear5)\n");
		#endif

		char parse_parameters_string[] = "ll|b";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width5, &height5, &clear5 ) == SUCCESS)
		{
			overload5_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::Create(*(wxSize*) object_pointer0_0, (unsigned char*) data0, (unsigned char*) alpha0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->Create(*(wxSize*) object_pointer0_0, (unsigned char*) data0, (unsigned char*) alpha0));

				references->AddReference(sz0, "wxImage::Create at call with 3 argument(s)");
				size_t elements_returned0_1 = sizeof(data0)/sizeof(*data0);
				array_init(data0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(data0_ref, data0[i]);
				}
				size_t elements_returned0_2 = sizeof(alpha0)/sizeof(*alpha0);
				array_init(alpha0_ref);
				for(size_t i=0; i<elements_returned0_2; i++)
				{
					add_next_index_long(alpha0_ref, alpha0[i]);
				}

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::Create(*(wxSize*) object_pointer0_0, (unsigned char*) data0, (unsigned char*) alpha0, static_data0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->Create(*(wxSize*) object_pointer0_0, (unsigned char*) data0, (unsigned char*) alpha0, static_data0));

				references->AddReference(sz0, "wxImage::Create at call with 4 argument(s)");
				size_t elements_returned0_1 = sizeof(data0)/sizeof(*data0);
				array_init(data0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(data0_ref, data0[i]);
				}
				size_t elements_returned0_2 = sizeof(alpha0)/sizeof(*alpha0);
				array_init(alpha0_ref);
				for(size_t i=0; i<elements_returned0_2; i++)
				{
					add_next_index_long(alpha0_ref, alpha0[i]);
				}

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::Create((int) width1, (int) height1, (unsigned char*) data1, (unsigned char*) alpha1))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->Create((int) width1, (int) height1, (unsigned char*) data1, (unsigned char*) alpha1));

				size_t elements_returned1_2 = sizeof(data1)/sizeof(*data1);
				array_init(data1_ref);
				for(size_t i=0; i<elements_returned1_2; i++)
				{
					add_next_index_long(data1_ref, data1[i]);
				}
				size_t elements_returned1_3 = sizeof(alpha1)/sizeof(*alpha1);
				array_init(alpha1_ref);
				for(size_t i=0; i<elements_returned1_3; i++)
				{
					add_next_index_long(alpha1_ref, alpha1[i]);
				}

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::Create((int) width1, (int) height1, (unsigned char*) data1, (unsigned char*) alpha1, static_data1))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->Create((int) width1, (int) height1, (unsigned char*) data1, (unsigned char*) alpha1, static_data1));

				size_t elements_returned1_2 = sizeof(data1)/sizeof(*data1);
				array_init(data1_ref);
				for(size_t i=0; i<elements_returned1_2; i++)
				{
					add_next_index_long(data1_ref, data1[i]);
				}
				size_t elements_returned1_3 = sizeof(alpha1)/sizeof(*alpha1);
				array_init(alpha1_ref);
				for(size_t i=0; i<elements_returned1_3; i++)
				{
					add_next_index_long(alpha1_ref, alpha1[i]);
				}

				return;
				break;
			}
		}
	}

	if(overload2_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::Create(*(wxSize*) object_pointer2_0, (unsigned char*) data2))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->Create(*(wxSize*) object_pointer2_0, (unsigned char*) data2));

				references->AddReference(sz2, "wxImage::Create at call with 2 argument(s)");
				size_t elements_returned2_1 = sizeof(data2)/sizeof(*data2);
				array_init(data2_ref);
				for(size_t i=0; i<elements_returned2_1; i++)
				{
					add_next_index_long(data2_ref, data2[i]);
				}

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::Create(*(wxSize*) object_pointer2_0, (unsigned char*) data2, static_data2))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->Create(*(wxSize*) object_pointer2_0, (unsigned char*) data2, static_data2));

				references->AddReference(sz2, "wxImage::Create at call with 3 argument(s)");
				size_t elements_returned2_1 = sizeof(data2)/sizeof(*data2);
				array_init(data2_ref);
				for(size_t i=0; i<elements_returned2_1; i++)
				{
					add_next_index_long(data2_ref, data2[i]);
				}

				return;
				break;
			}
		}
	}

	if(overload3_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::Create((int) width3, (int) height3, (unsigned char*) data3))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->Create((int) width3, (int) height3, (unsigned char*) data3));

				size_t elements_returned3_2 = sizeof(data3)/sizeof(*data3);
				array_init(data3_ref);
				for(size_t i=0; i<elements_returned3_2; i++)
				{
					add_next_index_long(data3_ref, data3[i]);
				}

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::Create((int) width3, (int) height3, (unsigned char*) data3, static_data3))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->Create((int) width3, (int) height3, (unsigned char*) data3, static_data3));

				size_t elements_returned3_2 = sizeof(data3)/sizeof(*data3);
				array_init(data3_ref);
				for(size_t i=0; i<elements_returned3_2; i++)
				{
					add_next_index_long(data3_ref, data3[i]);
				}

				return;
				break;
			}
		}
	}

	if(overload4_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::Create(*(wxSize*) object_pointer4_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->Create(*(wxSize*) object_pointer4_0));

				references->AddReference(sz4, "wxImage::Create at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::Create(*(wxSize*) object_pointer4_0, clear4))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->Create(*(wxSize*) object_pointer4_0, clear4));

				references->AddReference(sz4, "wxImage::Create at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload5_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::Create((int) width5, (int) height5))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->Create((int) width5, (int) height5));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::Create((int) width5, (int) height5, clear5))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->Create((int) width5, (int) height5, clear5));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::Create\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxImage::Copy()
   Returns an identical copy of this image. */
PHP_METHOD(php_wxImage, Copy)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::Copy\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::Copy call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Copy() to return new object\n\n");
				#endif

				wxImage value_to_return0;
				value_to_return0 = ((wxImage_php*)native_object)->Copy();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo0 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::Copy\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxImage::ConvertToMono(int r, int g, int b)
   Returns monochromatic version of the image. */
PHP_METHOD(php_wxImage, ConvertToMono)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::ConvertToMono\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::ConvertToMono call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long r0;
	long g0;
	long b0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&r0, &g0, &b0)\n");
		#endif

		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &r0, &g0, &b0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::ConvertToMono((unsigned char) r0, (unsigned char) g0, (unsigned char) b0) to return new object\n\n");
				#endif

				wxImage value_to_return3;
				value_to_return3 = ((wxImage_php*)native_object)->ConvertToMono((unsigned char) r0, (unsigned char) g0, (unsigned char) b0);
				((wxRefCounter *) value_to_return3.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo3 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo3->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::ConvertToMono\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxImage::ConvertToGreyscale()
   Returns a greyscale version of the image. */
PHP_METHOD(php_wxImage, ConvertToGreyscale)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::ConvertToGreyscale\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::ConvertToGreyscale call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	double weight_r1;
	double weight_g1;
	double weight_b1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'ddd' (&weight_r1, &weight_g1, &weight_b1)\n");
		#endif

		char parse_parameters_string[] = "ddd";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &weight_r1, &weight_g1, &weight_b1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::ConvertToGreyscale() to return new object\n\n");
				#endif

				wxImage value_to_return0;
				value_to_return0 = ((wxImage_php*)native_object)->ConvertToGreyscale();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo0 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::ConvertToGreyscale(weight_r1, weight_g1, weight_b1) to return new object\n\n");
				#endif

				wxImage value_to_return3;
				value_to_return3 = ((wxImage_php*)native_object)->ConvertToGreyscale(weight_r1, weight_g1, weight_b1);
				((wxRefCounter *) value_to_return3.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo3 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo3->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::ConvertToGreyscale\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxImage::ConvertToDisabled(int brightness)
   Returns disabled (dimmed) version of the image. */
PHP_METHOD(php_wxImage, ConvertToDisabled)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::ConvertToDisabled\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::ConvertToDisabled call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long brightness0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&brightness0)\n");
		#endif

		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &brightness0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::ConvertToDisabled() to return new object\n\n");
				#endif

				wxImage value_to_return0;
				value_to_return0 = ((wxImage_php*)native_object)->ConvertToDisabled();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo0 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::ConvertToDisabled((unsigned char) brightness0) to return new object\n\n");
				#endif

				wxImage value_to_return1;
				value_to_return1 = ((wxImage_php*)native_object)->ConvertToDisabled((unsigned char) brightness0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo1 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::ConvertToDisabled\n");
	}
}
/* }}} */

/* {{{ proto bool wxImage::ConvertAlphaToMask(int mr, int mg, int mb, int threshold)
   If the image has alpha channel, this method converts it to mask using the specified colour as the mask colour. */
PHP_METHOD(php_wxImage, ConvertAlphaToMask)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::ConvertAlphaToMask\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::ConvertAlphaToMask call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long mr0;
	long mg0;
	long mb0;
	long threshold0;
	bool overload0_called = false;
	//Parameters for overload 1
	long threshold1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 3  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll|l' (&mr0, &mg0, &mb0, &threshold0)\n");
		#endif

		char parse_parameters_string[] = "lll|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &mr0, &mg0, &mb0, &threshold0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&threshold1)\n");
		#endif

		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &threshold1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::ConvertAlphaToMask((unsigned char) mr0, (unsigned char) mg0, (unsigned char) mb0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->ConvertAlphaToMask((unsigned char) mr0, (unsigned char) mg0, (unsigned char) mb0));


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::ConvertAlphaToMask((unsigned char) mr0, (unsigned char) mg0, (unsigned char) mb0, (unsigned char) threshold0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->ConvertAlphaToMask((unsigned char) mr0, (unsigned char) mg0, (unsigned char) mb0, (unsigned char) threshold0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::ConvertAlphaToMask())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->ConvertAlphaToMask());


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImage::ConvertAlphaToMask((unsigned char) threshold1))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImage_php*)native_object)->ConvertAlphaToMask((unsigned char) threshold1));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::ConvertAlphaToMask\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::ClearAlpha()
   Removes the alpha channel from the image. */
PHP_METHOD(php_wxImage, ClearAlpha)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::ClearAlpha\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::ClearAlpha call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::ClearAlpha()\n\n");
				#endif

				((wxImage_php*)native_object)->ClearAlpha();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::ClearAlpha\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::Clear(int value)
   Initialize the image data with zeroes (the default) or with the byte value given as value. */
PHP_METHOD(php_wxImage, Clear)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::Clear\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::Clear call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long value0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 0  && arguments_received <= 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '|l' (&value0)\n");
		#endif

		char parse_parameters_string[] = "|l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &value0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Clear()\n\n");
				#endif

				((wxImage_php*)native_object)->Clear();


				return;
				break;
			}
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Clear((unsigned char) value0)\n\n");
				#endif

				((wxImage_php*)native_object)->Clear((unsigned char) value0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::Clear\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::CleanUpHandlers()
   Deletes all image handlers. */
PHP_METHOD(php_wxImage, CleanUpHandlers)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::CleanUpHandlers\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::CleanUpHandlers call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxImage::CleanUpHandlers()\n\n");
				#endif

				wxImage::CleanUpHandlers();


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::CleanUpHandlers\n");
	}
}
/* }}} */

/* {{{ proto bool wxImage::CanRead(wxInputStream &stream)
   Returns true if at least one of the available image handlers can read the data in the given stream. */
PHP_METHOD(php_wxImage, CanRead)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::CanRead\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::CanRead call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* stream0 = 0;
	wxInputStream* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	char* filename1;
	long filename_len1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'o' (&stream0)\n");
		#endif

		char parse_parameters_string[] = "o";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stream0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stream0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxInputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxInputStream*) zend_object_store_get_object(stream0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxInputStream*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXINPUTSTREAM_TYPE && argument_type != PHP_WXFFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFFILESTREAM_TYPE && argument_type != PHP_WXFILEINPUTSTREAM_TYPE && argument_type != PHP_WXFILESTREAM_TYPE))
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(stream0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&filename1, &filename_len1)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &filename1, &filename_len1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_BOOL(wxImage::CanRead(*(wxInputStream*) object_pointer0_0))\n\n");
				#endif

				ZVAL_BOOL(return_value, wxImage::CanRead(*(wxInputStream*) object_pointer0_0));


				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing RETURN_BOOL(wxImage::CanRead(wxString(filename1, wxConvUTF8)))\n\n");
				#endif

				ZVAL_BOOL(return_value, wxImage::CanRead(wxString(filename1, wxConvUTF8)));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::CanRead\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxImage::BlurVertical(int blurRadius)
   Blurs the image in the vertical direction only. */
PHP_METHOD(php_wxImage, BlurVertical)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::BlurVertical\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::BlurVertical call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long blurRadius0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&blurRadius0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &blurRadius0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::BlurVertical((int) blurRadius0) to return new object\n\n");
				#endif

				wxImage value_to_return1;
				value_to_return1 = ((wxImage_php*)native_object)->BlurVertical((int) blurRadius0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo1 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::BlurVertical\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxImage::BlurHorizontal(int blurRadius)
   Blurs the image in the horizontal direction only. */
PHP_METHOD(php_wxImage, BlurHorizontal)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::BlurHorizontal\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::BlurHorizontal call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long blurRadius0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&blurRadius0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &blurRadius0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::BlurHorizontal((int) blurRadius0) to return new object\n\n");
				#endif

				wxImage value_to_return1;
				value_to_return1 = ((wxImage_php*)native_object)->BlurHorizontal((int) blurRadius0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo1 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::BlurHorizontal\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxImage::Blur(int blurRadius)
   Blurs the image in both horizontal and vertical directions by the specified pixel blurRadius. */
PHP_METHOD(php_wxImage, Blur)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::Blur\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::Blur call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long blurRadius0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&blurRadius0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &blurRadius0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Blur((int) blurRadius0) to return new object\n\n");
				#endif

				wxImage value_to_return1;
				value_to_return1 = ((wxImage_php*)native_object)->Blur((int) blurRadius0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo1 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxImage_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::Blur\n");
	}
}
/* }}} */

/* {{{ proto  wxImage::AddHandler(wxImageHandler &handler)
   Register an image handler. */
PHP_METHOD(php_wxImage, AddHandler)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::AddHandler\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::AddHandler call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* handler0 = 0;
	wxImageHandler* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&handler0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &handler0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(handler0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxImageHandler*) zend_object_store_get_object(handler0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxImageHandler*) zend_object_store_get_object(handler0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxImageHandler*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXIMAGEHANDLER_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'handler' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(handler0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'handler' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxImage::AddHandler((wxImageHandler*) object_pointer0_0)\n\n");
				#endif

				wxImage::AddHandler((wxImageHandler*) object_pointer0_0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::AddHandler\n");
	}
}
/* }}} */

/* {{{ proto wxImage wxImage::Size(wxSize size, wxPoint pos, int red, int green, int blue)
   Returns a resized version of this image without scaling it by adding either a border with the given colour or cropping as necessary. */
PHP_METHOD(php_wxImage, Size)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImage::Size\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImage* current_object;
	wxphp_object_type current_object_type;
	wxImage_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImage*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImage::Size call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGE_TYPE){
				references = &((wxImage_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* size0 = 0;
	wxSize* object_pointer0_0 = 0;
	zval* pos0 = 0;
	wxPoint* object_pointer0_1 = 0;
	long red0;
	long green0;
	long blue0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 5)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO|lll' (&size0, php_wxSize_entry, &pos0, php_wxPoint_entry, &red0, &green0, &blue0)\n");
		#endif

		char parse_parameters_string[] = "OO|lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &size0, php_wxSize_entry, &pos0, php_wxPoint_entry, &red0, &green0, &blue0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(size0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxSize*) zend_object_store_get_object(size0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxSize*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'size' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(size0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'size' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(pos0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPoint*) zend_object_store_get_object(pos0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPoint*) zend_object_store_get_object(pos0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxPoint*) argument_native_object;
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter 'pos' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(pos0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'pos' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Size(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1) to return new object\n\n");
				#endif

				wxImage value_to_return2;
				value_to_return2 = ((wxImage_php*)native_object)->Size(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1);
				((wxRefCounter *) value_to_return2.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return2, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo2 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo2->native_object = (wxImage_php*) ptr;

				references->AddReference(size0, "wxImage::Size at call with 2 argument(s)");
				references->AddReference(pos0, "wxImage::Size at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Size(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0) to return new object\n\n");
				#endif

				wxImage value_to_return3;
				value_to_return3 = ((wxImage_php*)native_object)->Size(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0);
				((wxRefCounter *) value_to_return3.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return3, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo3 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo3->native_object = (wxImage_php*) ptr;

				references->AddReference(size0, "wxImage::Size at call with 3 argument(s)");
				references->AddReference(pos0, "wxImage::Size at call with 3 argument(s)");

				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Size(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0, (int) green0) to return new object\n\n");
				#endif

				wxImage value_to_return4;
				value_to_return4 = ((wxImage_php*)native_object)->Size(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0, (int) green0);
				((wxRefCounter *) value_to_return4.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return4, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo4 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo4->native_object = (wxImage_php*) ptr;

				references->AddReference(size0, "wxImage::Size at call with 4 argument(s)");
				references->AddReference(pos0, "wxImage::Size at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImage::Size(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0, (int) green0, (int) blue0) to return new object\n\n");
				#endif

				wxImage value_to_return5;
				value_to_return5 = ((wxImage_php*)native_object)->Size(*(wxSize*) object_pointer0_0, *(wxPoint*) object_pointer0_1, (int) red0, (int) green0, (int) blue0);
				((wxRefCounter *) value_to_return5.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxImage_php), 0);
				memcpy(ptr, &value_to_return5, sizeof(wxImage));
				object_init_ex(return_value, php_wxImage_entry);
				((wxImage_php*)ptr)->phpObj = return_value;
				zo_wxImage* zo5 = (zo_wxImage*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo5->native_object = (wxImage_php*) ptr;

				references->AddReference(size0, "wxImage::Size at call with 5 argument(s)");
				references->AddReference(pos0, "wxImage::Size at call with 5 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImage::Size\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxImageList_free(void *object TSRMLS_DC) 
{
    zo_wxImageList* custom_object = (zo_wxImageList*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxImageList_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxImageList done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxImageList_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxImageList_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxImageList* custom_object;
    custom_object = (zo_wxImageList*) emalloc(sizeof(zo_wxImageList));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxImageList_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXIMAGELIST_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto int wxImageList::Add(wxBitmap bitmap, wxBitmap mask)
   Adds a new image or images using a bitmap and optional mask bitmap. */
PHP_METHOD(php_wxImageList, Add)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageList::Add\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageList* current_object;
	wxphp_object_type current_object_type;
	wxImageList_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageList*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageList::Add call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGELIST_TYPE){
				references = &((wxImageList_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	zval* mask0 = 0;
	wxBitmap* object_pointer0_1 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	zval* bitmap1 = 0;
	wxBitmap* object_pointer1_0 = 0;
	zval* maskColour1 = 0;
	wxColour* object_pointer1_1 = 0;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|O' (&bitmap0, php_wxBitmap_entry, &mask0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O|O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap0, php_wxBitmap_entry, &mask0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					goto overload1;
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(mask0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(mask0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(mask0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_1 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(mask0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 2)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'OO' (&bitmap1, php_wxBitmap_entry, &maskColour1, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "OO";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &bitmap1, php_wxBitmap_entry, &maskColour1, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(bitmap1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 2){
				if(Z_TYPE_P(maskColour1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(maskColour1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(maskColour1 TSRMLS_CC))->native_object;
					object_pointer1_1 = (wxColour*) argument_native_object;
					if (!object_pointer1_1 )
					{
						zend_error(E_ERROR, "Parameter 'maskColour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(maskColour1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'maskColour' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImageList::Add(*(wxBitmap*) object_pointer0_0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxImageList_php*)native_object)->Add(*(wxBitmap*) object_pointer0_0));

				references->AddReference(bitmap0, "wxImageList::Add at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImageList::Add(*(wxBitmap*) object_pointer0_0, *(wxBitmap*) object_pointer0_1))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxImageList_php*)native_object)->Add(*(wxBitmap*) object_pointer0_0, *(wxBitmap*) object_pointer0_1));

				references->AddReference(bitmap0, "wxImageList::Add at call with 2 argument(s)");
				references->AddReference(mask0, "wxImageList::Add at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImageList::Add(*(wxBitmap*) object_pointer1_0, *(wxColour*) object_pointer1_1))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxImageList_php*)native_object)->Add(*(wxBitmap*) object_pointer1_0, *(wxColour*) object_pointer1_1));

				references->AddReference(bitmap1, "wxImageList::Add at call with 2 argument(s)");
				references->AddReference(maskColour1, "wxImageList::Add at call with 2 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageList::Add\n");
	}
}
/* }}} */

/* {{{ proto bool wxImageList::Create(int width, int height, bool mask, int initialCount)
   Initializes the list. */
PHP_METHOD(php_wxImageList, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageList::Create\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageList* current_object;
	wxphp_object_type current_object_type;
	wxImageList_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageList*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageList::Create call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGELIST_TYPE){
				references = &((wxImageList_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	long height0;
	bool mask0;
	long initialCount0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll|bl' (&width0, &height0, &mask0, &initialCount0)\n");
		#endif

		char parse_parameters_string[] = "ll|bl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0, &height0, &mask0, &initialCount0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageList::Create((int) width0, (int) height0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImageList_php*)native_object)->Create((int) width0, (int) height0));


				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageList::Create((int) width0, (int) height0, mask0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImageList_php*)native_object)->Create((int) width0, (int) height0, mask0));


				return;
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageList::Create((int) width0, (int) height0, mask0, (int) initialCount0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImageList_php*)native_object)->Create((int) width0, (int) height0, mask0, (int) initialCount0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageList::Create\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxImageList::GetBitmap(int index)
   Returns the bitmap corresponding to the given index. */
PHP_METHOD(php_wxImageList, GetBitmap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageList::GetBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageList* current_object;
	wxphp_object_type current_object_type;
	wxImageList_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageList*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageList::GetBitmap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGELIST_TYPE){
				references = &((wxImageList_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long index0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&index0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImageList::GetBitmap((int) index0) to return new object\n\n");
				#endif

				wxBitmap value_to_return1;
				value_to_return1 = ((wxImageList_php*)native_object)->GetBitmap((int) index0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxBitmap_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxBitmap));
				object_init_ex(return_value, php_wxBitmap_entry);
				((wxBitmap_php*)ptr)->phpObj = return_value;
				zo_wxBitmap* zo1 = (zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxBitmap_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageList::GetBitmap\n");
	}
}
/* }}} */

/* {{{ proto wxIcon wxImageList::GetIcon(int index)
   Returns the icon corresponding to the given index. */
PHP_METHOD(php_wxImageList, GetIcon)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageList::GetIcon\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageList* current_object;
	wxphp_object_type current_object_type;
	wxImageList_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageList*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageList::GetIcon call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGELIST_TYPE){
				references = &((wxImageList_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long index0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&index0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxImageList::GetIcon((int) index0) to return new object\n\n");
				#endif

				wxIcon value_to_return1;
				value_to_return1 = ((wxImageList_php*)native_object)->GetIcon((int) index0);
				((wxRefCounter *) value_to_return1.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxIcon_php), 0);
				memcpy(ptr, &value_to_return1, sizeof(wxIcon));
				object_init_ex(return_value, php_wxIcon_entry);
				((wxIcon_php*)ptr)->phpObj = return_value;
				zo_wxIcon* zo1 = (zo_wxIcon*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo1->native_object = (wxIcon_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageList::GetIcon\n");
	}
}
/* }}} */

/* {{{ proto int wxImageList::GetImageCount()
   Returns the number of images in the list. */
PHP_METHOD(php_wxImageList, GetImageCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageList::GetImageCount\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageList* current_object;
	wxphp_object_type current_object_type;
	wxImageList_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageList*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageList::GetImageCount call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGELIST_TYPE){
				references = &((wxImageList_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxImageList::GetImageCount())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxImageList_php*)native_object)->GetImageCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageList::GetImageCount\n");
	}
}
/* }}} */

/* {{{ proto bool wxImageList::GetSize(int index, int &width, int &height)
   Retrieves the size of the images in the list. */
PHP_METHOD(php_wxImageList, GetSize)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageList::GetSize\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageList* current_object;
	wxphp_object_type current_object_type;
	wxImageList_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageList*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageList::GetSize call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGELIST_TYPE){
				references = &((wxImageList_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long index0;
	long width0;
	zval* width0_ref;
	long height0;
	zval* height0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&index0, &width0, &height0)\n");
		#endif

		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index0, &width0, &height0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zzz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &width0_ref, &height0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageList::GetSize((int) index0, (int&) width0, (int&) height0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImageList_php*)native_object)->GetSize((int) index0, (int&) width0, (int&) height0));

				ZVAL_LONG(width0_ref, width0);
				ZVAL_LONG(height0_ref, height0);

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageList::GetSize\n");
	}
}
/* }}} */

/* {{{ proto bool wxImageList::Remove(int index)
   Removes the image at the given position. */
PHP_METHOD(php_wxImageList, Remove)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageList::Remove\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageList* current_object;
	wxphp_object_type current_object_type;
	wxImageList_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageList*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageList::Remove call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGELIST_TYPE){
				references = &((wxImageList_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long index0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&index0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageList::Remove((int) index0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImageList_php*)native_object)->Remove((int) index0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageList::Remove\n");
	}
}
/* }}} */

/* {{{ proto bool wxImageList::RemoveAll()
   Removes all the images in the list. */
PHP_METHOD(php_wxImageList, RemoveAll)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageList::RemoveAll\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageList* current_object;
	wxphp_object_type current_object_type;
	wxImageList_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageList*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageList::RemoveAll call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGELIST_TYPE){
				references = &((wxImageList_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageList::RemoveAll())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImageList_php*)native_object)->RemoveAll());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageList::RemoveAll\n");
	}
}
/* }}} */

/* {{{ proto bool wxImageList::Replace(int index, wxBitmap bitmap, wxBitmap mask)
   Replaces the existing image with the new image. */
PHP_METHOD(php_wxImageList, Replace)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageList::Replace\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageList* current_object;
	wxphp_object_type current_object_type;
	wxImageList_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageList*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageList::Replace call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGELIST_TYPE){
				references = &((wxImageList_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long index0;
	zval* bitmap0 = 0;
	wxBitmap* object_pointer0_1 = 0;
	zval* mask0 = 0;
	wxBitmap* object_pointer0_2 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 2  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lO|O' (&index0, &bitmap0, php_wxBitmap_entry, &mask0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "lO|O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index0, &bitmap0, php_wxBitmap_entry, &mask0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(bitmap0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(bitmap0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_1 )
					{
						zend_error(E_ERROR, "Parameter 'bitmap' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(bitmap0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'bitmap' not null, could not be retreived correctly.");
				}
			}

			if(arguments_received >= 3){
				if(Z_TYPE_P(mask0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(mask0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(mask0 TSRMLS_CC))->native_object;
					object_pointer0_2 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_2 )
					{
						zend_error(E_ERROR, "Parameter 'mask' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(mask0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'mask' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageList::Replace((int) index0, *(wxBitmap*) object_pointer0_1))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImageList_php*)native_object)->Replace((int) index0, *(wxBitmap*) object_pointer0_1));

				references->AddReference(bitmap0, "wxImageList::Replace at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageList::Replace((int) index0, *(wxBitmap*) object_pointer0_1, *(wxBitmap*) object_pointer0_2))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImageList_php*)native_object)->Replace((int) index0, *(wxBitmap*) object_pointer0_1, *(wxBitmap*) object_pointer0_2));

				references->AddReference(bitmap0, "wxImageList::Replace at call with 3 argument(s)");
				references->AddReference(mask0, "wxImageList::Replace at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageList::Replace\n");
	}
}
/* }}} */

/* {{{ proto  wxImageList::wxImageList()
   Default ctor. */
PHP_METHOD(php_wxImageList, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageList::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageList* current_object;
	wxImageList_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	long width1;
	long height1;
	bool mask1;
	long initialCount1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 2  && arguments_received <= 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'll|bl' (&width1, &height1, &mask1, &initialCount1)\n");
		#endif

		char parse_parameters_string[] = "ll|bl";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width1, &height1, &mask1, &initialCount1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxImageList_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width1, (int) height1)\n");
				#endif

				native_object = new wxImageList_php((int) width1, (int) height1);

				native_object->references.Initialize();
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width1, (int) height1, mask1)\n");
				#endif

				native_object = new wxImageList_php((int) width1, (int) height1, mask1);

				native_object->references.Initialize();
				break;
			}
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) width1, (int) height1, mask1, (int) initialCount1)\n");
				#endif

				native_object = new wxImageList_php((int) width1, (int) height1, mask1, (int) initialCount1);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxImageList*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxImageList::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto bool wxImageList::Draw(int index, wxDC &dc, int x, int y, int flags, bool solidBackground)
   Draws a specified image onto a device context. */
PHP_METHOD(php_wxImageList, Draw)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxImageList::Draw\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxImageList* current_object;
	wxphp_object_type current_object_type;
	wxImageList_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxImageList*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxImageList::Draw call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXIMAGELIST_TYPE){
				references = &((wxImageList_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long index0;
	zval* dc0 = 0;
	wxDC* object_pointer0_1 = 0;
	long x0;
	long y0;
	long flags0;
	bool solidBackground0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 4  && arguments_received <= 6)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'loll|lb' (&index0, &dc0, &x0, &y0, &flags0, &solidBackground0)\n");
		#endif

		char parse_parameters_string[] = "loll|lb";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &index0, &dc0, &x0, &y0, &flags0, &solidBackground0 ) == SUCCESS)
		{
			if(arguments_received >= 2){
				if(Z_TYPE_P(dc0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxDC*) zend_object_store_get_object(dc0 TSRMLS_CC))->native_object;
					object_pointer0_1 = (wxDC*) argument_native_object;
					if (!object_pointer0_1 || (argument_type != PHP_WXDC_TYPE && argument_type != PHP_WXWINDOWDC_TYPE && argument_type != PHP_WXCLIENTDC_TYPE && argument_type != PHP_WXPAINTDC_TYPE && argument_type != PHP_WXSCREENDC_TYPE && argument_type != PHP_WXPOSTSCRIPTDC_TYPE && argument_type != PHP_WXPRINTERDC_TYPE && argument_type != PHP_WXMEMORYDC_TYPE && argument_type != PHP_WXBUFFEREDDC_TYPE && argument_type != PHP_WXBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXAUTOBUFFEREDPAINTDC_TYPE && argument_type != PHP_WXMIRRORDC_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'dc' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(dc0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'dc' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageList::Draw((int) index0, *(wxDC*) object_pointer0_1, (int) x0, (int) y0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImageList_php*)native_object)->Draw((int) index0, *(wxDC*) object_pointer0_1, (int) x0, (int) y0));

				references->AddReference(dc0, "wxImageList::Draw at call with 4 argument(s)");

				return;
				break;
			}
			case 5:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageList::Draw((int) index0, *(wxDC*) object_pointer0_1, (int) x0, (int) y0, (int) flags0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImageList_php*)native_object)->Draw((int) index0, *(wxDC*) object_pointer0_1, (int) x0, (int) y0, (int) flags0));

				references->AddReference(dc0, "wxImageList::Draw at call with 5 argument(s)");

				return;
				break;
			}
			case 6:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxImageList::Draw((int) index0, *(wxDC*) object_pointer0_1, (int) x0, (int) y0, (int) flags0, solidBackground0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxImageList_php*)native_object)->Draw((int) index0, *(wxDC*) object_pointer0_1, (int) x0, (int) y0, (int) flags0, solidBackground0));

				references->AddReference(dc0, "wxImageList::Draw at call with 6 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxImageList::Draw\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPalette_free(void *object TSRMLS_DC) 
{
    zo_wxPalette* custom_object = (zo_wxPalette*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPalette_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxPalette done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxPalette_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPalette_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxPalette* custom_object;
    custom_object = (zo_wxPalette*) emalloc(sizeof(zo_wxPalette));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxPalette_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXPALETTE_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxPalette::wxPalette()
   Default constructor. */
PHP_METHOD(php_wxPalette, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPalette::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPalette* current_object;
	wxPalette_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* palette1 = 0;
	wxPalette* object_pointer1_0 = 0;
	bool overload1_called = false;
	//Parameters for overload 2
	long n2;
	zval* red2;
	zval* green2;
	zval* blue2;
	bool overload2_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&palette1, php_wxPalette_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &palette1, php_wxPalette_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(palette1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxPalette*) zend_object_store_get_object(palette1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxPalette*) zend_object_store_get_object(palette1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxPalette*) argument_native_object;
					if (!object_pointer1_0 )
					{
						goto overload2;
					}
				}
				else if(Z_TYPE_P(palette1) != IS_NULL)
				{
					goto overload2;
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

	//Overload 2
	overload2:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'laaa' (&n2, &red2, &green2, &blue2)\n");
		#endif

		char parse_parameters_string[] = "laaa";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n2, &red2, &green2, &blue2 ) == SUCCESS)
		{
			overload2_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxPalette_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxPalette*) object_pointer1_0)\n");
				#endif

				native_object = new wxPalette_php(*(wxPalette*) object_pointer1_0);

				native_object->references.Initialize();
				((wxPalette_php*) native_object)->references.AddReference(palette1, "wxPalette::wxPalette at call with 1 argument(s)");
				break;
			}
		}
	}

	if(overload2_called)
	{
		int array_count2_1 = 1;
		HashTable* arr_hash2_1;
		if(arguments_received > 1)
		{
			arr_hash2_1 = Z_ARRVAL_P(red2);
			array_count2_1 = zend_hash_num_elements(arr_hash2_1);
		}
		unsigned char* integers_array2_1 = new unsigned char[array_count2_1];
		bool integers_continue2_1 = true;

		int array_count2_2 = 1;
		HashTable* arr_hash2_2;
		if(arguments_received > 2)
		{
			arr_hash2_2 = Z_ARRVAL_P(green2);
			array_count2_2 = zend_hash_num_elements(arr_hash2_2);
		}
		unsigned char* integers_array2_2 = new unsigned char[array_count2_2];
		bool integers_continue2_2 = true;

		int array_count2_3 = 1;
		HashTable* arr_hash2_3;
		if(arguments_received > 3)
		{
			arr_hash2_3 = Z_ARRVAL_P(blue2);
			array_count2_3 = zend_hash_num_elements(arr_hash2_3);
		}
		unsigned char* integers_array2_3 = new unsigned char[array_count2_3];
		bool integers_continue2_3 = true;

		switch(arguments_received)
		{
			case 4:
			{
				int array_index2_1 = 0;
				zval** temp_array_value2_1 = 0;
				while(integers_continue2_1)
				{
					if(zend_hash_index_find(HASH_OF(red2), array_index2_1, (void**)&temp_array_value2_1) == SUCCESS)
					{
						convert_to_long_ex(temp_array_value2_1);
						integers_array2_1[array_index2_1] = (unsigned char) Z_LVAL_PP(temp_array_value2_1);
						array_index2_1++;
					}
					else
					{
						integers_continue2_1 = false;
					}
				}
				int array_index2_2 = 0;
				zval** temp_array_value2_2 = 0;
				while(integers_continue2_2)
				{
					if(zend_hash_index_find(HASH_OF(green2), array_index2_2, (void**)&temp_array_value2_2) == SUCCESS)
					{
						convert_to_long_ex(temp_array_value2_2);
						integers_array2_2[array_index2_2] = (unsigned char) Z_LVAL_PP(temp_array_value2_2);
						array_index2_2++;
					}
					else
					{
						integers_continue2_2 = false;
					}
				}
				int array_index2_3 = 0;
				zval** temp_array_value2_3 = 0;
				while(integers_continue2_3)
				{
					if(zend_hash_index_find(HASH_OF(blue2), array_index2_3, (void**)&temp_array_value2_3) == SUCCESS)
					{
						convert_to_long_ex(temp_array_value2_3);
						integers_array2_3[array_index2_3] = (unsigned char) Z_LVAL_PP(temp_array_value2_3);
						array_index2_3++;
					}
					else
					{
						integers_continue2_3 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct((int) n2, (const unsigned char*) integers_array2_1, (const unsigned char*) integers_array2_2, (const unsigned char*) integers_array2_3)\n");
				#endif

				native_object = new wxPalette_php((int) n2, (const unsigned char*) integers_array2_1, (const unsigned char*) integers_array2_2, (const unsigned char*) integers_array2_3);

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxPalette*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxPalette::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto bool wxPalette::IsOk()
   Returns true if palette data is present. */
PHP_METHOD(php_wxPalette, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPalette::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPalette* current_object;
	wxphp_object_type current_object_type;
	wxPalette_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPalette*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPalette::IsOk call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPALETTE_TYPE){
				references = &((wxPalette_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPalette::IsOk())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPalette_php*)native_object)->IsOk());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPalette::IsOk\n");
	}
}
/* }}} */

/* {{{ proto int wxPalette::GetPixel(int red, int green, int blue)
   Returns a pixel value (index into the palette) for the given RGB values. */
PHP_METHOD(php_wxPalette, GetPixel)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPalette::GetPixel\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPalette* current_object;
	wxphp_object_type current_object_type;
	wxPalette_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPalette*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPalette::GetPixel call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPALETTE_TYPE){
				references = &((wxPalette_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long red0;
	long green0;
	long blue0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&red0, &green0, &blue0)\n");
		#endif

		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &red0, &green0, &blue0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPalette::GetPixel((unsigned char) red0, (unsigned char) green0, (unsigned char) blue0))\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPalette_php*)native_object)->GetPixel((unsigned char) red0, (unsigned char) green0, (unsigned char) blue0));


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPalette::GetPixel\n");
	}
}
/* }}} */

/* {{{ proto int wxPalette::GetColoursCount()
   Returns number of entries in palette. */
PHP_METHOD(php_wxPalette, GetColoursCount)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPalette::GetColoursCount\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPalette* current_object;
	wxphp_object_type current_object_type;
	wxPalette_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPalette*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPalette::GetColoursCount call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPALETTE_TYPE){
				references = &((wxPalette_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPalette::GetColoursCount())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPalette_php*)native_object)->GetColoursCount());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPalette::GetColoursCount\n");
	}
}
/* }}} */

/* {{{ proto bool wxPalette::Create(int n, array red, array green, array blue)
   Creates a palette from arrays of size n, one for each red, blue or green component. */
PHP_METHOD(php_wxPalette, Create)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPalette::Create\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPalette* current_object;
	wxphp_object_type current_object_type;
	wxPalette_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPalette*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPalette::Create call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPALETTE_TYPE){
				references = &((wxPalette_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long n0;
	zval* red0;
	zval* green0;
	zval* blue0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'laaa' (&n0, &red0, &green0, &blue0)\n");
		#endif

		char parse_parameters_string[] = "laaa";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &n0, &red0, &green0, &blue0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		int array_count0_1 = 1;
		HashTable* arr_hash0_1;
		if(arguments_received > 1)
		{
			arr_hash0_1 = Z_ARRVAL_P(red0);
			array_count0_1 = zend_hash_num_elements(arr_hash0_1);
		}
		unsigned char* integers_array0_1 = new unsigned char[array_count0_1];
		bool integers_continue0_1 = true;

		int array_count0_2 = 1;
		HashTable* arr_hash0_2;
		if(arguments_received > 2)
		{
			arr_hash0_2 = Z_ARRVAL_P(green0);
			array_count0_2 = zend_hash_num_elements(arr_hash0_2);
		}
		unsigned char* integers_array0_2 = new unsigned char[array_count0_2];
		bool integers_continue0_2 = true;

		int array_count0_3 = 1;
		HashTable* arr_hash0_3;
		if(arguments_received > 3)
		{
			arr_hash0_3 = Z_ARRVAL_P(blue0);
			array_count0_3 = zend_hash_num_elements(arr_hash0_3);
		}
		unsigned char* integers_array0_3 = new unsigned char[array_count0_3];
		bool integers_continue0_3 = true;

		switch(arguments_received)
		{
			case 4:
			{
				int array_index0_1 = 0;
				zval** temp_array_value0_1 = 0;
				while(integers_continue0_1)
				{
					if(zend_hash_index_find(HASH_OF(red0), array_index0_1, (void**)&temp_array_value0_1) == SUCCESS)
					{
						convert_to_long_ex(temp_array_value0_1);
						integers_array0_1[array_index0_1] = (unsigned char) Z_LVAL_PP(temp_array_value0_1);
						array_index0_1++;
					}
					else
					{
						integers_continue0_1 = false;
					}
				}
				int array_index0_2 = 0;
				zval** temp_array_value0_2 = 0;
				while(integers_continue0_2)
				{
					if(zend_hash_index_find(HASH_OF(green0), array_index0_2, (void**)&temp_array_value0_2) == SUCCESS)
					{
						convert_to_long_ex(temp_array_value0_2);
						integers_array0_2[array_index0_2] = (unsigned char) Z_LVAL_PP(temp_array_value0_2);
						array_index0_2++;
					}
					else
					{
						integers_continue0_2 = false;
					}
				}
				int array_index0_3 = 0;
				zval** temp_array_value0_3 = 0;
				while(integers_continue0_3)
				{
					if(zend_hash_index_find(HASH_OF(blue0), array_index0_3, (void**)&temp_array_value0_3) == SUCCESS)
					{
						convert_to_long_ex(temp_array_value0_3);
						integers_array0_3[array_index0_3] = (unsigned char) Z_LVAL_PP(temp_array_value0_3);
						array_index0_3++;
					}
					else
					{
						integers_continue0_3 = false;
					}
				}
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPalette::Create((int) n0, (const unsigned char*) integers_array0_1, (const unsigned char*) integers_array0_2, (const unsigned char*) integers_array0_3))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPalette_php*)native_object)->Create((int) n0, (const unsigned char*) integers_array0_1, (const unsigned char*) integers_array0_2, (const unsigned char*) integers_array0_3));

				delete[] integers_array0_1;
				delete[] integers_array0_2;
				delete[] integers_array0_3;

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPalette::Create\n");
	}
}
/* }}} */

/* {{{ proto bool wxPalette::GetRGB(int pixel, int &red, int &green, int &blue)
   Returns RGB values for a given palette index. */
PHP_METHOD(php_wxPalette, GetRGB)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPalette::GetRGB\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPalette* current_object;
	wxphp_object_type current_object_type;
	wxPalette_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPalette*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPalette::GetRGB call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPALETTE_TYPE){
				references = &((wxPalette_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long pixel0;
	long* red0;
	zval* red0_ref;
	long* green0;
	zval* green0_ref;
	long* blue0;
	zval* blue0_ref;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 4)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'llll' (&pixel0, red0, green0, blue0)\n");
		#endif

		char parse_parameters_string[] = "llll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &pixel0, red0, green0, blue0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;

			char parse_references_string[] = "zzzz";
			zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_references_string, &dummy, &red0_ref, &green0_ref, &blue0_ref );
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 4:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPalette::GetRGB((int) pixel0, (unsigned char*) red0, (unsigned char*) green0, (unsigned char*) blue0))\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPalette_php*)native_object)->GetRGB((int) pixel0, (unsigned char*) red0, (unsigned char*) green0, (unsigned char*) blue0));

				size_t elements_returned0_1 = sizeof(red0)/sizeof(*red0);
				array_init(red0_ref);
				for(size_t i=0; i<elements_returned0_1; i++)
				{
					add_next_index_long(red0_ref, red0[i]);
				}
				size_t elements_returned0_2 = sizeof(green0)/sizeof(*green0);
				array_init(green0_ref);
				for(size_t i=0; i<elements_returned0_2; i++)
				{
					add_next_index_long(green0_ref, green0[i]);
				}
				size_t elements_returned0_3 = sizeof(blue0)/sizeof(*blue0);
				array_init(blue0_ref);
				for(size_t i=0; i<elements_returned0_3; i++)
				{
					add_next_index_long(blue0_ref, blue0[i]);
				}

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPalette::GetRGB\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPen_free(void *object TSRMLS_DC) 
{
    zo_wxPen* custom_object = (zo_wxPen*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPen_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxPen done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxPen_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPen_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxPen* custom_object;
    custom_object = (zo_wxPen*) emalloc(sizeof(zo_wxPen));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxPen_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXPEN_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxPen::wxPen()
   Default constructor. */
PHP_METHOD(php_wxPen, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPen::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPen* current_object;
	wxPen_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
	//Parameters for overload 1
	zval* colour1 = 0;
	wxColour* object_pointer1_0 = 0;
	long width1;
	long style1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received >= 1  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|ll' (&colour1, php_wxColour_entry, &width1, &style1)\n");
		#endif

		char parse_parameters_string[] = "O|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour1, php_wxColour_entry, &width1, &style1 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour1) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour1 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour1 TSRMLS_CC))->native_object;
					object_pointer1_0 = (wxColour*) argument_native_object;
					if (!object_pointer1_0 )
					{
						zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour1) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
				}
			}

			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxPen_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer1_0)\n");
				#endif

				native_object = new wxPen_php(*(wxColour*) object_pointer1_0);

				native_object->references.Initialize();
				((wxPen_php*) native_object)->references.AddReference(colour1, "wxPen::wxPen at call with 1 argument(s)");
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer1_0, (int) width1)\n");
				#endif

				native_object = new wxPen_php(*(wxColour*) object_pointer1_0, (int) width1);

				native_object->references.Initialize();
				((wxPen_php*) native_object)->references.AddReference(colour1, "wxPen::wxPen at call with 2 argument(s)");
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct(*(wxColour*) object_pointer1_0, (int) width1, (wxPenStyle) style1)\n");
				#endif

				native_object = new wxPen_php(*(wxColour*) object_pointer1_0, (int) width1, (wxPenStyle) style1);

				native_object->references.Initialize();
				((wxPen_php*) native_object)->references.AddReference(colour1, "wxPen::wxPen at call with 3 argument(s)");
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxPen*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxPen::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

/* {{{ proto bool wxPen::IsTransparent()
   Returns true if the pen is transparent. */
PHP_METHOD(php_wxPen, IsTransparent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPen::IsTransparent\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPen* current_object;
	wxphp_object_type current_object_type;
	wxPen_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPen*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPen::IsTransparent call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPEN_TYPE){
				references = &((wxPen_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPen::IsTransparent())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPen_php*)native_object)->IsTransparent());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPen::IsTransparent\n");
	}
}
/* }}} */

/* {{{ proto bool wxPen::IsOk()
   Returns true if the pen is initialised. */
PHP_METHOD(php_wxPen, IsOk)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPen::IsOk\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPen* current_object;
	wxphp_object_type current_object_type;
	wxPen_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPen*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPen::IsOk call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPEN_TYPE){
				references = &((wxPen_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPen::IsOk())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPen_php*)native_object)->IsOk());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPen::IsOk\n");
	}
}
/* }}} */

/* {{{ proto bool wxPen::IsNonTransparent()
   Returns true if the pen is a valid non-transparent pen. */
PHP_METHOD(php_wxPen, IsNonTransparent)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPen::IsNonTransparent\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPen* current_object;
	wxphp_object_type current_object_type;
	wxPen_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPen*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPen::IsNonTransparent call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPEN_TYPE){
				references = &((wxPen_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_BOOL(wxPen::IsNonTransparent())\n\n");
				#endif

				ZVAL_BOOL(return_value, ((wxPen_php*)native_object)->IsNonTransparent());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPen::IsNonTransparent\n");
	}
}
/* }}} */

/* {{{ proto int wxPen::GetWidth()
   Returns the pen width. */
PHP_METHOD(php_wxPen, GetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPen::GetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPen* current_object;
	wxphp_object_type current_object_type;
	wxPen_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPen*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPen::GetWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPEN_TYPE){
				references = &((wxPen_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPen::GetWidth())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPen_php*)native_object)->GetWidth());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPen::GetWidth\n");
	}
}
/* }}} */

/* {{{ proto wxPenStyle wxPen::GetStyle()
   Returns the pen style. */
PHP_METHOD(php_wxPen, GetStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPen::GetStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPen* current_object;
	wxphp_object_type current_object_type;
	wxPen_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPen*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPen::GetStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPEN_TYPE){
				references = &((wxPen_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPen::GetStyle())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPen_php*)native_object)->GetStyle());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPen::GetStyle\n");
	}
}
/* }}} */

/* {{{ proto wxBitmap wxPen::GetStipple()
   Gets a pointer to the stipple bitmap. */
PHP_METHOD(php_wxPen, GetStipple)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPen::GetStipple\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPen* current_object;
	wxphp_object_type current_object_type;
	wxPen_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPen*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPen::GetStipple call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPEN_TYPE){
				references = &((wxPen_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPen::GetStipple() to return object pointer\n\n");
				#endif

				wxBitmap_php* value_to_return0;
				value_to_return0 = (wxBitmap_php*) ((wxPen_php*)native_object)->GetStipple();

				if(value_to_return0 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxBitmap_entry);
					((zo_wxBitmap*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxBitmap_php*) value_to_return0;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return0 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxPen::GetStipple at call with 0 argument(s)");
				}


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPen::GetStipple\n");
	}
}
/* }}} */

/* {{{ proto wxPenJoin wxPen::GetJoin()
   Returns the pen join style, which may be one of wxJOIN_BEVEL, wxJOIN_ROUND and wxJOIN_MITER. */
PHP_METHOD(php_wxPen, GetJoin)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPen::GetJoin\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPen* current_object;
	wxphp_object_type current_object_type;
	wxPen_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPen*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPen::GetJoin call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPEN_TYPE){
				references = &((wxPen_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPen::GetJoin())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPen_php*)native_object)->GetJoin());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPen::GetJoin\n");
	}
}
/* }}} */

/* {{{ proto wxColour wxPen::GetColour()
   Returns a reference to the pen colour. */
PHP_METHOD(php_wxPen, GetColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPen::GetColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPen* current_object;
	wxphp_object_type current_object_type;
	wxPen_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPen*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPen::GetColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPEN_TYPE){
				references = &((wxPen_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPen::GetColour() to return new object\n\n");
				#endif

				wxColour value_to_return0;
				value_to_return0 = ((wxPen_php*)native_object)->GetColour();
				((wxRefCounter *) value_to_return0.GetRefData())->IncRef();
				void* ptr = safe_emalloc(1, sizeof(wxColour_php), 0);
				memcpy(ptr, &value_to_return0, sizeof(wxColour));
				object_init_ex(return_value, php_wxColour_entry);
				((wxColour_php*)ptr)->phpObj = return_value;
				zo_wxColour* zo0 = (zo_wxColour*) zend_object_store_get_object(return_value TSRMLS_CC);
				zo0->native_object = (wxColour_php*) ptr;


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPen::GetColour\n");
	}
}
/* }}} */

/* {{{ proto wxPenCap wxPen::GetCap()
   Returns the pen cap style, which may be one of wxCAP_ROUND, wxCAP_PROJECTING and wxCAP_BUTT. */
PHP_METHOD(php_wxPen, GetCap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPen::GetCap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPen* current_object;
	wxphp_object_type current_object_type;
	wxPen_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPen*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPen::GetCap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPEN_TYPE){
				references = &((wxPen_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing RETURN_LONG(wxPen::GetCap())\n\n");
				#endif

				ZVAL_LONG(return_value, ((wxPen_php*)native_object)->GetCap());


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPen::GetCap\n");
	}
}
/* }}} */

/* {{{ proto  wxPen::SetColour(wxColour &colour)
   The pen's colour is changed to the given colour. */
PHP_METHOD(php_wxPen, SetColour)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPen::SetColour\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPen* current_object;
	wxphp_object_type current_object_type;
	wxPen_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPen*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPen::SetColour call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPEN_TYPE){
				references = &((wxPen_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colour0 = 0;
	wxColour* object_pointer0_0 = 0;
	bool overload0_called = false;
	//Parameters for overload 1
	long red1;
	long green1;
	long blue1;
	bool overload1_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&colour0, php_wxColour_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						goto overload1;
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
					goto overload1;
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

	//Overload 1
	overload1:
	if(!already_called && arguments_received == 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'lll' (&red1, &green1, &blue1)\n");
		#endif

		char parse_parameters_string[] = "lll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &red1, &green1, &blue1 ) == SUCCESS)
		{
			overload1_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPen::SetColour(*(wxColour*) object_pointer0_0)\n\n");
				#endif

				((wxPen_php*)native_object)->SetColour(*(wxColour*) object_pointer0_0);

				references->AddReference(colour0, "wxPen::SetColour at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

	if(overload1_called)
	{
		switch(arguments_received)
		{
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPen::SetColour((unsigned char) red1, (unsigned char) green1, (unsigned char) blue1)\n\n");
				#endif

				((wxPen_php*)native_object)->SetColour((unsigned char) red1, (unsigned char) green1, (unsigned char) blue1);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPen::SetColour\n");
	}
}
/* }}} */

/* {{{ proto  wxPen::SetJoin(wxPenJoin join_style)
   Sets the pen join style, which may be one of wxJOIN_BEVEL, wxJOIN_ROUND and wxJOIN_MITER. */
PHP_METHOD(php_wxPen, SetJoin)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPen::SetJoin\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPen* current_object;
	wxphp_object_type current_object_type;
	wxPen_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPen*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPen::SetJoin call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPEN_TYPE){
				references = &((wxPen_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long join_style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&join_style0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &join_style0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPen::SetJoin((wxPenJoin) join_style0)\n\n");
				#endif

				((wxPen_php*)native_object)->SetJoin((wxPenJoin) join_style0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPen::SetJoin\n");
	}
}
/* }}} */

/* {{{ proto  wxPen::SetStipple(wxBitmap stipple)
   Sets the bitmap for stippling. */
PHP_METHOD(php_wxPen, SetStipple)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPen::SetStipple\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPen* current_object;
	wxphp_object_type current_object_type;
	wxPen_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPen*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPen::SetStipple call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPEN_TYPE){
				references = &((wxPen_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* stipple0 = 0;
	wxBitmap* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O' (&stipple0, php_wxBitmap_entry)\n");
		#endif

		char parse_parameters_string[] = "O";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &stipple0, php_wxBitmap_entry ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(stipple0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxBitmap*) zend_object_store_get_object(stipple0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxBitmap*) zend_object_store_get_object(stipple0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxBitmap*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'stipple' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(stipple0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'stipple' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPen::SetStipple(*(wxBitmap*) object_pointer0_0)\n\n");
				#endif

				((wxPen_php*)native_object)->SetStipple(*(wxBitmap*) object_pointer0_0);

				references->AddReference(stipple0, "wxPen::SetStipple at call with 1 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPen::SetStipple\n");
	}
}
/* }}} */

/* {{{ proto  wxPen::SetStyle(wxPenStyle style)
   Set the pen style. */
PHP_METHOD(php_wxPen, SetStyle)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPen::SetStyle\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPen* current_object;
	wxphp_object_type current_object_type;
	wxPen_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPen*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPen::SetStyle call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPEN_TYPE){
				references = &((wxPen_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&style0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &style0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPen::SetStyle((wxPenStyle) style0)\n\n");
				#endif

				((wxPen_php*)native_object)->SetStyle((wxPenStyle) style0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPen::SetStyle\n");
	}
}
/* }}} */

/* {{{ proto  wxPen::SetWidth(int width)
   Sets the pen width. */
PHP_METHOD(php_wxPen, SetWidth)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPen::SetWidth\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPen* current_object;
	wxphp_object_type current_object_type;
	wxPen_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPen*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPen::SetWidth call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPEN_TYPE){
				references = &((wxPen_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long width0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&width0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &width0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPen::SetWidth((int) width0)\n\n");
				#endif

				((wxPen_php*)native_object)->SetWidth((int) width0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPen::SetWidth\n");
	}
}
/* }}} */

/* {{{ proto  wxPen::SetCap(wxPenCap capStyle)
   Sets the pen cap style, which may be one of wxCAP_ROUND, wxCAP_PROJECTING and wxCAP_BUTT. */
PHP_METHOD(php_wxPen, SetCap)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPen::SetCap\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPen* current_object;
	wxphp_object_type current_object_type;
	wxPen_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPen*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPen::SetCap call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPEN_TYPE){
				references = &((wxPen_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	long capStyle0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'l' (&capStyle0)\n");
		#endif

		char parse_parameters_string[] = "l";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &capStyle0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPen::SetCap((wxPenCap) capStyle0)\n\n");
				#endif

				((wxPen_php*)native_object)->SetCap((wxPenCap) capStyle0);


				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPen::SetCap\n");
	}
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxPenList_free(void *object TSRMLS_DC) 
{
    zo_wxPenList* custom_object = (zo_wxPenList*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPenList_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxPenList done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxPenList_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxPenList_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxPenList* custom_object;
    custom_object = (zo_wxPenList*) emalloc(sizeof(zo_wxPenList));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxPenList_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXPENLIST_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto wxPen wxPenList::FindOrCreatePen(wxColour colour, int width, wxPenStyle style)
   Finds a pen with the specified attributes and returns it, else creates a new pen, adds it to the pen list, and returns it. */
PHP_METHOD(php_wxPenList, FindOrCreatePen)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPenList::FindOrCreatePen\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPenList* current_object;
	wxphp_object_type current_object_type;
	wxPenList_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxPenList*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxPenList::FindOrCreatePen call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXPENLIST_TYPE){
				references = &((wxPenList_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* colour0 = 0;
	wxColour* object_pointer0_0 = 0;
	long width0;
	long style0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received >= 1  && arguments_received <= 3)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'O|ll' (&colour0, php_wxColour_entry, &width0, &style0)\n");
		#endif

		char parse_parameters_string[] = "O|ll";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &colour0, php_wxColour_entry, &width0, &style0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(colour0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxColour*) zend_object_store_get_object(colour0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxColour*) argument_native_object;
					if (!object_pointer0_0 )
					{
						zend_error(E_ERROR, "Parameter 'colour' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(colour0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'colour' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPenList::FindOrCreatePen(*(wxColour*) object_pointer0_0) to return object pointer\n\n");
				#endif

				wxPen_php* value_to_return1;
				value_to_return1 = (wxPen_php*) ((wxPenList_php*)native_object)->FindOrCreatePen(*(wxColour*) object_pointer0_0);

				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxPen_entry);
					((zo_wxPen*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPen_php*) value_to_return1;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return1 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxPenList::FindOrCreatePen at call with 1 argument(s)");
				}

				references->AddReference(colour0, "wxPenList::FindOrCreatePen at call with 1 argument(s)");

				return;
				break;
			}
			case 2:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPenList::FindOrCreatePen(*(wxColour*) object_pointer0_0, (int) width0) to return object pointer\n\n");
				#endif

				wxPen_php* value_to_return2;
				value_to_return2 = (wxPen_php*) ((wxPenList_php*)native_object)->FindOrCreatePen(*(wxColour*) object_pointer0_0, (int) width0);

				if(value_to_return2 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return2->references.IsUserInitialized()){
					if(value_to_return2->phpObj != NULL){
						*return_value = *value_to_return2->phpObj;
						zval_add_ref(&value_to_return2->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxPen_entry);
					((zo_wxPen*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPen_php*) value_to_return2;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return2 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxPenList::FindOrCreatePen at call with 2 argument(s)");
				}

				references->AddReference(colour0, "wxPenList::FindOrCreatePen at call with 2 argument(s)");

				return;
				break;
			}
			case 3:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing wxPenList::FindOrCreatePen(*(wxColour*) object_pointer0_0, (int) width0, (wxPenStyle) style0) to return object pointer\n\n");
				#endif

				wxPen_php* value_to_return3;
				value_to_return3 = (wxPen_php*) ((wxPenList_php*)native_object)->FindOrCreatePen(*(wxColour*) object_pointer0_0, (int) width0, (wxPenStyle) style0);

				if(value_to_return3 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return3->references.IsUserInitialized()){
					if(value_to_return3->phpObj != NULL){
						*return_value = *value_to_return3->phpObj;
						zval_add_ref(&value_to_return3->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxPen_entry);
					((zo_wxPen*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxPen_php*) value_to_return3;
				}

				if(Z_TYPE_P(return_value) != IS_NULL && (void*)value_to_return3 != (void*)native_object && return_is_user_initialized){
					references->AddReference(return_value, "wxPenList::FindOrCreatePen at call with 3 argument(s)");
				}

				references->AddReference(colour0, "wxPenList::FindOrCreatePen at call with 3 argument(s)");

				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxPenList::FindOrCreatePen\n");
	}
}
/* }}} */

/* {{{ proto  wxPenList::wxPenList()
   Constructor. */
PHP_METHOD(php_wxPenList, __construct)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxPenList::__construct\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxPenList* current_object;
	wxPenList_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	int arguments_received = ZEND_NUM_ARGS();
	
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Executing __construct()\n");
				#endif

				native_object = new wxPenList_php();

				native_object->references.Initialize();
				break;
			}
		}
	}

		
	if(already_called)
	{
		native_object->phpObj = getThis();
		

		current_object = (zo_wxPenList*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		current_object->native_object = native_object;
		
		current_object->is_user_initialized = 1;
		
		#ifdef ZTS 
		native_object->TSRMLS_C = TSRMLS_C;
		#endif
	}
	else
	{
		zend_error(E_ERROR, "Abstract class or wrong type/count of parameters passed to: wxPenList::__construct\n");
	}
	
	#ifdef USE_WXPHP_DEBUG
		php_printf("===========================================\n\n");
	#endif
}
/* }}} */

BEGIN_EXTERN_C()
void php_wxRendererNative_free(void *object TSRMLS_DC) 
{
    zo_wxRendererNative* custom_object = (zo_wxRendererNative*) object;
    
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxRendererNative_free on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	if(custom_object->native_object != NULL)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Pointer not null\n");
		php_printf("Pointer address %x\n", (unsigned int)(size_t)custom_object->native_object);
		#endif
		
		if(custom_object->is_user_initialized)
		{
			#ifdef USE_WXPHP_DEBUG
			php_printf("Deleting pointer with delete\n");
			#endif
			
       
            delete custom_object->native_object;
			
			custom_object->native_object = NULL;
		}
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Deletion of wxRendererNative done\n");
		php_printf("===========================================\n\n");
		#endif
	}
	else
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Not user space initialized\n");
		#endif
	}

	zend_object_std_dtor(&custom_object->zo TSRMLS_CC);
    efree(custom_object);
}

zend_object_value php_wxRendererNative_new(zend_class_entry *class_type TSRMLS_DC)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Calling php_wxRendererNative_new on %s at line %i\n", zend_get_executed_filename(TSRMLS_C), zend_get_executed_lineno(TSRMLS_C));
	php_printf("===========================================\n");
	#endif
	
	zval *temp;
    zend_object_value retval;
    zo_wxRendererNative* custom_object;
    custom_object = (zo_wxRendererNative*) emalloc(sizeof(zo_wxRendererNative));

    zend_object_std_init(&custom_object->zo, class_type TSRMLS_CC);

#if PHP_VERSION_ID < 50399
	ALLOC_HASHTABLE(custom_object->zo.properties);
    zend_hash_init(custom_object->zo.properties, 0, NULL, ZVAL_PTR_DTOR, 0);
    zend_hash_copy(custom_object->zo.properties, &class_type->default_properties, (copy_ctor_func_t) zval_add_ref,(void *) &temp, sizeof(zval *));
#else
	object_properties_init(&custom_object->zo, class_type);
#endif

	retval.handle = zend_objects_store_put(custom_object, NULL, php_wxRendererNative_free, NULL TSRMLS_CC);
	retval.handlers = zend_get_std_object_handlers();

    custom_object->native_object = NULL;
	custom_object->object_type = PHP_WXRENDERERNATIVE_TYPE;
	custom_object->is_user_initialized = 0;
	
    return retval;
}
END_EXTERN_C()

/* {{{ proto  wxRendererNative::DrawCheckBox(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a check box. */
void wxRendererNative_php::DrawCheckBox(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxRendererNative::DrawCheckBox\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawCheckBox", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) win;
	object_init_ex(arguments[1], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	ZVAL_LONG(arguments[3], flags);
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawCheckBox", 12, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxRendererNative::DrawCheckBox'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxRendererNative::DrawChoice(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a native wxChoice. */
void wxRendererNative_php::DrawChoice(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxRendererNative::DrawChoice\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawChoice", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) win;
	object_init_ex(arguments[1], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	ZVAL_LONG(arguments[3], flags);
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawChoice", 10, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxRendererNative::DrawChoice'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxRendererNative::DrawComboBox(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a native wxComboBox. */
void wxRendererNative_php::DrawComboBox(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxRendererNative::DrawComboBox\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawComboBox", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) win;
	object_init_ex(arguments[1], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	ZVAL_LONG(arguments[3], flags);
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawComboBox", 12, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxRendererNative::DrawComboBox'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxRendererNative::DrawComboBoxDropButton(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a button like the one used by wxComboBox to show a drop down window. */
void wxRendererNative_php::DrawComboBoxDropButton(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxRendererNative::DrawComboBoxDropButton\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawComboBoxDropButton", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) win;
	object_init_ex(arguments[1], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	ZVAL_LONG(arguments[3], flags);
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawComboBoxDropButton", 22, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxRendererNative::DrawComboBoxDropButton'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxRendererNative::DrawDropArrow(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a drop down arrow that is suitable for use outside a combo box. */
void wxRendererNative_php::DrawDropArrow(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxRendererNative::DrawDropArrow\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawDropArrow", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) win;
	object_init_ex(arguments[1], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	ZVAL_LONG(arguments[3], flags);
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawDropArrow", 13, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxRendererNative::DrawDropArrow'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxRendererNative::DrawFocusRect(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a focus rectangle using the specified rectangle. */
void wxRendererNative_php::DrawFocusRect(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxRendererNative::DrawFocusRect\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawFocusRect", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) win;
	object_init_ex(arguments[1], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	ZVAL_LONG(arguments[3], flags);
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawFocusRect", 13, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxRendererNative::DrawFocusRect'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxRendererNative::DrawPushButton(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a blank push button that looks very similar to wxButton. */
void wxRendererNative_php::DrawPushButton(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxRendererNative::DrawPushButton\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawPushButton", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) win;
	object_init_ex(arguments[1], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	ZVAL_LONG(arguments[3], flags);
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawPushButton", 14, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxRendererNative::DrawPushButton'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxRendererNative::DrawItemSelectionRect(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a selection rectangle underneath the text as used e.g. */
void wxRendererNative_php::DrawItemSelectionRect(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxRendererNative::DrawItemSelectionRect\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawItemSelectionRect", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) win;
	object_init_ex(arguments[1], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	ZVAL_LONG(arguments[3], flags);
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawItemSelectionRect", 21, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxRendererNative::DrawItemSelectionRect'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxRendererNative::DrawRadioBitmap(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a native wxRadioButton bitmap. */
void wxRendererNative_php::DrawRadioBitmap(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxRendererNative::DrawRadioBitmap\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawRadioBitmap", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) win;
	object_init_ex(arguments[1], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	ZVAL_LONG(arguments[3], flags);
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawRadioBitmap", 15, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxRendererNative::DrawRadioBitmap'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxRendererNative::DrawSplitterBorder(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw the border for sash window: this border must be such that the sash drawn by DrawSplitterSash() blends into it well. */
void wxRendererNative_php::DrawSplitterBorder(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxRendererNative::DrawSplitterBorder\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawSplitterBorder", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) win;
	object_init_ex(arguments[1], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	ZVAL_LONG(arguments[3], flags);
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawSplitterBorder", 18, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxRendererNative::DrawSplitterBorder'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxRendererNative::DrawSplitterSash(wxWindow &win, wxDC &dc, wxSize size, int position, wxOrientation orient, int flags)
   Draw a sash. */
void wxRendererNative_php::DrawSplitterSash(wxWindow* win, wxDC& dc, const wxSize& size, wxCoord position, wxOrientation orient, int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxRendererNative::DrawSplitterSash\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[6];
	zval *arguments[6];
	
	//Initilize arguments array
	for(int i=0; i<6; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawSplitterSash", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) win;
	object_init_ex(arguments[1], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[2], php_wxSize_entry);
	((zo_wxSize*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxSize_php*) &size;
	ZVAL_LONG(arguments[3], position);
	ZVAL_LONG(arguments[4], orient);
	ZVAL_LONG(arguments[5], flags);
		
	for(int i=0; i<6; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawSplitterSash", 16, &return_value, 6, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<6; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxRendererNative::DrawSplitterSash'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxRendererNative::DrawTextCtrl(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw a native wxTextCtrl frame. */
void wxRendererNative_php::DrawTextCtrl(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxRendererNative::DrawTextCtrl\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawTextCtrl", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) win;
	object_init_ex(arguments[1], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	ZVAL_LONG(arguments[3], flags);
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawTextCtrl", 12, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxRendererNative::DrawTextCtrl'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto  wxRendererNative::DrawTreeItemButton(wxWindow &win, wxDC &dc, wxRect rect, int flags)
   Draw the expanded/collapsed icon for a tree control item. */
void wxRendererNative_php::DrawTreeItemButton(wxWindow* win, wxDC& dc, const wxRect& rect, int flags)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxRendererNative::DrawTreeItemButton\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[4];
	zval *arguments[4];
	
	//Initilize arguments array
	for(int i=0; i<4; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "DrawTreeItemButton", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) win;
	object_init_ex(arguments[1], php_wxDC_entry);
	((zo_wxDC*) zend_object_store_get_object(arguments[1] TSRMLS_CC))->native_object = (wxDC_php*) &dc;
	object_init_ex(arguments[2], php_wxRect_entry);
	((zo_wxRect*) zend_object_store_get_object(arguments[2] TSRMLS_CC))->native_object = (wxRect_php*) &rect;
	ZVAL_LONG(arguments[3], flags);
		
	for(int i=0; i<4; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "DrawTreeItemButton", 18, &return_value, 4, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<4; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxRendererNative::DrawTreeItemButton'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return;
	
}
/* }}} */

/* {{{ proto wxRendererNative wxRendererNative::Get()
   Return the currently used renderer. */
PHP_METHOD(php_wxRendererNative, Get)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRendererNative::Get\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRendererNative* current_object;
	wxphp_object_type current_object_type;
	wxRendererNative_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRendererNative*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRendererNative::Get call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRENDERERNATIVE_TYPE){
				references = &((wxRendererNative_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxRendererNative::Get() to return object reference\n\n");
				#endif

				wxRendererNative_php* value_to_return0;
				value_to_return0 = (wxRendererNative_php*) &wxRendererNative::Get();
				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxRendererNative_entry);
					((zo_wxRendererNative*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRendererNative_php*) value_to_return0;
				}



				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRendererNative::Get\n");
	}
}
/* }}} */

/* {{{ proto wxSize wxRendererNative::GetCheckBoxSize(wxWindow &win)
   Returns the size of a check box. */
wxSize wxRendererNative_php::GetCheckBoxSize(wxWindow* win)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxRendererNative::GetCheckBoxSize\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetCheckBoxSize", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) win;
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetCheckBoxSize", 15, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxRendererNative::GetCheckBoxSize'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	if(Z_TYPE_P(return_value) == IS_OBJECT)
	{
		return_object = (void*) ((zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object;
	}

	//Threat it as a normal object on the calling function and not a php user space intiialized one
	((zo_wxSize*) zend_object_store_get_object(return_value TSRMLS_CC))->is_user_initialized = 0;
	wxSize_php* var = (wxSize_php*) return_object;
	var->references.UnInitialize();

	return *(wxSize*) return_object;
	
}
/* }}} */

/* {{{ proto wxRendererNative wxRendererNative::GetDefault()
   Return the default (native) implementation for this platform  this is also the one used by default but this may be changed by calling Set() in which case the return value of this method may be different from the return value of Get(). */
PHP_METHOD(php_wxRendererNative, GetDefault)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRendererNative::GetDefault\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRendererNative* current_object;
	wxphp_object_type current_object_type;
	wxRendererNative_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRendererNative*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRendererNative::GetDefault call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRENDERERNATIVE_TYPE){
				references = &((wxRendererNative_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxRendererNative::GetDefault() to return object reference\n\n");
				#endif

				wxRendererNative_php* value_to_return0;
				value_to_return0 = (wxRendererNative_php*) &wxRendererNative::GetDefault();
				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxRendererNative_entry);
					((zo_wxRendererNative*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRendererNative_php*) value_to_return0;
				}



				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRendererNative::GetDefault\n");
	}
}
/* }}} */

/* {{{ proto wxRendererNative wxRendererNative::GetGeneric()
   Return the generic implementation of the renderer. */
PHP_METHOD(php_wxRendererNative, GetGeneric)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRendererNative::GetGeneric\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRendererNative* current_object;
	wxphp_object_type current_object_type;
	wxRendererNative_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRendererNative*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRendererNative::GetGeneric call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRENDERERNATIVE_TYPE){
				references = &((wxRendererNative_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 0)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with '' ()\n");
		#endif

		overload0_called = true;
		already_called = true;
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 0:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxRendererNative::GetGeneric() to return object reference\n\n");
				#endif

				wxRendererNative_php* value_to_return0;
				value_to_return0 = (wxRendererNative_php*) &wxRendererNative::GetGeneric();
				if(value_to_return0->references.IsUserInitialized()){
					if(value_to_return0->phpObj != NULL){
						*return_value = *value_to_return0->phpObj;
						zval_add_ref(&value_to_return0->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value,php_wxRendererNative_entry);
					((zo_wxRendererNative*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRendererNative_php*) value_to_return0;
				}



				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRendererNative::GetGeneric\n");
	}
}
/* }}} */

/* {{{ proto int wxRendererNative::GetHeaderButtonHeight(wxWindow &win)
   Returns the height of a header button, either a fixed platform height if available, or a generic height based on the win window's font. */
int wxRendererNative_php::GetHeaderButtonHeight(wxWindow* win)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxRendererNative::GetHeaderButtonHeight\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetHeaderButtonHeight", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) win;
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetHeaderButtonHeight", 21, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxRendererNative::GetHeaderButtonHeight'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (int) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto int wxRendererNative::GetHeaderButtonMargin(wxWindow &win)
   Returns the horizontal margin on the left and right sides of header button's label. */
int wxRendererNative_php::GetHeaderButtonMargin(wxWindow* win)
{
	static zend_function* cached_function = NULL;
	static bool is_php_user_space_implemented = true;
	
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking virtual wxRendererNative::GetHeaderButtonMargin\n");
	php_printf("===========================================\n");
	#endif
	
	zval** params[1];
	zval *arguments[1];
	
	//Initilize arguments array
	for(int i=0; i<1; i++)
	{
		ALLOC_INIT_ZVAL(arguments[i]);
	}

	zval* return_value;
	MAKE_STD_ZVAL(return_value);
	zval function_name;
	ZVAL_STRING(&function_name, "GetHeaderButtonMargin", 0);
	char* temp_string;
	void* return_object;
	int function_called;
	
	//Parameters for conversion
	object_init_ex(arguments[0], php_wxWindow_entry);
	((zo_wxWindow*) zend_object_store_get_object(arguments[0] TSRMLS_CC))->native_object = (wxWindow_php*) win;
		
	for(int i=0; i<1; i++)
	{
		params[i] = &arguments[i];
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Trying to call user defined method\n");
	#endif
	
	if(is_php_user_space_implemented)
	{
		function_called = wxphp_call_method((zval**) &this->phpObj, NULL, &cached_function, "GetHeaderButtonMargin", 21, &return_value, 1, params TSRMLS_CC);
	}
	else
	{
		function_called = FAILURE;
	}
    
    	
	//Delete already used parameters from memory
	for(int i=0; i<1; i++)
	{
		zval_ptr_dtor(&arguments[i]);
	}
	
	if(function_called == FAILURE)
	{
		is_php_user_space_implemented = false;
		
		#ifdef USE_WXPHP_DEBUG
		php_printf("Invocation of user defined method failed\n");
		#endif
		
		wxMessageBox("Failed to call virtual method 'wxRendererNative::GetHeaderButtonMargin'!", "Error", wxOK|wxICON_ERROR);
	}

	#ifdef USE_WXPHP_DEBUG
	php_printf("Returning userspace value.\n");
	#endif
		
	return (int) Z_LVAL_P(return_value);
	
}
/* }}} */

/* {{{ proto wxRendererNative wxRendererNative::Load(string name)
   Load the renderer from the specified DLL, the returned pointer must be deleted by caller if not NULL when it is not used any more. */
PHP_METHOD(php_wxRendererNative, Load)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRendererNative::Load\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRendererNative* current_object;
	wxphp_object_type current_object_type;
	wxRendererNative_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRendererNative*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRendererNative::Load call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRENDERERNATIVE_TYPE){
				references = &((wxRendererNative_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	char* name0;
	long name_len0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 's' (&name0, &name_len0)\n");
		#endif

		char parse_parameters_string[] = "s";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &name0, &name_len0 ) == SUCCESS)
		{
			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxRendererNative::Load(wxString(name0, wxConvUTF8)) to return object pointer\n\n");
				#endif

				wxRendererNative_php* value_to_return1;
				value_to_return1 = (wxRendererNative_php*) wxRendererNative::Load(wxString(name0, wxConvUTF8));
				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxRendererNative_entry);
					((zo_wxRendererNative*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRendererNative_php*) value_to_return1;
				}



				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRendererNative::Load\n");
	}
}
/* }}} */

/* {{{ proto wxRendererNative wxRendererNative::Set(wxRendererNative &renderer)
   Set the renderer to use, passing NULL reverts to using the default renderer (the global renderer must always exist). */
PHP_METHOD(php_wxRendererNative, Set)
{
	#ifdef USE_WXPHP_DEBUG
	php_printf("Invoking wxRendererNative::Set\n");
	php_printf("===========================================\n");
	#endif
	
	zo_wxRendererNative* current_object;
	wxphp_object_type current_object_type;
	wxRendererNative_php* native_object;
	void* argument_native_object = NULL;
	
	//Other variables used thru the code
	zval* dummy = NULL;
	bool already_called = false;
	wxPHPObjectReferences* references;
	int arguments_received = ZEND_NUM_ARGS();
	bool return_is_user_initialized = false;
	
	//Get native object of the php object that called the method
	if(getThis() != NULL) 
	{
		current_object = (zo_wxRendererNative*) zend_object_store_get_object(getThis() TSRMLS_CC);
		
		if(current_object->native_object == NULL)
		{
			zend_error(E_ERROR, "Failed to get the native object for wxRendererNative::Set call\n");
			
			return;
		}
		else
		{
			native_object = current_object->native_object;
			current_object_type = current_object->object_type;
			
			bool reference_type_found = false;

			if(current_object_type == PHP_WXRENDERERNATIVE_TYPE){
				references = &((wxRendererNative_php*)native_object)->references;
				reference_type_found = true;
			}
		}
	}
	#ifdef USE_WXPHP_DEBUG
	else
	{
		php_printf("Processing the method call as static\n");
	}
	#endif
	
	//Parameters for overload 0
	zval* renderer0 = 0;
	wxRendererNative* object_pointer0_0 = 0;
	bool overload0_called = false;
		
	//Overload 0
	overload0:
	if(!already_called && arguments_received == 1)
	{
		#ifdef USE_WXPHP_DEBUG
		php_printf("Parameters received %d\n", arguments_received);
		php_printf("Parsing parameters with 'z' (&renderer0)\n");
		#endif

		char parse_parameters_string[] = "z";
		if(zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, arguments_received TSRMLS_CC, parse_parameters_string, &renderer0 ) == SUCCESS)
		{
			if(arguments_received >= 1){
				if(Z_TYPE_P(renderer0) == IS_OBJECT)
				{
					wxphp_object_type argument_type = ((zo_wxRendererNative*) zend_object_store_get_object(renderer0 TSRMLS_CC))->object_type;
					argument_native_object = (void*) ((zo_wxRendererNative*) zend_object_store_get_object(renderer0 TSRMLS_CC))->native_object;
					object_pointer0_0 = (wxRendererNative*) argument_native_object;
					if (!object_pointer0_0 || (argument_type != PHP_WXRENDERERNATIVE_TYPE))
					{
						zend_error(E_ERROR, "Parameter 'renderer' could not be retreived correctly.");
					}
				}
				else if(Z_TYPE_P(renderer0) != IS_NULL)
				{
					zend_error(E_ERROR, "Parameter 'renderer' not null, could not be retreived correctly.");
				}
			}

			overload0_called = true;
			already_called = true;
		}
	}

		
	if(overload0_called)
	{
		switch(arguments_received)
		{
			case 1:
			{
				#ifdef USE_WXPHP_DEBUG
				php_printf("Static ");
				php_printf("Executing wxRendererNative::Set((wxRendererNative*) object_pointer0_0) to return object pointer\n\n");
				#endif

				wxRendererNative_php* value_to_return1;
				value_to_return1 = (wxRendererNative_php*) wxRendererNative::Set((wxRendererNative*) object_pointer0_0);
				if(value_to_return1 == NULL){
					ZVAL_NULL(return_value);
				}
				else if(value_to_return1->references.IsUserInitialized()){
					if(value_to_return1->phpObj != NULL){
						*return_value = *value_to_return1->phpObj;
						zval_add_ref(&value_to_return1->phpObj);
						return_is_user_initialized = true;
					}
					else{
						zend_error(E_ERROR, "Could not retreive original zval.");
					}
				}
				else{
					object_init_ex(return_value, php_wxRendererNative_entry);
					((zo_wxRendererNative*) zend_object_store_get_object(return_value TSRMLS_CC))->native_object = (wxRendererNative_php*) value_to_return1;
				}



				return;
				break;
			}
		}
	}

		
	//In case wrong type/count of parameters was passed
	if(!already_called)
	{
		zend_error(E_ERROR, "Wrong type or count of parameters passed to: wxRendererNative::Set\n");
	}
}
/* }}} */

