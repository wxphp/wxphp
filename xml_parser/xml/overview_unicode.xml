<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.7.4">
  <compounddef id="overview_unicode" kind="page">
    <compoundname>overview_unicode</compoundname>
    <title>Unicode Support in wxWidgets</title>
    <detaileddescription>
<para>This section describes how does wxWidgets support Unicode and how can it affect your programs.</para><para>Notice that Unicode support has changed radically in wxWidgets 3.0 and a lot of existing material pertaining to the previous versions of the library is not correct any more. Please see <ref refid="overview_changes_since28_1overview_changes_unicode" kindref="member">Unicode-related Changes</ref> for the details of these changes.</para><para>You can skip the first two sections if you&apos;re already familiar with Unicode and wish to jump directly in the details of its support in the library: <itemizedlist>
<listitem><para><ref refid="overview_unicode_1overview_unicode_what" kindref="member">What is Unicode?</ref> </para></listitem>
<listitem><para><ref refid="overview_unicode_1overview_unicode_encodings" kindref="member">Unicode Representations and Terminology</ref> </para></listitem>
<listitem><para><ref refid="overview_unicode_1overview_unicode_supportin" kindref="member">Unicode Support in wxWidgets</ref> </para></listitem>
<listitem><para><ref refid="overview_unicode_1overview_unicode_pitfalls" kindref="member">Potential Unicode Pitfalls</ref> </para></listitem>
<listitem><para><ref refid="overview_unicode_1overview_unicode_supportout" kindref="member">Unicode and the Outside World</ref> </para></listitem>
<listitem><para><ref refid="overview_unicode_1overview_unicode_settings" kindref="member">Unicode Related Compilation Settings</ref></para></listitem>
</itemizedlist>
<hruler/>
</para><sect1 id="overview_unicode_1overview_unicode_what">
<title>What is Unicode?</title>
<para>Unicode is a standard for character encoding which addresses the shortcomings of the previous standards (e.g. the ASCII standard), by using 8, 16 or 32 bits for encoding each character. This allows enough code points (see below for the definition) sufficient to encode all of the world languages at once. More details about Unicode may be found at <ulink url="http://www.unicode.org/.">http://www.unicode.org/.</ulink></para><para>From a practical point of view, using Unicode is almost a requirement when writing applications for international audience. Moreover, any application reading files which it didn&apos;t produce or receiving data from the network from other services should be ready to deal with Unicode.</para></sect1>
<sect1 id="overview_unicode_1overview_unicode_encodings">
<title>Unicode Representations and Terminology</title>
<para>When working with Unicode, it&apos;s important to define the meaning of some terms.</para><para>A <bold><emphasis>glyph</emphasis></bold> is a particular image (usually part of a font) that represents a character or part of a character. Any character may have one or more glyph associated; e.g. some of the possible glyphs for the capital letter &apos;A&apos; are:</para><para><image type="html" name="overview_unicode_glyphs.png"></image>
</para><para>Unicode assigns each character of almost any existing alphabet/script a number, which is called <bold><emphasis>code point</emphasis></bold>; it&apos;s typically indicated in documentation manuals and in the Unicode website as <computeroutput>U+xxxx</computeroutput> where <computeroutput>xxxx</computeroutput> is an hexadecimal number.</para><para>Note that typically one character is assigned exactly one code point, but there are exceptions; the so-called <emphasis>precomposed characters</emphasis> (see <ulink url="http://en.wikipedia.org/wiki/Precomposed_character">http://en.wikipedia.org/wiki/Precomposed_character</ulink>) or the <emphasis>ligatures</emphasis>. In these cases a single &quot;character&quot; may be mapped to more than one code point or viceversa more characters may be mapped to a single code point.</para><para>The Unicode standard divides the space of all possible code points in <bold><emphasis>planes</emphasis></bold>; a plane is a range of 65,536 (1000016) contiguous Unicode code points. Planes are numbered from 0 to 16, where the first one is the <emphasis>BMP</emphasis>, or Basic Multilingual Plane. The BMP contains characters for all modern languages, and a large number of special characters. The other planes in fact contain mainly historic scripts, special-purpose characters or are unused.</para><para>Code points are represented in computer memory as a sequence of one or more <bold><emphasis>code units</emphasis></bold>, where a code unit is a unit of memory: 8, 16, or 32 bits. More precisely, a code unit is the minimal bit combination that can represent a unit of encoded text for processing or interchange.</para><para>The <bold><emphasis>UTF</emphasis></bold> or Unicode Transformation Formats are algorithms mapping the Unicode code points to code unit sequences. The simplest of them is <bold>UTF-32</bold> where each code unit is composed by 32 bits (4 bytes) and each code point is always represented by a single code unit (fixed length encoding). (Note that even UTF-32 is still not completely trivial as the mapping is different for little and big-endian architectures). UTF-32 is commonly used under Unix systems for internal representation of Unicode strings.</para><para>Another very widespread standard is <bold>UTF-16</bold> which is used by Microsoft Windows: it encodes the first (approximately) 64 thousands of Unicode code points (the BMP plane) using 16-bit code units (2 bytes) and uses a pair of 16-bit code units to encode the characters beyond this. These pairs are called <emphasis>surrogate</emphasis>. Thus UTF16 uses a variable number of code units to encode each code point.</para><para>Finally, the most widespread encoding used for the external Unicode storage (e.g. files and network protocols) is <bold>UTF-8</bold> which is byte-oriented and so avoids the endianness ambiguities of UTF-16 and UTF-32. UTF-8 uses code units of 8 bits (1 byte); code points beyond the usual english alphabet are represented using a variable number of bytes, which makes it less efficient than UTF-32 for internal representation.</para><para>As visual aid to understand the differences between the various concepts described so far, look at the different UTF representations of the same code point:</para><para><image type="html" name="overview_unicode_codes.png"></image>
</para><para>In this particular case UTF8 requires more space than UTF16 (3 bytes instead of 2).</para><para>Note that from the C/C++ programmer perspective the situation is further complicated by the fact that the standard type <computeroutput>wchar_t</computeroutput> which is usually used to represent the Unicode (&quot;wide&quot;) strings in C/C++ doesn&apos;t have the same size on all platforms. It is 4 bytes under Unix systems, corresponding to the tradition of using UTF-32, but only 2 bytes under Windows which is required by compatibility with the OS which uses UTF-16.</para><para>Typically when UTF8 is used, code units are stored into <computeroutput>char</computeroutput> types, since <computeroutput>char</computeroutput> are 8bit wide on almost all systems; when using UTF16 typically code units are stored into <computeroutput>wchar_t</computeroutput> types since <computeroutput>wchar_t</computeroutput> is at least 16bits on all systems. This is also the approach used by <ref refid="classwx_string" kindref="compound">wxString</ref>. See <ref refid="overview_string" kindref="compound">wxString Overview</ref> for more info.</para><para>See also <ulink url="http://unicode.org/glossary/">http://unicode.org/glossary/</ulink> for the official definitions of the terms reported above.</para></sect1>
<sect1 id="overview_unicode_1overview_unicode_supportin">
<title>Unicode Support in wxWidgets</title>
<para>Since wxWidgets 3.0 Unicode support is always enabled and building the library without it is not recommended any longer and will cease to be supported in the near future. This means that internally only Unicode strings are used and that, under Microsoft Windows, Unicode system API is used which means that wxWidgets programs require the Microsoft Layer for Unicode to run on Windows 95/98/ME.</para><para>However, unlike the Unicode build mode of the previous versions of wxWidgets, this support is mostly transparent: you can still continue to work with the <bold>narrow</bold> (i.e. current locale-encoded <computeroutput>char*</computeroutput>) strings even if <bold>wide</bold> (i.e. UTF16-encoded <computeroutput>wchar_t*</computeroutput> or UTF8-encoded <computeroutput>char*</computeroutput>) strings are also supported. Any wxWidgets function accepts arguments of either type as both kinds of strings are implicitly converted to <ref refid="classwx_string" kindref="compound">wxString</ref>, so both <programlisting><codeline><highlight class="normal"><ref refid="group__group__funcmacro__dialog_1ga193c64ed4802e379799cdb42de252647" kindref="member" tooltip="Show a general purpose message dialog.">wxMessageBox</ref>(</highlight><highlight class="stringliteral">&quot;Hello,<sp/>world!&quot;</highlight><highlight class="normal">);</highlight></codeline>
</programlisting> and the somewhat less usual <programlisting><codeline><highlight class="normal"><ref refid="group__group__funcmacro__dialog_1ga193c64ed4802e379799cdb42de252647" kindref="member" tooltip="Show a general purpose message dialog.">wxMessageBox</ref>(L</highlight><highlight class="stringliteral">&quot;Salut<sp/>\u00E0<sp/>toi!&quot;</highlight><highlight class="normal">);<sp/></highlight><highlight class="comment">//<sp/>U+00E0<sp/>is<sp/>&quot;Latin<sp/>Small<sp/>Letter<sp/>a<sp/>with<sp/>Grave&quot;</highlight></codeline>
</programlisting> work as expected.</para><para>Notice that the narrow strings used with wxWidgets are <emphasis>always</emphasis> assumed to be in the current locale encoding, so writing <programlisting><codeline><highlight class="normal"><ref refid="group__group__funcmacro__dialog_1ga193c64ed4802e379799cdb42de252647" kindref="member" tooltip="Show a general purpose message dialog.">wxMessageBox</ref>(</highlight><highlight class="stringliteral">&quot;Salut<sp/>Ã <sp/>toi!&quot;</highlight><highlight class="normal">);</highlight></codeline>
</programlisting> wouldn&apos;t work if the encoding used on the user system is incompatible with ISO-8859-1 (or even if the sources were compiled under different locale in the case of gcc). In particular, the most common encoding used under modern Unix systems is UTF-8 and as the string above is not a valid UTF-8 byte sequence, nothing would be displayed at all in this case. Thus it is important to <bold>never use 8-bit (instead of 7-bit) characters directly in the program source</bold> but use wide strings or, alternatively, write: <programlisting><codeline><highlight class="normal"><ref refid="group__group__funcmacro__dialog_1ga193c64ed4802e379799cdb42de252647" kindref="member" tooltip="Show a general purpose message dialog.">wxMessageBox</ref>(<ref refid="classwx_string_1a2ddc1b7c8e1eb9adbf5874dead5b180b" kindref="member" tooltip="Converts C string encoded in UTF-8 to wxString.">wxString::FromUTF8</ref>(</highlight><highlight class="stringliteral">&quot;Salut<sp/>\xC3\xA0<sp/>toi!&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>in<sp/>UTF8<sp/>the<sp/>character<sp/>U+00E0<sp/>is<sp/>encoded<sp/>as<sp/>0xC3A0</highlight></codeline>
</programlisting></para><para>In a similar way, <ref refid="classwx_string" kindref="compound">wxString</ref> provides access to its contents as either <computeroutput>wchar_t</computeroutput> or <computeroutput>char</computeroutput> character buffer. Of course, the latter only works if the string contains data representable in the current locale encoding. This will always be the case if the string had been initially constructed from a narrow string or if it contains only 7-bit ASCII data but otherwise this conversion is not guaranteed to succeed. And as with <ref refid="classwx_string_1a2ddc1b7c8e1eb9adbf5874dead5b180b" kindref="member">wxString::FromUTF8()</ref> example above, you can always use <ref refid="classwx_string_1ac923e0bcfda57ec5064dcade9808db94" kindref="member">wxString::ToUTF8()</ref> to retrieve the string contents in UTF-8 encoding -- this, unlike converting to <computeroutput>char*</computeroutput> using the current locale, never fails.</para><para>For more info about how <ref refid="classwx_string" kindref="compound">wxString</ref> works, please see the <ref refid="overview_string" kindref="compound">wxString Overview</ref>.</para><para>To summarize, Unicode support in wxWidgets is mostly <bold>transparent</bold> for the application and if you use <ref refid="classwx_string" kindref="compound">wxString</ref> objects for storing all the character data in your program there is really nothing special to do. However you should be aware of the potential problems covered by the following section.</para></sect1>
<sect1 id="overview_unicode_1overview_unicode_pitfalls">
<title>Potential Unicode Pitfalls</title>
<para>The problems can be separated into three broad classes:</para><sect2 id="overview_unicode_1overview_unicode_compilation_errors">
<title>Unicode-Related Compilation Errors</title>
<para>Because of the need to support implicit conversions to both <computeroutput>char</computeroutput> and <computeroutput>wchar_t</computeroutput>, <ref refid="classwx_string" kindref="compound">wxString</ref> implementation is rather involved and many of its operators don&apos;t return the types which they could be naively expected to return. For example, the <computeroutput>operator</computeroutput>[] doesn&apos;t return neither a <computeroutput>char</computeroutput> nor a <computeroutput>wchar_t</computeroutput> but an object of a helper class <ref refid="classwx_uni_char" kindref="compound">wxUniChar</ref> or <ref refid="classwx_uni_char_ref" kindref="compound">wxUniCharRef</ref> which is implicitly convertible to either. Usually you don&apos;t need to worry about this as the conversions do their work behind the scenes however in some cases it doesn&apos;t work. Here are some examples, using a <ref refid="classwx_string" kindref="compound">wxString</ref> object <computeroutput>s</computeroutput> and some integer <computeroutput>n:</computeroutput> </para><para><itemizedlist>
<listitem><para>Writing <programlisting><codeline><highlight class="normal"><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(<sp/>s[n]<sp/>)<sp/></highlight></codeline>
</programlisting> doesn&apos;t work because the argument of the switch statement must be an integer expression so you need to replace <computeroutput>s</computeroutput>[n] with <programlisting><codeline><highlight class="normal"><sp/>s[n].GetValue()<sp/></highlight></codeline>
</programlisting>. You may also force the conversion to <computeroutput>char</computeroutput> or <computeroutput>wchar_t</computeroutput> by using an explicit cast but beware that converting the value to char uses the conversion to current locale and may return 0 if it fails. Finally notice that writing <programlisting><codeline><highlight class="normal"><sp/>(<ref refid="group__group__funcmacro__string_1gad42f64d8c82f1ce4ae58773a89b2d6a7" kindref="member" tooltip="wxChar is defined to be">wxChar</ref>)s[n]<sp/></highlight></codeline>
</programlisting> works both with wxWidgets 3.0 and previous library versions and so should be used for writing code which should be compatible with both 2.8 and 3.0.</para></listitem></itemizedlist>
</para><para><itemizedlist>
<listitem><para>Similarly, <programlisting><codeline><highlight class="normal"><sp/>&amp;s[n]<sp/></highlight></codeline>
</programlisting> doesn&apos;t yield a pointer to char so you may not pass it to functions expecting <computeroutput>char*</computeroutput> or <computeroutput>wchar_t*</computeroutput>. Consider using string iterators instead if possible or replace this expression with <programlisting><codeline><highlight class="normal"><sp/>s.<ref refid="classwx_string_1a6418ec90c6d4ffe0b05702be1b35df4f" kindref="member" tooltip="Returns a lightweight intermediate class which is in turn implicitly convertible to both const char* ...">c_str</ref>()<sp/>+<sp/>n<sp/></highlight></codeline>
</programlisting> otherwise.</para></listitem></itemizedlist>
</para><para>Another class of problems is related to the fact that the value returned by <computeroutput>c_str()</computeroutput> itself is also not just a pointer to a buffer but a value of helper class wxCStrData which is implicitly convertible to both narrow and wide strings. Again, this mostly will be unnoticeable but can result in some problems:</para><para><itemizedlist>
<listitem><para>You shouldn&apos;t pass <computeroutput>c_str()</computeroutput> result to vararg functions such as standard <computeroutput>printf()</computeroutput>. Some compilers (notably g++) warn about this but even if they don&apos;t, this <programlisting><codeline><highlight class="normal"><sp/>printf(</highlight><highlight class="stringliteral">&quot;Hello,<sp/>%s&quot;</highlight><highlight class="normal">,<sp/>s.<ref refid="classwx_string_1a6418ec90c6d4ffe0b05702be1b35df4f" kindref="member" tooltip="Returns a lightweight intermediate class which is in turn implicitly convertible to both const char* ...">c_str</ref>())<sp/></highlight></codeline>
</programlisting> is not going to work. It can be corrected in one of the following ways:</para></listitem></itemizedlist>
</para><para><itemizedlist>
<listitem><para>Preferred: <programlisting><codeline><highlight class="normal"><sp/>wxPrintf(</highlight><highlight class="stringliteral">&quot;Hello,<sp/>%s&quot;</highlight><highlight class="normal">,<sp/>s)<sp/></highlight></codeline>
</programlisting> (notice the absence of <computeroutput>c_str()</computeroutput>, it is not needed at all with wxWidgets functions)</para></listitem><listitem><para>Compatible with wxWidgets 2.8: <programlisting><codeline><highlight class="normal"><sp/>wxPrintf(</highlight><highlight class="stringliteral">&quot;Hello,<sp/>%s&quot;</highlight><highlight class="normal">,<sp/>s.<ref refid="classwx_string_1a6418ec90c6d4ffe0b05702be1b35df4f" kindref="member" tooltip="Returns a lightweight intermediate class which is in turn implicitly convertible to both const char* ...">c_str</ref>())<sp/></highlight></codeline>
</programlisting></para></listitem><listitem><para>Using an explicit conversion to narrow, multibyte, string: <programlisting><codeline><highlight class="normal"><sp/>printf(</highlight><highlight class="stringliteral">&quot;Hello,<sp/>%s&quot;</highlight><highlight class="normal">,<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*)s.<ref refid="classwx_string_1adcfd12e6d0765b1d74bccc3d63d02e98" kindref="member" tooltip="Returns the multibyte (C string) representation of the string using conv&amp;#39;s wxMBConv::cWC2MB method an...">mb_str</ref>())<sp/></highlight></codeline>
</programlisting></para></listitem><listitem><para>Using a cast to force the issue (listed only for completeness): <programlisting><codeline><highlight class="normal"><sp/>printf(</highlight><highlight class="stringliteral">&quot;Hello,<sp/>%s&quot;</highlight><highlight class="normal">,<sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*)s.<ref refid="classwx_string_1a6418ec90c6d4ffe0b05702be1b35df4f" kindref="member" tooltip="Returns a lightweight intermediate class which is in turn implicitly convertible to both const char* ...">c_str</ref>())<sp/></highlight></codeline>
</programlisting></para></listitem></itemizedlist>
</para><para><itemizedlist>
<listitem><para>The result of <computeroutput>c_str()</computeroutput> cannot be cast to <computeroutput>char*</computeroutput> but only to <computeroutput>const</computeroutput> <computeroutput><computeroutput>char*</computeroutput>.</computeroutput> Of course, modifying the string via the pointer returned by this method has never been possible but unfortunately it was occasionally useful to use a <computeroutput>const_cast</computeroutput> here to pass the value to const-incorrect functions. This can be done either using new <ref refid="classwx_string_1aedcaea87fc347a940263a533bd56846f" kindref="member">wxString::char_str()</ref> (and matching wchar_str()) method or by writing a double cast: <programlisting><codeline><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*)(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*)s.<ref refid="classwx_string_1a6418ec90c6d4ffe0b05702be1b35df4f" kindref="member" tooltip="Returns a lightweight intermediate class which is in turn implicitly convertible to both const char* ...">c_str</ref>()<sp/></highlight></codeline>
</programlisting></para></listitem></itemizedlist>
</para><para><itemizedlist>
<listitem><para>One of the unfortunate consequences of the possibility to pass <ref refid="classwx_string" kindref="compound">wxString</ref> to <computeroutput>wxPrintf()</computeroutput> without using <computeroutput>c_str()</computeroutput> is that it is now impossible to pass the elements of unnamed enumerations to <computeroutput>wxPrintf()</computeroutput> and other similar vararg functions, i.e. <programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">enum</highlight><highlight class="normal"><sp/>{<sp/>Red,<sp/>Green,<sp/>Blue<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>wxPrintf(</highlight><highlight class="stringliteral">&quot;Red<sp/>is<sp/>%d&quot;</highlight><highlight class="normal">,<sp/>Red);</highlight></codeline>
</programlisting> doesn&apos;t compile. The easiest workaround is to give a name to the enum.</para></listitem></itemizedlist>
</para><para>Other unexpected compilation errors may arise but they should happen even more rarely than the above-mentioned ones and the solution should usually be quite simple: just use the explicit methods of <ref refid="classwx_uni_char" kindref="compound">wxUniChar</ref> and wxCStrData classes instead of relying on their implicit conversions if the compiler can&apos;t choose among them.</para></sect2>
<sect2 id="overview_unicode_1overview_unicode_data_loss">
<title>Data Loss due To Unicode Conversion Errors</title>
<para><ref refid="classwx_string" kindref="compound">wxString</ref> API provides implicit conversion of the internal Unicode string contents to narrow, char strings. This can be very convenient and is absolutely necessary for backwards compatibility with the existing code using wxWidgets however it is a rather dangerous operation as it can easily give unexpected results if the string contents isn&apos;t convertible to the current locale.</para><para>To be precise, the conversion will always succeed if the string was created from a narrow string initially. It will also succeed if the current encoding is UTF-8 as all Unicode strings are representable in this encoding. However initializing the string using <ref refid="classwx_string_1a2ddc1b7c8e1eb9adbf5874dead5b180b" kindref="member">wxString::FromUTF8()</ref> method and then accessing it as a char string via its <ref refid="classwx_string_1a6418ec90c6d4ffe0b05702be1b35df4f" kindref="member">wxString::c_str()</ref> method is a recipe for disaster as the program may work perfectly well during testing on Unix systems using UTF-8 locale but completely fail under Windows where UTF-8 locales are never used because <ref refid="classwx_string_1a6418ec90c6d4ffe0b05702be1b35df4f" kindref="member">wxString::c_str()</ref> would return an empty string.</para><para>The simplest way to ensure that this doesn&apos;t happen is to avoid conversions to <computeroutput>char*</computeroutput> completely by using <ref refid="classwx_string" kindref="compound">wxString</ref> throughout your program. However if the program never manipulates 8 bit strings internally, using <computeroutput>char*</computeroutput> pointers is safe as well. So the existing code needs to be reviewed when upgrading to wxWidgets 3.0 and the new code should be used with this in mind and ideally avoiding implicit conversions to <computeroutput>char*</computeroutput>.</para></sect2>
<sect2 id="overview_unicode_1overview_unicode_performance">
<title>Unicode Performance Implications</title>
<para>Under Unix systems <ref refid="classwx_string" kindref="compound">wxString</ref> class uses variable-width UTF-8 encoding for internal representation and this implies that it can&apos;t guarantee constant-time access to N-th element of the string any longer as to find the position of this character in the string we have to examine all the preceding ones. Usually this doesn&apos;t matter much because most algorithms used on the strings examine them sequentially anyhow and because <ref refid="classwx_string" kindref="compound">wxString</ref> implements a cache for iterating over the string by index but it can have serious consequences for algorithms using random access to string elements as they typically acquire O(N^2) time complexity instead of O(N) where N is the length of the string.</para><para>Even despite caching the index, indexed access should be replaced with sequential access using string iterators. For example a typical loop: <programlisting><codeline><highlight class="normal"><ref refid="classwx_string" kindref="compound" tooltip="The wxString class has been completely rewritten for wxWidgets 3.0 and this change was actually the m...">wxString</ref><sp/>s(</highlight><highlight class="stringliteral">&quot;hello&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>s.<ref refid="classwx_string_1af63f200410b56436a830550905e20539" kindref="member">length</ref>();<sp/>i++<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">wchar_t</highlight><highlight class="normal"><sp/>ch<sp/>=<sp/>s[i];</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>with<sp/>it</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> should be rewritten as <programlisting><codeline><highlight class="normal"><ref refid="classwx_string" kindref="compound" tooltip="The wxString class has been completely rewritten for wxWidgets 3.0 and this change was actually the m...">wxString</ref><sp/>s(</highlight><highlight class="stringliteral">&quot;hello&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/>wxString::const_iterator<sp/>i<sp/>=<sp/>s.<ref refid="classwx_string_1ad59ca2dd208720b3cce07d90bcb90093" kindref="member">begin</ref>();<sp/>i<sp/>!=<sp/>s.<ref refid="classwx_string_1a6a0f235fff88df5e6b16b5f0e1e719cc" kindref="member">end</ref>();<sp/>++i<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">wchar_t</highlight><highlight class="normal"><sp/>ch<sp/>=<sp/>*i</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>with<sp/>it</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Another, similar, alternative is to use pointer arithmetic: <programlisting><codeline><highlight class="normal"><ref refid="classwx_string" kindref="compound" tooltip="The wxString class has been completely rewritten for wxWidgets 3.0 and this change was actually the m...">wxString</ref><sp/>s(</highlight><highlight class="stringliteral">&quot;hello&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">wchar_t</highlight><highlight class="normal"><sp/>*p<sp/>=<sp/>s.<ref refid="classwx_string_1a6cd4782263a3ed4064eca915eb6e27e6" kindref="member" tooltip="Converts the strings contents to the wide character representation and returns it as a temporary wxWC...">wc_str</ref>();<sp/>*p;<sp/>p++<sp/>)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">wchar_t</highlight><highlight class="normal"><sp/>ch<sp/>=<sp/>*i</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>with<sp/>it</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> however this doesn&apos;t work correctly for strings with embedded <computeroutput>NUL</computeroutput> characters and the use of iterators is generally preferred as they provide some run-time checks (at least in debug build) unlike the raw pointers. But if you do use them, it is better to use <computeroutput>wchar_t</computeroutput> pointers rather than <computeroutput>char</computeroutput> ones to avoid the data loss problems due to conversion as discussed in the previous section.</para></sect2>
</sect1>
<sect1 id="overview_unicode_1overview_unicode_supportout">
<title>Unicode and the Outside World</title>
<para>Even though wxWidgets always uses Unicode internally, not all the other libraries and programs do and even those that do use Unicode may use a different encoding of it. So you need to be able to convert the data to various representations and the <ref refid="classwx_string" kindref="compound">wxString</ref> methods <ref refid="classwx_string_1a2fec30dc8959d4fd3a56cd148bf1e57a" kindref="member">wxString::ToAscii()</ref>, <ref refid="classwx_string_1ac923e0bcfda57ec5064dcade9808db94" kindref="member">wxString::ToUTF8()</ref> (or its synonym <ref refid="classwx_string_1ad71e3ded85939db8af9eeadfa02719ac" kindref="member">wxString::utf8_str()</ref>), <ref refid="classwx_string_1adcfd12e6d0765b1d74bccc3d63d02e98" kindref="member">wxString::mb_str()</ref>, <ref refid="classwx_string_1a6418ec90c6d4ffe0b05702be1b35df4f" kindref="member">wxString::c_str()</ref> and <ref refid="classwx_string_1a6cd4782263a3ed4064eca915eb6e27e6" kindref="member">wxString::wc_str()</ref> can be used for this.</para><para>The first of them should be only used for the string containing 7-bit ASCII characters only, anything else will be replaced by some substitution character. <ref refid="classwx_string_1adcfd12e6d0765b1d74bccc3d63d02e98" kindref="member">wxString::mb_str()</ref> converts the string to the encoding used by the current locale and so can return an empty string if the string contains characters not representable in it as explained in <ref refid="overview_unicode_1overview_unicode_data_loss" kindref="member">Data Loss due To Unicode Conversion Errors</ref>. The same applies to <ref refid="classwx_string_1a6418ec90c6d4ffe0b05702be1b35df4f" kindref="member">wxString::c_str()</ref> if its result is used as a narrow string. Finally, <ref refid="classwx_string_1ac923e0bcfda57ec5064dcade9808db94" kindref="member">wxString::ToUTF8()</ref> and <ref refid="classwx_string_1a6cd4782263a3ed4064eca915eb6e27e6" kindref="member">wxString::wc_str()</ref> functions never fail and always return a pointer to char string containing the UTF-8 representation of the string or <computeroutput>wchar_t</computeroutput> string.</para><para><ref refid="classwx_string" kindref="compound">wxString</ref> also provides two convenience functions: <ref refid="classwx_string_1a5aedc23e9cc2774237d99148d0622661" kindref="member">wxString::From8BitData()</ref> and <ref refid="classwx_string_1afa91a632574bcbba1bf35b54f2c5562a" kindref="member">wxString::To8BitData()</ref>. They can be used to create a <ref refid="classwx_string" kindref="compound">wxString</ref> from arbitrary binary data without supposing that it is in current locale encoding, and then get it back, again, without any conversion or, rather, undoing the conversion used by <ref refid="classwx_string_1a5aedc23e9cc2774237d99148d0622661" kindref="member">wxString::From8BitData()</ref>. Because of this you should only use <ref refid="classwx_string_1a5aedc23e9cc2774237d99148d0622661" kindref="member">wxString::From8BitData()</ref> for the strings created using <ref refid="classwx_string_1afa91a632574bcbba1bf35b54f2c5562a" kindref="member">wxString::To8BitData()</ref>. Also notice that in spite of the availability of these functions, <ref refid="classwx_string" kindref="compound">wxString</ref> is not the ideal class for storing arbitrary binary data as they can take up to 4 times more space than needed (when using <computeroutput>wchar_t</computeroutput> internal representation on the systems where size of wide characters is 4 bytes) and you should consider using <ref refid="classwx_memory_buffer" kindref="compound">wxMemoryBuffer</ref> instead.</para><para>Final word of caution: most of these functions may return either directly the pointer to internal string buffer or a temporary <ref refid="classwx_char_buffer" kindref="compound">wxCharBuffer</ref> or <ref refid="classwx_w_char_buffer" kindref="compound">wxWCharBuffer</ref> object. Such objects are implicitly convertible to <computeroutput>char</computeroutput> and <computeroutput>wchar_t</computeroutput> pointers, respectively, and so the result of, for example, <ref refid="classwx_string_1ac923e0bcfda57ec5064dcade9808db94" kindref="member">wxString::ToUTF8()</ref> can always be passed directly to a function taking <computeroutput>const char*</computeroutput>. However code such as <programlisting><codeline><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*p<sp/>=<sp/>s.<ref refid="classwx_string_1ac923e0bcfda57ec5064dcade9808db94" kindref="member" tooltip="Same as utf8_str().">ToUTF8</ref>();</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">puts(p);<sp/></highlight><highlight class="comment">//<sp/>or<sp/>call<sp/>any<sp/>other<sp/>function<sp/>taking<sp/>const<sp/>char<sp/>*</highlight></codeline>
</programlisting> does <bold>not</bold> work because the temporary buffer returned by <ref refid="classwx_string_1ac923e0bcfda57ec5064dcade9808db94" kindref="member">wxString::ToUTF8()</ref> is destroyed and <computeroutput>p</computeroutput> is left pointing nowhere. To correct this you should use <programlisting><codeline><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classwx_scoped_char_type_buffer" kindref="compound">wxScopedCharBuffer</ref><sp/>p(s.<ref refid="classwx_string_1ac923e0bcfda57ec5064dcade9808db94" kindref="member" tooltip="Same as utf8_str().">ToUTF8</ref>());</highlight></codeline>
<codeline><highlight class="normal">puts(p);</highlight></codeline>
</programlisting> which does work.</para><para>Similarly, wxWX2WCbuf can be used for the return type of <ref refid="classwx_string_1a6cd4782263a3ed4064eca915eb6e27e6" kindref="member">wxString::wc_str()</ref>. But, once again, none of these cryptic types is really needed if you just pass the return value of any of the functions mentioned in this section to another function directly.</para></sect1>
<sect1 id="overview_unicode_1overview_unicode_settings">
<title>Unicode Related Compilation Settings</title>
<para><computeroutput>wxUSE_UNICODE</computeroutput> is now defined as <computeroutput>1</computeroutput> by default to indicate Unicode support. If UTF-8 is used for the internal storage in <ref refid="classwx_string" kindref="compound">wxString</ref>, <computeroutput>wxUSE_UNICODE_UTF8</computeroutput> is also defined, otherwise <computeroutput>wxUSE_UNICODE_WCHAR</computeroutput> is.</para><para>You are encouraged to always use the default build settings of wxWidgets; this avoids the need of different builds of the same application/library because of different &quot;build modes&quot;. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
